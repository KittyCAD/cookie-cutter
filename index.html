<!-- Good morning, afternoon or evening, whoever is here :)

  All assets are base64 encoded, because changing them is a rare occasion.

  To generate new base64 data on Arch Linux (yea yea, you know the joke)
  you can run `base64 -w 0 my-file | xsel -b` to put the output into your
  clipboard in order to paste it easily.

  This project includes a couple of cool things:

  1. A minimal example of nearly complete interaction with the KittyCAD API
     (WebSocket, WebRTC).
  2. An exercise in Rust -> JS conversion for SVG parsing. Rust maps nicely
     to JS.
  3. Some cute ASCII art.
  4. The file itself, an example of how a simple index.html can be effective.
-->
<!DOCTYPE html>
<html>
  <head>
    <title>Cookie Cutter Creater by Zoo</title>
      <link rel="icon" href="https://cookie-cutter.zoo.dev/favicon.png" />
      <meta name="description" content="Generate cookie cutters from SVGs! A fun weekend project by @lf94 showing how to build using only the KittyCAD Design API (and love, obv)." />
      <meta name="twitter:card" content="summary_large_image" />
      <meta name="twitter:title" content="Cookie Cutter Creater by Zoo" />
      <meta name="twitter:site" content="@zoodotdev" />
      <meta name="twitter:description" content="Generate cookie cutters from SVGs! A fun weekend project by @lf94 showing how to build using only the KittyCAD Design API (and love, obv).." />
      <meta name="twitter:image" content="https://cookie-cutter.zoo.dev/meta-image.jpg" />
      <meta name="twitter:image:alt" content="A card with hearts and uwu cute stuff on it with the name and description of the app. It generates cookie cutters from SVG files!" />
      <meta name="twitter:creator" content="@zoodotdev" />
      <meta name="twitter:domain" content="https://cookie-cutter.zoo.dev" />
      <meta name="twitter:url" content="https://cookie-cutter.zoo.dev/" />
      <meta property="og:site_name" content="Cookie Cutter Creater by Zoo" />
      <meta property="og:url" content="https://cookie-cutter.zoo.dev/" />
      <meta
          name="title"
          property="og:title"
          content="Cookie Cutter Creater by Zoo"
      />
      <meta
          name="description"
          property="og:description"
          content="Generate cookie cutters from SVGs! A fun weekend project by @lf94 showing how to build using only the KittyCAD Design API (and love, obv)."
      />
      <meta
          property="og:image"
          content="https://cookie-cutter.zoo.dev/meta-image.jpg"
      />
      <meta
          property="og:image:secure_url"
          content="https://cookie-cutter.zoo.dev/meta-image.jpg"
      />
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <style>
      @font-face {
        font-family: "Titan One";
        src: url(data:font/ttf;base64,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AGwALgBvAHIAZwAvAE8ARgBMAHcAdwB3AC4AcgBmAHUAZQBuAHoAYQBsAGkAZABhAC4AYwBvAG0AUgBvAGQAcgBpAGcAbwAgAEYAdQBlAG4AegBhAGwAaQBkAGEAVABpAHQAYQBuACAAaQBzACAAYQAgAHQAcgBhAGQAZQBtAGEAcgBrACAAbwBmACAAUgBvAGQAcgBpAGcAbwAgAEYAdQBlAG4AegBhAGwAaQBkAGEALgBUAGkAdABhAG4ATwBuAGUAVgBlAHIAcwBpAG8AbgAgADEALgAwADAAMQBSAG8AZAByAGkAZwBvAEYAdQBlAG4AegBhAGwAaQBkAGEAOgAgAFQAaQB0AGEAbgAgAE8AbgBlADoAIAAyADAAMQAxAFIAZQBnAHUAbABhAHIAVABpAHQAYQBuACAATwBuAGUAQwBvAHAAeQByAGkAZwBoAHQAIAAoAGMAKQAgADIAMAAxADEAIABSAG8AZAByAGkAZwBvACAARgB1AGUAbgB6AGEAbABpAGQAYQAgACgAaABlAGwAbABvAEAAcgBmAHUAZQBuAHoAYQBsAGkAZABhAC4AYwBvAG0AKQAsACAAdwBpAHQAaAAgAFIAZQBzAGUAcgB2AGUAZAAgAEYAbwBuAHQAIABOAGEAbQBlACAAIgBUAGkAdABhAG4AIABPAG4AZQAiASwAAAAAAAABTQAAAOEAAAFMAB8CCgAeAy4ACgKYAB4DzwAeAwgAHgEFAB4BwgAjAcIAHgIuAA8CKQAeASUAKAIpAB4BJQAoAaIAGQLWAB4BxQAPAmYAHgJhAB4CagAPAmMAHgKWAB4CGwAKApMAHgKWAB4BJQAoASUAKAFqAA8CKQAeAWoAHgJXABQDEgAoAuIACgLBACgCkAAeAtsAKAJiACgCSgAoAqIAHgLXACgBZwAoAZoACgLFACgCIAAoA3AAKALeACgC9AAZAsMAKALqABQCzAAoAo4AGQKLABQC1gAoAtcACgP4AAoC0QAKAroACgJzABQB1gAyAXAAAAHWADIBuAAoAlEADwF8ADICmAAeApwAIwImABkCmAAZAoAAGQIvAAoCkwAZApkAIwFeACMBkAAAAnwAIwFUACMD1QAjAqEAIwKtABkClwAjApcAGQJKACMCYwAZAeIACgKmACMCpwAFA9cABQKnAAUClQAjAkAAGQHSAAoBGAAtAdIALQIxACgBTAAeAiEAGQJSAAoC0QAkAroACgEYAC0CQwAUAjoAKAKtABkBTAAPAswADwIpAB4DQQAAAq0AGQIpAB4BdwAtAikAHgFqABkBbAAZAXwAMgKwACgCvwAUASUAKAEMACgBEwAPAXcALQK2AB4DAwAeAzwAHgMfAB4CVwAeAuwADwLsAA8C7AAPAuwADwLsAA8C7AAPA+wADwKVACMCZwAtAmcALQJnAC0CZwAtAXEADwFxAC0BcQAJAXH/yQMIAAoC3gAoAwgAIwMIACMDCAAjAwgAIwMIACMCKQA0AwgAIwLgAC0C4AAtAuAALQLgAC0CugAKAs4ALQOXAAoCkwAZApMAGQKTABkCkwAZApMAGQKTABkDygAZAiEAGQKAABkCgAAZAoAAGQKAABkBVQABAVUAIwFV//wBVf+8AsEAGQKhACMCrQAZAq0AGQKtABkCrQAZAq0AGQIVABQCrQAZAqYAIwKmACMCpgAjAqYAIwKVACMC3wAfApUAIwLsAA8CkwAZAuwADwKTABkC7AAPApMAGQKVACMCIQAZApUAIwIhABkClQAjAiEAGQKVACMCIQAZAuUALQOgABkDCAAKAsEAGQJnAC0CgAAZAmcALQKAABkCZwAtAoAAGQJnAC0CgAAZAmcALQKAABkCpwAjApMAGQKnACMCkwAZAqcAIwKTABkC4QAtApkAIwKZ/8oBcf/OAVX/ugHP//EBz//xAXEAKgFVAB0BcQAeAV4AEwFVACMDFQAtAv0AKAGkAA8BcwAKAiUALQFUACMCWAAtAmIAIwJfAC0CYAAjAmMACgIpAAoC6AAtAqEAIwLoAC0CoQAjAugALQKhACMDCAAjAq0AGQMIACMCrQAZAwgAIwKtABkEAAAoA+cAGQLRAC0CLAAjAk8AKALRAC0CLAAjApgAHgJDABQCmAAeAkMAFAKYAB4CQwAUApgAHgJDABQCiwAUAvQACgLgAC0CpgAjAuAALQKmACMC4AAtAqYAIwLgAC0CpgAjAuAALQKmACMC4AAtAqYAIwQCAA8D4QAKAroACgKVACMCugAKAn0AGQJAABkCfQAZAkAAGQJ9ABkCQAAZAi8ACgG4ACgBuAAoAWwAKAF8ADIBSgAyAYoAMgIxACgCnwAyAXwAMgKhAB4DugAeARIAHgESACgBEgAoAjUAHgI1ACgCNQAoAgEACgIBAAoBdwAtA7QARgWGAB4BkgAPAYgAHgGi/8sCcQAKApAAGQM8AB4DjAAeAikAHgKoAAcCqAA/AqgAQQKoADoCqABAAqgAJwKoAFECqAAoAqgAJwKoAAcCqABuAqgANAKoAEYCqAAjAqgAUgKoACgCqAAjAqgAHgKoACgBtwAZARMADwFqABkBbAAZAXAADwFsABkBgwAZAToADwGCABkBhAAZAbcAGQETAA8BagAZAWwAGQFwAA8BZwAZAYMAGQE6AA8BggAZAYQAGQKoAI0C4AAjAgQACgKCACMCYgAjAp0ADwJKACMCngAjAnUACgKzACMCngAjAtQAMgKLACgC8AAyAnoAMgJiADICswAoAusAMgF7ADIBrgAUAtoAMgI0ADIDhAAyAvIAMgMAACgC4AAyAwAAKALdADICnAAjApUAGQLzADIC7AAUBAsAFALpABQC0AAUApIAIwL1ABQDjgAKAu0ACgLtAA8ETAAKAAoAAAACAAAAAAAA/7UAMgAAAAAAAAAAAAAAAAAAAAAAAAAAAZ8AAAABAAIAAwAEAAUABgAHAAgACQAKAAsADAANAA4ADwAQABEAEgATABQAFQAWABcAGAAZABoAGwAcAB0AHgAfACAAIQAiACMAJAAlACYAJwAoACkAKgArACwALQAuAC8AMAAxADIAMwA0ADUANgA3ADgAOQA6ADsAPAA9AD4APwBAAEEAQgBDAEQARQBGAEcASABJAEoASwBMAE0ATgBPAFAAUQBSAFMAVABVAFYAVwBYAFkAWgBbAFwAXQBeAF8AYABhAKMAhACFAL0AlgDoAIYAjgCLAJ0AqQCkAQIAigDaAIMAkwDyAPMAjQCXAIgAwwDeAPEAngCqAPUA9AD2AKIArQDJAMcArgBiAGMAkABkAMsAZQDIAMoAzwDMAM0AzgDpAGYA0wDQANEArwBnAPAAkQDWANQA1QBoAOsA7QCJAGoAaQBrAG0AbABuAKAAbwBxAHAAcgBzAHUAdAB2AHcA6gB4AHoAeQB7AH0AfAC4AKEAfwB+AIAAgQDsAO4AugEDAQQBBQEGAQcBCAD9AP4BCQEKAQsBDAD/AQABDQEOAQ8BAQEQAREBEgETARQBFQEWARcBGAEZARoBGwD4APkBHAEdAR4BHwEgASEBIgEjASQBJQEmAScBKADXASkBKgErASwBLQEuAS8BMAExATIA4gDjATMBNAE1ATYBNwE4ATkBOgE7ATwBPQE+ALAAsQE/AUABQQFCAUMBRAFFAUYBRwD7APwA5ADlAUgBSQFKAUsBTAFNAU4BTwFQAVEBUgFTAVQBVQFWAVcBWAFZALsBWgFbAVwBXQDmAOcApgDYAOEA2wDcAN0A4ADZAN8BXgCyALMAtgC3AMQAtAC1AMUAggDCAIcAqwDGAL4AvwC8AV8AjAFgAWEA7wFiAWMBZAFlAWYBZwFoAWkBagFrAWwBbQFuAW8BcAFxAXIBcwF0AXUBdgF3AXgBeQF6AXsBfAF9AX4BfwGAAYEBggGDAYQBhQGGAYcBiAGJAYoBiwGMAY0BjgGPAZABkQGSAZMBlAGVAZYBlwGYAZkBmgGbAZwBnQGeAZ8BoAGhAaIBowGkAaUBpgGnAagBqQGqAasBrAGtAa4AwADBAa8BsAd1bmkwMEFEB0FtYWNyb24HYW1hY3JvbgZBYnJldmUGYWJyZXZlB0FvZ29uZWsHYW9nb25lawtDY2lyY3VtZmxleAtjY2lyY3VtZmxleApDZG90YWNjZW50CmNkb3RhY2NlbnQGRGNhcm9uBmRjYXJvbgZEY3JvYXQHRW1hY3JvbgdlbWFjcm9uBkVicmV2ZQZlYnJldmUKRWRvdGFjY2VudAplZG90YWNjZW50B0VvZ29uZWsHZW9nb25lawZFY2Fyb24GZWNhcm9uC0djaXJjdW1mbGV4C2djaXJjdW1mbGV4Ckdkb3RhY2NlbnQKZ2RvdGFjY2VudAtIY2lyY3VtZmxleAtoY2lyY3VtZmxleARoYmFyBkl0aWxkZQZpdGlsZGUHSW1hY3JvbgdpbWFjcm9uBklicmV2ZQZpYnJldmUHSW9nb25lawdpb2dvbmVrAklKAmlqC0pjaXJjdW1mbGV4C2pjaXJjdW1mbGV4BkxhY3V0ZQZsYWN1dGUGTGNhcm9uBmxjYXJvbgRMZG90BGxkb3QGTmFjdXRlBm5hY3V0ZQZOY2Fyb24GbmNhcm9uA0VuZwNlbmcHT21hY3JvbgdvbWFjcm9uBk9icmV2ZQZvYnJldmUNT2h1bmdhcnVtbGF1dA1vaHVuZ2FydW1sYXV0BlJhY3V0ZQZyYWN1dGUMcmNvbW1hYWNjZW50BlJjYXJvbgZyY2Fyb24GU2FjdXRlBnNhY3V0ZQtTY2lyY3VtZmxleAtzY2lyY3VtZmxleAZUY2Fyb24GdGNhcm9uBlV0aWxkZQZ1dGlsZGUHVW1hY3Jvbgd1bWFjcm9uBlVicmV2ZQZ1YnJldmUFVXJpbmcFdXJpbmcNVWh1bmdhcnVtbGF1dA11aHVuZ2FydW1sYXV0B1VvZ29uZWsHdW9nb25lawtXY2lyY3VtZmxleAt3Y2lyY3VtZmxleAtZY2lyY3VtZmxleAt5Y2lyY3VtZmxleAZaYWN1dGUGemFjdXRlClpkb3RhY2NlbnQKemRvdGFjY2VudAxkb3RhY2NlbnRjbWIERXVybwhvbmV0aGlyZAl0d290aGlyZHMIemVyby50YWIHdHdvLnRhYgl0aHJlZS50YWIIZm91ci50YWIIZml2ZS50YWIHc2l4LnRhYglzZXZlbi50YWIJZWlnaHQudGFiCG5pbmUudGFiC3plcm8ub3MudGFiCm9uZS5vcy50YWIKdHdvLm9zLnRhYgx0aHJlZS5vcy50YWILZm91ci5vcy50YWILZml2ZS5vcy50YWIKc2l4Lm9zLnRhYgxzZXZlbi5vcy50YWIMZWlnaHQub3MudGFiC25pbmUub3MudGFiCHplcm8uZGVuB29uZS5kZW4HdHdvLmRlbgl0aHJlZS5kZW4IZm91ci5kZW4IZml2ZS5kZW4Hc2l4LmRlbglzZXZlbi5kZW4JZWlnaHQuZGVuCG5pbmUuZGVuCHplcm8ubnVtB29uZS5udW0HdHdvLm51bQl0aHJlZS5udW0IZm91ci5udW0IZml2ZS5udW0Hc2l4Lm51bQlzZXZlbi5udW0JZWlnaHQubnVtCG5pbmUubnVtB29uZS50YWIHemVyby5vcwZvbmUub3MGdHdvLm9zCHRocmVlLm9zB2ZvdXIub3MHZml2ZS5vcwZzaXgub3MIc2V2ZW4ub3MIZWlnaHQub3MHbmluZS5vcwRCLnNjBEMuc2MERC5zYwRFLnNjBEYuc2MERy5zYwRILnNjBEkuc2MESi5zYwRLLnNjBEwuc2METS5zYwROLnNjBE8uc2MEUC5zYwRRLnNjBFIuc2MEUy5zYwRULnNjBFUuc2MEVi5zYwRXLnNjBFguc2MEWS5zYwRaLnNjBEEuc2MCZmYDZmZpA2ZmbAAAAAACAB//rwEuAtQACwATAAASNjIVFAMOASMiJwMABiIm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) format('truetype');
      }

      @font-face {
        font-family: "Owners";
        src: url(data:font/otf;base64,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AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAD/8f/7//v/iP+XAAUAAAAAAAAAAAAAAAAAAP/2//H/8QAAAAD/8f/2//v/8f/2AAUAAP/YAAAAAAAA//YAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA//EAAP/s//YAAP/7AAD/+wAAAAAAAAAAAAAAAAAA//b/5wAFAAD/+//2//v/+wAFAAUAAAAAAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD/4gAA//sABQAA/7r/sP/sAAAAAAAAAAAAAAAAAAD/+wAF//YAAAAAAAUAAAAA//b/+//2AAD/4gAAAAAAAAAAAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD/3f/O/93/g/+hAAAAAAAAAAAAAAAAAAAAAP/2/93/yQAPAAD/4v/s/+f/2P/dAAD/zv/OAAAAAAAA/+z/3QAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA/8kAAP/7//v/+//7//b/+wAAAAAAAAAAAAAAAAAA//v/9gAAAAAAAP/2//b/+wAFAAAAAAAAAAAAAAAAAAD/+wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA//H/9gAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD/9gAA/+z/5wAFAAr/xP/i/90AAAAAAAD/4v/xAAAACgAFAAAAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP/7AAD/+wAA//v/+//xAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD/8f/7AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA//v/+//n//sAAP/x//YAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP/Y/9gAAAAA//YAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8AAP/d/7//0/9R/1EABQAAAAAAAAAAAAAAAAAA//b/2P+hAAAAAP/Y/+L/5/+6/7oABf/E/6EAAAAAAAD/2P+/AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD/8QAAAAD/+wAA/3n/ef/xAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD/tQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP/xAAD/9gAAAAD/+wAA//sAAAAAAAAAAAAAAAAAAP/2//EAAAAA//v/8f/2//sAAAAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA/+cAAAAAAAAAAP/i/9P/0//s//YACv+1AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAD/5//dAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA//sAAP/7AAD/+//7//EAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP/x//YAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP+N//b/ef/E/90AAAAF//sAAAAAAAAAAAAAAAAAAP+c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AAD/+//i/+L/9gAFAAD/9gAAAAAAAAAAAAD/+//7/7oAAAAAAAAAAAAAAAAAAP/7AAAAAP/7AAAAAAAFAAUAAAAFAAAAAP/JAAAAAAAAAAD/q//2/7D/5wAAAAAABQAAAAAAAAAAAAAAAAAA/+L/zv/O//EAAP/x/87/0//sAAD/9v/xAAAAAAAAAAAAAP/2//v/tQAA//sAAAAAAAAAAAAA//sAAAAA//YAAP/7AAUABQAA//sAAAAA/7AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA//v/7AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA//b/+wAAAAAABQAAAAAAAAAA//sAAP/d//sAAP/7//sAAAAAAAD/5//d/87/+wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP/xAAAAAAAAAAAAAP/n//EAAAAAAAD/9v/2AAAAAAAAAAAAAAAAAAAAAAAA/8n/9v/xAAD/+wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAD/5//x/+f/+wAF/+IAAAAAAAUAAAAA/+L/7P/nAAAAAP/i/+IAAAAAAAAAAAAAAAAABf/dAAX/sP/n/93/3f/Y/9MAAAAAAAAAAP/YAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD/9gAAAAAAAP/sAAAAAAAAAAAAAP/n//EAAAAAAAD/7P/sAAAAAAAAAAAAAAAAAAAAAAAA/8n/7P/s//b/+wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAD/5//2/+f/+wAF/+IAAAAAAAUAAAAA/+L/7P/nAAAAAP/i/+IAAAAAAAAAAAAAAAAAAAAAAAX/sP/n/93/8f/n/9MAAAAAAAAAAP/YAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA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AA0AEwAZACMAKQAvADUAOwBBAEcATQBTAAD//wAPAAIACAAOABQAGgAeACQAKgAwADYAPABCAEgATgBUAAD//wAPAAMACQAPABUAGwAfACUAKwAxADcAPQBDAEkATwBVAAD//wAPAAQACgAQABYAHAAgACYALAAyADgAPgBEAEoAUABWAAD//wAPAAUACwARABcAHQAhACcALQAzADkAPwBFAEsAUQBXAFhhYWx0AhJhYWx0AhphYWx0AiJhYWx0AiphYWx0AjJhYWx0AjpjYWx0AkJjYWx0AkhjYWx0Ak5jYWx0AlRjYWx0AlpjYWx0AmBjYXNlAmZjYXNlAmxjYXNlAnJjYXNlAnhjYXNlAn5jYXNlAoRkbm9tAopkbm9tApBkbm9tApZkbm9tApxkbm9tAqJkbm9tAqhmcmFjAq5mcmFjArRmcmFjArpmcmFjAsBmcmFjAsZmcmFjAsxsb2NsAtJsb2NsAthsb2NsAt5sb2NsAuRudW1yAupudW1yAvBudW1yAvZudW1yAvxudW1yAwJudW1yAwhzczAxAw5zczAxAxRzczAxAxpzczAxAyBzczAxAyZzczAxAyxzczAyAzJzczAyAzhzczAyAz5zczAyA0RzczAyA0pzczAyA1BzczAzA1ZzczAzA1xzczAzA2JzczAzA2hzczAzA25zczAzA3RzczA0A3pzczA0A4BzczA0A4ZzczA0A4xzczA0A5JzczA0A5hzczA1A55zczA1A6RzczA1A6pzczA1A7BzczA1A7ZzczA1A7xzczA2A8JzczA2A8hzczA2A85zczA2A9RzczA2A9pzczA2A+BzdWJzA+ZzdWJzA+xzdWJzA/JzdWJzA/hzdWJzA/5zdWJzBARzdXBzBApzdXBzBBBzdXBzBBZzdXBzBBxzdXBzBCJzdXBzBCgAAAACAAAAAQAAAAIAAAABAAAAAgAAAAEAAAACAAAAAQAAAAIAAAABAAAAAgAAAAEAAAABABAAAAABABAAAAABABAAAAABABAAAAABABAAAAABABAAAAABAAoAAAABAAoAAAABAAoAAAABAAoAAAABAAoAAAABAAoAAAABAA4AAAABAA4AAAABAA4AAAABAA4AAAABAA4AAAABAA4AAAABAA8AAAABAA8AAAABAA8AAAABAA8AAAABAA8AAAABAA8AAAABAAIAAAABAAIAAAABAAMAAAABAAIAAAABAAwAAAABAAwAAAABAAwAAAABAAwAAAABAAwAAAABAAwAAAABAAQAAAABAAQAAAABAAQAAAABAAQAAAABAAQAAAABAAQAAAABAAUAAAABAAUAAAABAAUAAAABAAUAAAABAAUAAAABAAUAAAABAAYAAAABAAYAAAABAAYAAAABAAYAAAABAAYAAAABAAYAAAABAAcAAAABAAcAAAABAAcAAAABAAcAAAABAAcAAAABAAcAAAABAAgAAAABAAgAAAABAAgAAAABAAgAAAABAAgAAAABAAgAAAABAAkAAAABAAkAAAABAAkAAAABAAkAAAABAAkAAAABAAkAAAABAA0AAAABAA0AAAABAA0AAAABAA0AAAABAA0AAAABAA0AAAABAAsAAAABAAsAAAABAAsAAAABAAsAAAABAAsAAAABAAsAEQAkACwANAA8AEQATABUAFwAZABsAHQAfACEAIwAlACcAKQAAQAAAAEDJgADAAAAAQNGAAEAAAABAHgAAQAAAAEAeAABAAAAAQB2AAEAAAABAIgAAQAAAAEAiAABAAAAAQCIAAQAAAABAIoABAAAAAEAuAABAAAAAQEOAAEAAAABARIAAQAAAAEBJAABAAAAAQE2AAEAAAABAUgABAAAAAEBWgAEAAAAAQIgAAIDHAABAGkAAgMaAAAAAgMYAAoAfACDAH0AfgB/AIAAgQCCAIQAhQACAyAAAQA9AAIDHgABAMAAAgMcAAIAnQCeAAEDGgAEAA4AGAAiACwAAQAEAPYAAgC0AAEABAD1AAIBBgABAAQA9wACAKUAAQAEAPQAAgCoAAEC8AAGABIAHAAmADgAQgBMAAEABAD8AAIAtAABAAQA/gACALQAAgAGAAwA/QACAKMA/wACAKQAAQAEAPsAAgEGAAEABAD5AAIBBgACAAYADAD6AAIAtgD4AAIBBAACAqIAAwCUAJcAugACAqAACgDPANAA0QDSANMA1ADVANYA1wDYAAIChgAKAM8A0ADRANIA0wDUANUA1gDXANgAAgJsAAoA2QDaANsA3ADdAN4A3wDgAOEA4gACAlIACgDZANoA2wDcAN0A3gDfAOAA4QDiAAECQgAHABQALABqAIAAoACsAMIAAgAGABAA8wAEAKMAxQDFAPIAAwCjAMUABgAOABYAHgAmAC4ANgDjAAMAowDHAOQAAwCjAMgA5gADAKMAyQDoAAMAowDKAOwAAwCjAMsA7gADAKMAzQACAAYADgDlAAMAowDIAOkAAwCjAMoAAwAIABAAGADnAAMAowDJAOoAAwCjAMoA7wADAKMAzQABAAQA6wADAKMAygACAAYADgDtAAMAowDLAPAAAwCjAM0AAQAEAPEAAwCjAM0AAQGEAAgAFgAgACoANAA+AFgAYgBsAAEABAD8AAIAtAABAAQA/gACALQAAQAEAPYAAgC0AAEABAD1AAIBBgADAAgADgAUAP0AAgCjAP8AAgCkAPcAAgClAAEABAD7AAIBBgABAAQA+QACAQYAAwAIAA4AFAD0AAIAqAD6AAIAtgD4AAIBBAACARIAEQA9AHwAgwB9AH4AfwCAAIEAggCEAIUAlACXAJ0AngC6AMAAAQC8AAoAGgAgACYALAAyADgAPgBEAEoAUAACAM8A2QACANAA2gACANEA2wACANIA3AACANMA3QACANQA3gACANUA3wACANYA4AACANcA4QACANgA4gABAAEARgABAAAAAgAFAD4APgAAAFYAVgABAFgAWgACAFwAXgAFAHgAeQAIAAEAAQATAAEAAQC/AAEAAgCYAJoAAQAEAKUAqAC0AQUAAQAGAKMApAC0ALYBBAEFAAEAAwCTAJYAuQACAAEAxQDOAAAAAgACAMUAygAAAMwAzAAGAAEACACjAKQApQCoALQAtgEEAQUAAQARABMAPgBWAFgAWQBaAFwAXQBeAHgAeQCTAJYAmACaALkAvwHbACkAygAAAMoAAAJq//wCQwAgAnEAEwJcACACCAAgAgQAIAKGABMCUgAgAJoAIAItAA0CMAAgAf4AIAK/ACACSQAgAoYAEwI4ACAChgATAj4AIAI7AA4CUQALAlYAHAJq//wDMgAHAk3/+QJg//kCHQAPAmr//AJq//wCav/8A8//+wJq//wCav/8Amr//AJxABMCCAAgAggAIAIIACACCAAgAncAAwCaACAAmv+5AJr/5ACa/8ECSQAgAoYAEwKGABMChgATA8IAEwKGABMChgAPAoYAEwI5ACACVgAcAlYAHAJWABwCVgAcAmD/+QJg//kChgATAdoAEAIVAB0B9wASAhUAEgH8ABIBdwAMAhUAEgHuAB0AkQAdAJH/1AHRAB0AkQAeAy0AHQHuAB0CCQASAhUAHQIVABIBKgAdAdQADwGGAAwB7gAcAef/+wKnAAYB3P/3Aen/+wG3AA0B2gAQAdoAEAHaABADUAAPAdoAEAHaABAB2gAQAfcAEgH8ABIB/AASAfwAEgH8ABICCgASAgkAHQCRAB4Akf/JAJH/7gCRAB0Akf/OAe4AHQIJABICCQASAgkAEgOOABICCQASAgkADAIJABICFQAdAe4AHAHuABwB7gAcAe4AHAHp//sB6f/7AWYACwGLAA0CFQASAhUAEgIVABICFQASAhUAEgIVABICFQASAe4AHAHuABwB7gAcAnwAEQIcAIICHADlAhwAfQIcAJwCHAClAhwAlQCUABgAlAAUAJQAGACVABQBvQAYAJcAGQCXABkAlwAZAf4AEwH+ABIB/gASAJQAGQCUABQBGwAZARsAFAEbABQAlAAYARsAGAEqAAoBKgAIAcYACgHGAAgBov/MAaL/+ACKAB0BTgAWAJQAGAFSAB0B/QAdAtYAHQEwABkBMAAFARsAHAEbAA8BSgASAUoADwGVABYCWAAUAkwAEAHpABYBzQASAcz//wCFABgA+AAYArMAEwKzABMCrQATAhQAFgMwAAwCowAPAiEAEgIgABIB7QASAh4ADwJs//sCugAIAlwAEwDqAAcCBQAOAiEADgJGABACFAAQAjIAEwIOAA0CLwASAjIAEgErAAoAhwAFAQYABwEUAAgBJAAJAQ0ACAEbAAkBBwAIARoACQEbAAkBKwAKAIcABQEGAAcBFAAIASQACQENAAgBGwAJAQcACAEaAAkBGwAJAioADQI3AA0CewAHAhIADQJJAAgCQQANAokABwKGAAgCnQAJAjgADQJnAAgCRQANAn0ACAJyAAgCRAANAmUACgOTAAoDDQALAw0ADwJwABACcAATAvQACwL0ABkC9AALAvQAGQLSABAC0gAQAtIAEALSABAB/wAdAf8AHQH/ADUB/wAdAf8AHQH/AB0B/wAdAVUAGQADAAAAAAAA/7UAMgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAgAAAAMAAAAUAAMAAQAAABQABAHyAAAAMgAgAAQAEgAvADkAQABaAGAAegB+AKMApQCrALQA/wFTAXgC3CAUIBkgHiAiICYgOiCsISLgBv//AAAAIAAwADoAQQBbAGEAewCgAKUApwCtALYBUgF4AtwgEyAYIBwgIiAmIDkgrCEi4AD//wAAAJUAAP/CAAD/3QAAAAAAHgAAAAAAAAAAAAAAAOCWAAAAAAAA4GvgZuAS35sAAAABADIAAABOAAAAWAAAAGAAZgAAAGoAcgCAARIBFAEUAAABEgEUARgAAAAAAAAAAAEQAAAAAQCSALgAxAC/APIAhgC3AKsArACxAQAAjgCoAI0AowCPAJABBQEEAQYAlQC5AK0ApACuALQAtgCHAK8ApQCwALUAAgCTAMEAwgCyAIsAuwB6AKEAqAC8AIoBBwEBANEA0gCIALMApwCMANAAewCiAOYA4wDnAJYAIQAdAB4AIwAfACIAIAAkACgAJQAmACcALQAqACsALAApAC4AMwAvADAANQAxAQIANAA6ADcAOAA5ADsANgBlAFwAWABZAF4AWgBdAFsAXwBjAGAAYQBiAGoAZgBnAGgAZABrAHAAbABtAHIAbgEDAHEAdwB0AHUAdgB4AHMAeQAyAG8APACJAJgAmQCaAJsAnACmAAQABwAVAD8AUABUAFYAAA==) format("opentype");
        font-display:auto;font-style:normal;font-weight:400;font-stretch:normal;
      }

      p {
        font-family: "Owners", sans-serif;
        font-size: 16px;
        color: #FF0000;
      }

      input[type="file"] {
        display: none;
      }

      footer {
        padding: 5px 10px 5px 10px;
        border: 1px solid #FF3232;
        border-bottom: none;

        color: #FF3232;
        font-family: Owners;
        font-size: 12px;
        font-weight: 400;
        line-height: 17px;
        letter-spacing: 0em;
        text-align: left;

        margin-top: 20px;
      }

      footer p {
        margin: 0;
      }

      .mouse-wait {
        cursor: wait;
      }

      html, body, #pseudo-body {
        border: 0;
        margin: 0;
        padding: 0;
        height: 100%;
        height: 100dvh; /* https://developer.mozilla.org/en-US/docs/Web/CSS/length#vh */
      }

      body {
        background: radial-gradient(77.49% 77.49% at 50% 22.51%, #FFF5F5 0%, #FFE9E9 100%);
        background-repeat: no-repeat;
      }

      #pseudo-body {
        max-width: 360px;
        margin-inline: auto;
        display: flex;
        flex-direction: column;
        justify-content: stretch;
      }

      header {
        padding-bottom: 32px;
        display: flex;
        align-items: center;
        justify-content: space-between;
      }

      #title {
        padding-top: 16px;
      }

      #sign-in {
        font-family: "Titan One";
        color: #FF3232;
        font-family: Titan One;
        font-size: 12px;
        font-weight: 400;
        line-height: 14px;
        letter-spacing: 0em;
        text-align: left;

        display: flex;
        flex-direction: row;
        align-items: center;
        gap: 1ch;
      }

      /* Hide the default browser arrow for the summary tag */
      #uwu,
      details > summary {
        list-style: none;
        width: 3rem;
        height: 3rem;
        border-radius: 100px;
        overflow: hidden;

        display: grid;
        place-content: center;

        border: 10px solid #FF3232;
        transform-origin: center;
        transform: rotate(30deg);
        cursor: pointer;
      }

      #uwu,
      details > summary {
        animation: rock 1s infinite alternate;
      }
      @media (prefers-reduced-motion: reduce) {
        #uwu {
          animation: none;
        }
      }

      @keyframes rock {
        0% {
          transform: rotate(25deg);
        }
        100% {
          transform: rotate(35deg);
        }
      }

      #avatar,
      #uwu > img {
        width: 100%;
        height: 100%;
        object-fit: cover;
      }

      details summary::-webkit-details-marker {
        display: none;
      }

      /* Positions the details contents as a menu-like item */
      details {
        position: relative;
      }

      #account-menu {
        position: absolute;
        top: 100%;
        right: 0;
        min-width: 200px;
        max-width: 300px;
        margin-top: 8px;

        font-family: "Titan One";
        color: #FF3232;
        font-family: Titan One;
        background-color: #FFF;

        border: 1px solid #FF3232;
        border-radius: 4px;
      }

      #user-info {
        background-color: #FF3232;
        padding: 8px;
        display: flex;
        flex-direction: column;
        gap: 8px;
      }

      #user-info > p {
        color: #FFE9E9;
      }

      #user-name {
        font-size: 16px;
        margin: 0;
      }

      #user-email {
        font-family: "Owners";
        letter-spacing: 0.04em;
        margin: 0;
      }

      #sign-out {
        padding: 8px;
        border: none;
        background: none;
        font-size: 24px;
        margin: none;
        color: #FF3232;
      }

      .svg-file-uploader {
        flex-grow: 1;
        padding: 10px;
        border-radius: 8px;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        gap: 20px;
        border: 4px dashed #FF7B7B;

        color: #FF3232;
        font-family: "Owners";
        font-size: 16px;
        font-weight: 400;
        line-height: 22px;
        letter-spacing: 0.04em;
        text-align: center;
        
        cursor: pointer;
      }
      
      .svg-file-uploader > * {
        user-select: none;
      }

      #configuration {
        flex-grow: 1;
        margin-block: 48px;
        display: flex;
        flex-direction: column;
        gap: 0px;
        justify-content: stretch;
      }

      #upload-fields {
        display: flex;
        flex-grow: 1;
        flex-direction: column;
        gap: 20px;
        justify-content: stretch;
      }

      #generation {
        min-height: 272px;
        flex-grow: 1;
        justify-content: center;
        margin-inline: auto;
      }

      section {
        display: flex;
        flex-direction: column;
        gap: 20px;
      }

      #outline > svg, #stamp > svg, #outline > img, #stamp > img  {
        width: 87px;
        height: auto;
      }


      #viewer {
        border-radius: 12px;
        border: 5px solid #FF3232;
        display: grid;
        place-items: center;
        place-content: center;
        overflow: hidden;
      }

      #stream {
        background-color: black;
        width: 100%;
        max-width: 100%;
        height: auto;
        filter: invert(100%);
      }

      button {
        background: linear-gradient(0deg, #FF0000, #FF0000),
        linear-gradient(0deg, #FF3232, #FF3232);
        border: 5px solid #FF0000;
        box-shadow: 0px 14px 14px 0px #FF000033, 0px 4px 7px 0px #DB00004D;
        width: 100%;
        padding: 10px;
        border-radius: 8px;
        border: 5px;
        gap: 50px;

        color: #FFFCFC;
        font-family: "Titan One";
        font-size: 32px;
        font-weight: 400;
        line-height: 1.13;
        letter-spacing: 0em;
        text-align: left;
        cursor: pointer;
      }

      body:not(.signed-in) #configuration {
        position: relative;
      }

      body:not(.signed-in) #configuration > * {
        pointer-events: none;
      }

      body:not(.signed-in) #configuration::before {
        content: "Sign in pls!";
        position: absolute;
        cursor: not-allowed;
        font-size: 4rem;
        color: #FF3232;
        inset: 1rem ;
        display: grid;
        place-items: center;
        opacity: 1;
        padding: 0.5em;
        place-items: center;
        font-family: "Titan One";
        background-color: #FFE9E9DF;
        border: 3px solid #FF3232;
        border-radius: 8px;
      }

      body:not(.signed-in) #configuration::after {
        content: "Our APIs need to eat tokens to poop out cookie cutters :3";
        font-family: "Owners";
        pointer-events: none;
        font-size: 1rem;
        position: absolute;
        bottom: 2rem;
        left: 2rem;
        color: #FF3232;
      }

      button.secondary {
        background: transparent;
        box-shadow: none;
        color: #FF3232;
        border: 1px solid #FF3232;
      }

      .center {
        display: flex;
        flex-direction: row;
        align-items: center;
        justify-content: center;
      }

      button:active {
        transition: box-shadow 0.26s;
        box-shadow: 0px 4px 4px 0px #FF000033, 0px 1px 0px 0px #DB00004D;
      }

      a { color: #FF3232; }
      a > img {
        text-decoration: none;
      }

      .hide {
        display: none !important;
      }

      .fade-out {
        animation: 1s ease-out 0s fade-out;
      }

      .fade-in {
        animation: 1s ease-out 0s fade-in;
      }

      @keyframes fade-out {
        from { opacity: 1; }
        to { opacity: 0; }
      }

      @keyframes fade-in {
        from { opacity: 0; }
        to { opacity: 1; }
      }

      @media (min-width: 768px) {
        #pseudo-body {
          max-width: none;
          margin-inline: 5vw;
          display: flex;
          flex-direction: column;
        }

        #sign-in {
          font-size: 20px;
          line-height: 1;
        }
        
        #configuration {
          margin-block: 80px;
        }

        #upload-fields {
          flex-grow: 1;
          display: flex;
          flex-direction: row;
          align-items: stretch;
          gap: 20px;
        }

        .svg-file-uploader {
          height: auto;
          display: flex;
          flex-grow: 1;
          flex-direction: column;
          align-items: center;
          justify-content: center;

          font-size: 20px;
        }

        .svg-file-uploader img {
          width: 15ch;
          height: auto;
        }

        #generate-cookie-cutter {
          height: 100%;
          max-width: 9ch;
        }

        button {
          font-size: 48px;
        }

        #generation {
          flex-direction: row;
          align-items: center;
        }

        footer {
          font-size: 14px;
          display: flex;
          flex-direction: row;
          justify-content: space-between;
        }
      }

      @media (pointer: fine) {
        button {
          border: 5px solid transparent;
          box-shadow: 0px 0px 0px 0px #FF000033, 0px 0px 0px 0px #DB00004D;
          transition: border-color 0.11s ease-out, box-shadow 0.11s ease-out;
        }

        button:hover {
          border: 5px solid #FF0000;
          box-shadow: 0px 14px 14px 0px #FF000033, 0px 4px 7px 0px #DB00004D;
        }

        #try-again:hover {
          border-width: 1px;
        }
      }
    </style>


    <!-- uuidV4
      https://gist.github.com/scwood/3bff42cc005cc20ab7ec98f0d8e1d59d -->
    <script>function uuidV4() { const uuid = new Array(36); for (let i = 0; i < 36; i++) { uuid[i] = Math.floor(Math.random() * 16); } uuid[14] = 4; uuid[19] = uuid[19] &= ~(1 << 2); uuid[19] = uuid[19] |= (1 << 3); uuid[8] = uuid[13] = uuid[18] = uuid[23] = '-'; return uuid.map((x) => x.toString(16)).join(''); }</script>

    <!-- Complaint:
      I'm sorry, but BSON doesn't come standard in browsers. SOMEONE AT
      GOOGLE USE YOUR POWERS AND MAKE IT DEFACTO! GET THIS IN CHROMIUM PRONTO!
     -->
    <script>var BSON = (function (exports) { 'use strict';  function isAnyArrayBuffer(value) { return ['[object ArrayBuffer]', '[object SharedArrayBuffer]'].includes(Object.prototype.toString.call(value)); } function isUint8Array(value) { return Object.prototype.toString.call(value) === '[object Uint8Array]'; } function isRegExp(d) { return Object.prototype.toString.call(d) === '[object RegExp]'; } function isMap(d) { return Object.prototype.toString.call(d) === '[object Map]'; } function isDate(d) { return Object.prototype.toString.call(d) === '[object Date]'; } function defaultInspect(x, _options) { return JSON.stringify(x, (k, v) => { if (typeof v === 'bigint') { return { $numberLong: `${v}` }; } else if (isMap(v)) { return Object.fromEntries(v); } return v; }); } function getStylizeFunction(options) { const stylizeExists = options != null && typeof options === 'object' && 'stylize' in options && typeof options.stylize === 'function'; if (stylizeExists) { return options.stylize; } }  const BSON_MAJOR_VERSION = 6; const BSON_INT32_MAX = 0x7fffffff; const BSON_INT32_MIN = -0x80000000; const BSON_INT64_MAX = Math.pow(2, 63) - 1; const BSON_INT64_MIN = -Math.pow(2, 63); const JS_INT_MAX = Math.pow(2, 53); const JS_INT_MIN = -Math.pow(2, 53); const BSON_DATA_NUMBER = 1; const BSON_DATA_STRING = 2; const BSON_DATA_OBJECT = 3; const BSON_DATA_ARRAY = 4; const BSON_DATA_BINARY = 5; const BSON_DATA_UNDEFINED = 6; const BSON_DATA_OID = 7; const BSON_DATA_BOOLEAN = 8; const BSON_DATA_DATE = 9; const BSON_DATA_NULL = 10; const BSON_DATA_REGEXP = 11; const BSON_DATA_DBPOINTER = 12; const BSON_DATA_CODE = 13; const BSON_DATA_SYMBOL = 14; const BSON_DATA_CODE_W_SCOPE = 15; const BSON_DATA_INT = 16; const BSON_DATA_TIMESTAMP = 17; const BSON_DATA_LONG = 18; const BSON_DATA_DECIMAL128 = 19; const BSON_DATA_MIN_KEY = 0xff; const BSON_DATA_MAX_KEY = 0x7f; const BSON_BINARY_SUBTYPE_DEFAULT = 0; const BSON_BINARY_SUBTYPE_UUID_NEW = 4; const BSONType = Object.freeze({ double: 1, string: 2, object: 3, array: 4, binData: 5, undefined: 6, objectId: 7, bool: 8, date: 9, null: 10, regex: 11, dbPointer: 12, javascript: 13, symbol: 14, javascriptWithScope: 15, int: 16, timestamp: 17, long: 18, decimal: 19, minKey: -1, maxKey: 127 });  class BSONError extends Error { get bsonError() { return true; } get name() { return 'BSONError'; } constructor(message, options) { super(message, options); } static isBSONError(value) { return (value != null && typeof value === 'object' && 'bsonError' in value && value.bsonError === true && 'name' in value && 'message' in value && 'stack' in value); } } class BSONVersionError extends BSONError { get name() { return 'BSONVersionError'; } constructor() { super(`Unsupported BSON version, bson types must be from bson ${BSON_MAJOR_VERSION}.x.x`); } } class BSONRuntimeError extends BSONError { get name() { return 'BSONRuntimeError'; } constructor(message) { super(message); } }  const FIRST_BIT = 0x80; const FIRST_TWO_BITS = 0xc0; const FIRST_THREE_BITS = 0xe0; const FIRST_FOUR_BITS = 0xf0; const FIRST_FIVE_BITS = 0xf8; const TWO_BIT_CHAR = 0xc0; const THREE_BIT_CHAR = 0xe0; const FOUR_BIT_CHAR = 0xf0; const CONTINUING_CHAR = 0x80; function validateUtf8(bytes, start, end) { let continuation = 0; for (let i = start; i < end; i += 1) { const byte = bytes[i]; if (continuation) { if ((byte & FIRST_TWO_BITS) !== CONTINUING_CHAR) { return false; } continuation -= 1; } else if (byte & FIRST_BIT) { if ((byte & FIRST_THREE_BITS) === TWO_BIT_CHAR) { continuation = 1; } else if ((byte & FIRST_FOUR_BITS) === THREE_BIT_CHAR) { continuation = 2; } else if ((byte & FIRST_FIVE_BITS) === FOUR_BIT_CHAR) { continuation = 3; } else { return false; } } } return !continuation; }  function tryLatin(uint8array, start, end) { if (uint8array.length === 0) { return ''; } const stringByteLength = end - start; if (stringByteLength === 0) { return ''; } if (stringByteLength > 20) { return null; } if (stringByteLength === 1 && uint8array[start] < 128) { return String.fromCharCode(uint8array[start]); } if (stringByteLength === 2 && uint8array[start] < 128 && uint8array[start + 1] < 128) { return String.fromCharCode(uint8array[start]) + String.fromCharCode(uint8array[start + 1]); } if (stringByteLength === 3 && uint8array[start] < 128 && uint8array[start + 1] < 128 && uint8array[start + 2] < 128) { return (String.fromCharCode(uint8array[start]) + String.fromCharCode(uint8array[start + 1]) + String.fromCharCode(uint8array[start + 2])); } const latinBytes = []; for (let i = start; i < end; i++) { const byte = uint8array[i]; if (byte > 127) { return null; } latinBytes.push(byte); } return String.fromCharCode(...latinBytes); }  function nodejsMathRandomBytes(byteLength) { return nodeJsByteUtils.fromNumberArray(Array.from({ length: byteLength }, () => Math.floor(Math.random() * 256))); } const nodejsRandomBytes = (() => { try { return require('crypto').randomBytes; } catch { return nodejsMathRandomBytes; } })(); const nodeJsByteUtils = { toLocalBufferType(potentialBuffer) { if (Buffer.isBuffer(potentialBuffer)) { return potentialBuffer; } if (ArrayBuffer.isView(potentialBuffer)) { return Buffer.from(potentialBuffer.buffer, potentialBuffer.byteOffset, potentialBuffer.byteLength); } const stringTag = potentialBuffer?.[Symbol.toStringTag] ?? Object.prototype.toString.call(potentialBuffer); if (stringTag === 'ArrayBuffer' || stringTag === 'SharedArrayBuffer' || stringTag === '[object ArrayBuffer]' || stringTag === '[object SharedArrayBuffer]') { return Buffer.from(potentialBuffer); } throw new BSONError(`Cannot create Buffer from ${String(potentialBuffer)}`); }, allocate(size) { return Buffer.alloc(size); }, equals(a, b) { return nodeJsByteUtils.toLocalBufferType(a).equals(b); }, fromNumberArray(array) { return Buffer.from(array); }, fromBase64(base64) { return Buffer.from(base64, 'base64'); }, toBase64(buffer) { return nodeJsByteUtils.toLocalBufferType(buffer).toString('base64'); }, fromISO88591(codePoints) { return Buffer.from(codePoints, 'binary'); }, toISO88591(buffer) { return nodeJsByteUtils.toLocalBufferType(buffer).toString('binary'); }, fromHex(hex) { return Buffer.from(hex, 'hex'); }, toHex(buffer) { return nodeJsByteUtils.toLocalBufferType(buffer).toString('hex'); }, fromUTF8(text) { return Buffer.from(text, 'utf8'); }, toUTF8(buffer, start, end, fatal) { const basicLatin = end - start <= 20 ? tryLatin(buffer, start, end) : null; if (basicLatin != null) { return basicLatin; } const string = nodeJsByteUtils.toLocalBufferType(buffer).toString('utf8', start, end); if (fatal) { for (let i = 0; i < string.length; i++) { if (string.charCodeAt(i) === 0xfffd) { if (!validateUtf8(buffer, start, end)) { throw new BSONError('Invalid UTF-8 string in BSON document'); } break; } } } return string; }, utf8ByteLength(input) { return Buffer.byteLength(input, 'utf8'); }, encodeUTF8Into(buffer, source, byteOffset) { return nodeJsByteUtils.toLocalBufferType(buffer).write(source, byteOffset, undefined, 'utf8'); }, randomBytes: nodejsRandomBytes };  function isReactNative() { const { navigator } = globalThis; return typeof navigator === 'object' && navigator.product === 'ReactNative'; } function webMathRandomBytes(byteLength) { if (byteLength < 0) { throw new RangeError(`The argument 'byteLength' is invalid. Received ${byteLength}`); } return webByteUtils.fromNumberArray(Array.from({ length: byteLength }, () => Math.floor(Math.random() * 256))); } const webRandomBytes = (() => { const { crypto } = globalThis; if (crypto != null && typeof crypto.getRandomValues === 'function') { return (byteLength) => { return crypto.getRandomValues(webByteUtils.allocate(byteLength)); }; } else { if (isReactNative()) { const { console } = globalThis; console?.warn?.('BSON: For React Native please polyfill crypto.getRandomValues, e.g. using: https://www.npmjs.com/package/react-native-get-random-values.'); } return webMathRandomBytes; } })(); const HEX_DIGIT = /(\d|[a-f])/i; const webByteUtils = { toLocalBufferType(potentialUint8array) { const stringTag = potentialUint8array?.[Symbol.toStringTag] ?? Object.prototype.toString.call(potentialUint8array); if (stringTag === 'Uint8Array') { return potentialUint8array; } if (ArrayBuffer.isView(potentialUint8array)) { return new Uint8Array(potentialUint8array.buffer.slice(potentialUint8array.byteOffset, potentialUint8array.byteOffset + potentialUint8array.byteLength)); } if (stringTag === 'ArrayBuffer' || stringTag === 'SharedArrayBuffer' || stringTag === '[object ArrayBuffer]' || stringTag === '[object SharedArrayBuffer]') { return new Uint8Array(potentialUint8array); } throw new BSONError(`Cannot make a Uint8Array from ${String(potentialUint8array)}`); }, allocate(size) { if (typeof size !== 'number') { throw new TypeError(`The "size" argument must be of type number. Received ${String(size)}`); } return new Uint8Array(size); }, equals(a, b) { if (a.byteLength !== b.byteLength) { return false; } for (let i = 0; i < a.byteLength; i++) { if (a[i] !== b[i]) { return false; } } return true; }, fromNumberArray(array) { return Uint8Array.from(array); }, fromBase64(base64) { return Uint8Array.from(atob(base64), c => c.charCodeAt(0)); }, toBase64(uint8array) { return btoa(webByteUtils.toISO88591(uint8array)); }, fromISO88591(codePoints) { return Uint8Array.from(codePoints, c => c.charCodeAt(0) & 0xff); }, toISO88591(uint8array) { return Array.from(Uint16Array.from(uint8array), b => String.fromCharCode(b)).join(''); }, fromHex(hex) { const evenLengthHex = hex.length % 2 === 0 ? hex : hex.slice(0, hex.length - 1); const buffer = []; for (let i = 0; i < evenLengthHex.length; i += 2) { const firstDigit = evenLengthHex[i]; const secondDigit = evenLengthHex[i + 1]; if (!HEX_DIGIT.test(firstDigit)) { break; } if (!HEX_DIGIT.test(secondDigit)) { break; } const hexDigit = Number.parseInt(`${firstDigit}${secondDigit}`, 16); buffer.push(hexDigit); } return Uint8Array.from(buffer); }, toHex(uint8array) { return Array.from(uint8array, byte => byte.toString(16).padStart(2, '0')).join(''); }, fromUTF8(text) { return new TextEncoder().encode(text); }, toUTF8(uint8array, start, end, fatal) { const basicLatin = end - start <= 20 ? tryLatin(uint8array, start, end) : null; if (basicLatin != null) { return basicLatin; } if (fatal) { try { return new TextDecoder('utf8', { fatal }).decode(uint8array.slice(start, end)); } catch (cause) { throw new BSONError('Invalid UTF-8 string in BSON document', { cause }); } } return new TextDecoder('utf8', { fatal }).decode(uint8array.slice(start, end)); }, utf8ByteLength(input) { return webByteUtils.fromUTF8(input).byteLength; }, encodeUTF8Into(buffer, source, byteOffset) { const bytes = webByteUtils.fromUTF8(source); buffer.set(bytes, byteOffset); return bytes.byteLength; }, randomBytes: webRandomBytes };  const hasGlobalBuffer = typeof Buffer === 'function' && Buffer.prototype?._isBuffer !== true; const ByteUtils = hasGlobalBuffer ? nodeJsByteUtils : webByteUtils; class BSONDataView extends DataView { static fromUint8Array(input) { return new DataView(input.buffer, input.byteOffset, input.byteLength); } }  class BSONValue { get [Symbol.for('@@mdb.bson.version')]() { return BSON_MAJOR_VERSION; } [Symbol.for('nodejs.util.inspect.custom')](depth, options, inspect) { return this.inspect(depth, options, inspect); } }  class Binary extends BSONValue { get _bsontype() { return 'Binary'; } constructor(buffer, subType) { super(); if (!(buffer == null) && typeof buffer === 'string' && !ArrayBuffer.isView(buffer) && !isAnyArrayBuffer(buffer) && !Array.isArray(buffer)) { throw new BSONError('Binary can only be constructed from Uint8Array or number[]'); } this.sub_type = subType ?? Binary.BSON_BINARY_SUBTYPE_DEFAULT; if (buffer == null) { this.buffer = ByteUtils.allocate(Binary.BUFFER_SIZE); this.position = 0; } else { this.buffer = Array.isArray(buffer) ? ByteUtils.fromNumberArray(buffer) : ByteUtils.toLocalBufferType(buffer); this.position = this.buffer.byteLength; } } put(byteValue) { if (typeof byteValue === 'string' && byteValue.length !== 1) { throw new BSONError('only accepts single character String'); } else if (typeof byteValue !== 'number' && byteValue.length !== 1) throw new BSONError('only accepts single character Uint8Array or Array'); let decodedByte; if (typeof byteValue === 'string') { decodedByte = byteValue.charCodeAt(0); } else if (typeof byteValue === 'number') { decodedByte = byteValue; } else { decodedByte = byteValue[0]; } if (decodedByte < 0 || decodedByte > 255) { throw new BSONError('only accepts number in a valid unsigned byte range 0-255'); } if (this.buffer.byteLength > this.position) { this.buffer[this.position++] = decodedByte; } else { const newSpace = ByteUtils.allocate(Binary.BUFFER_SIZE + this.buffer.length); newSpace.set(this.buffer, 0); this.buffer = newSpace; this.buffer[this.position++] = decodedByte; } } write(sequence, offset) { offset = typeof offset === 'number' ? offset : this.position; if (this.buffer.byteLength < offset + sequence.length) { const newSpace = ByteUtils.allocate(this.buffer.byteLength + sequence.length); newSpace.set(this.buffer, 0); this.buffer = newSpace; } if (ArrayBuffer.isView(sequence)) { this.buffer.set(ByteUtils.toLocalBufferType(sequence), offset); this.position = offset + sequence.byteLength > this.position ? offset + sequence.length : this.position; } else if (typeof sequence === 'string') { throw new BSONError('input cannot be string'); } } read(position, length) { length = length && length > 0 ? length : this.position; return this.buffer.slice(position, position + length); } value() { return this.buffer.length === this.position ? this.buffer : this.buffer.subarray(0, this.position); } length() { return this.position; } toJSON() { return ByteUtils.toBase64(this.buffer); } toString(encoding) { if (encoding === 'hex') return ByteUtils.toHex(this.buffer); if (encoding === 'base64') return ByteUtils.toBase64(this.buffer); if (encoding === 'utf8' || encoding === 'utf-8') return ByteUtils.toUTF8(this.buffer, 0, this.buffer.byteLength, false); return ByteUtils.toUTF8(this.buffer, 0, this.buffer.byteLength, false); } toExtendedJSON(options) { options = options || {}; const base64String = ByteUtils.toBase64(this.buffer); const subType = Number(this.sub_type).toString(16); if (options.legacy) { return { $binary: base64String, $type: subType.length === 1 ? '0' + subType : subType }; } return { $binary: { base64: base64String, subType: subType.length === 1 ? '0' + subType : subType } }; } toUUID() { if (this.sub_type === Binary.SUBTYPE_UUID) { return new UUID(this.buffer.slice(0, this.position)); } throw new BSONError(`Binary sub_type "${this.sub_type}" is not supported for converting to UUID. Only "${Binary.SUBTYPE_UUID}" is currently supported.`); } static createFromHexString(hex, subType) { return new Binary(ByteUtils.fromHex(hex), subType); } static createFromBase64(base64, subType) { return new Binary(ByteUtils.fromBase64(base64), subType); } static fromExtendedJSON(doc, options) { options = options || {}; let data; let type; if ('$binary' in doc) { if (options.legacy && typeof doc.$binary === 'string' && '$type' in doc) { type = doc.$type ? parseInt(doc.$type, 16) : 0; data = ByteUtils.fromBase64(doc.$binary); } else { if (typeof doc.$binary !== 'string') { type = doc.$binary.subType ? parseInt(doc.$binary.subType, 16) : 0; data = ByteUtils.fromBase64(doc.$binary.base64); } } } else if ('$uuid' in doc) { type = 4; data = UUID.bytesFromString(doc.$uuid); } if (!data) { throw new BSONError(`Unexpected Binary Extended JSON format ${JSON.stringify(doc)}`); } return type === BSON_BINARY_SUBTYPE_UUID_NEW ? new UUID(data) : new Binary(data, type); } inspect(depth, options, inspect) { inspect ??= defaultInspect; const base64 = ByteUtils.toBase64(this.buffer.subarray(0, this.position)); const base64Arg = inspect(base64, options); const subTypeArg = inspect(this.sub_type, options); return `Binary.createFromBase64(${base64Arg}, ${subTypeArg})`; } } Binary.BSON_BINARY_SUBTYPE_DEFAULT = 0; Binary.BUFFER_SIZE = 256; Binary.SUBTYPE_DEFAULT = 0; Binary.SUBTYPE_FUNCTION = 1; Binary.SUBTYPE_BYTE_ARRAY = 2; Binary.SUBTYPE_UUID_OLD = 3; Binary.SUBTYPE_UUID = 4; Binary.SUBTYPE_MD5 = 5; Binary.SUBTYPE_ENCRYPTED = 6; Binary.SUBTYPE_COLUMN = 7; Binary.SUBTYPE_USER_DEFINED = 128; const UUID_BYTE_LENGTH = 16; const UUID_WITHOUT_DASHES = /^[0-9A-F]{32}$/i; const UUID_WITH_DASHES = /^[0-9A-F]{8}-[0-9A-F]{4}-[0-9A-F]{4}-[0-9A-F]{4}-[0-9A-F]{12}$/i; class UUID extends Binary { constructor(input) { let bytes; if (input == null) { bytes = UUID.generate(); } else if (input instanceof UUID) { bytes = ByteUtils.toLocalBufferType(new Uint8Array(input.buffer)); } else if (ArrayBuffer.isView(input) && input.byteLength === UUID_BYTE_LENGTH) { bytes = ByteUtils.toLocalBufferType(input); } else if (typeof input === 'string') { bytes = UUID.bytesFromString(input); } else { throw new BSONError('Argument passed in UUID constructor must be a UUID, a 16 byte Buffer or a 32/36 character hex string (dashes excluded/included, format: xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx).'); } super(bytes, BSON_BINARY_SUBTYPE_UUID_NEW); } get id() { return this.buffer; } set id(value) { this.buffer = value; } toHexString(includeDashes = true) { if (includeDashes) { return [ ByteUtils.toHex(this.buffer.subarray(0, 4)), ByteUtils.toHex(this.buffer.subarray(4, 6)), ByteUtils.toHex(this.buffer.subarray(6, 8)), ByteUtils.toHex(this.buffer.subarray(8, 10)), ByteUtils.toHex(this.buffer.subarray(10, 16)) ].join('-'); } return ByteUtils.toHex(this.buffer); } toString(encoding) { if (encoding === 'hex') return ByteUtils.toHex(this.id); if (encoding === 'base64') return ByteUtils.toBase64(this.id); return this.toHexString(); } toJSON() { return this.toHexString(); } equals(otherId) { if (!otherId) { return false; } if (otherId instanceof UUID) { return ByteUtils.equals(otherId.id, this.id); } try { return ByteUtils.equals(new UUID(otherId).id, this.id); } catch { return false; } } toBinary() { return new Binary(this.id, Binary.SUBTYPE_UUID); } static generate() { const bytes = ByteUtils.randomBytes(UUID_BYTE_LENGTH); bytes[6] = (bytes[6] & 0x0f) | 0x40; bytes[8] = (bytes[8] & 0x3f) | 0x80; return bytes; } static isValid(input) { if (!input) { return false; } if (typeof input === 'string') { return UUID.isValidUUIDString(input); } if (isUint8Array(input)) { return input.byteLength === UUID_BYTE_LENGTH; } return (input._bsontype === 'Binary' && input.sub_type === this.SUBTYPE_UUID && input.buffer.byteLength === 16); } static createFromHexString(hexString) { const buffer = UUID.bytesFromString(hexString); return new UUID(buffer); } static createFromBase64(base64) { return new UUID(ByteUtils.fromBase64(base64)); } static bytesFromString(representation) { if (!UUID.isValidUUIDString(representation)) { throw new BSONError('UUID string representation must be 32 hex digits or canonical hyphenated representation'); } return ByteUtils.fromHex(representation.replace(/-/g, '')); } static isValidUUIDString(representation) { return UUID_WITHOUT_DASHES.test(representation) || UUID_WITH_DASHES.test(representation); } inspect(depth, options, inspect) { inspect ??= defaultInspect; return `new UUID(${inspect(this.toHexString(), options)})`; } }  class Code extends BSONValue { get _bsontype() { return 'Code'; } constructor(code, scope) { super(); this.code = code.toString(); this.scope = scope ?? null; } toJSON() { if (this.scope != null) { return { code: this.code, scope: this.scope }; } return { code: this.code }; } toExtendedJSON() { if (this.scope) { return { $code: this.code, $scope: this.scope }; } return { $code: this.code }; } static fromExtendedJSON(doc) { return new Code(doc.$code, doc.$scope); } inspect(depth, options, inspect) { inspect ??= defaultInspect; let parametersString = inspect(this.code, options); const multiLineFn = parametersString.includes('\n'); if (this.scope != null) { parametersString += `,${multiLineFn ? '\n' : ' '}${inspect(this.scope, options)}`; } const endingNewline = multiLineFn && this.scope === null; return `new Code(${multiLineFn ? '\n' : ''}${parametersString}${endingNewline ? '\n' : ''})`; } }  function isDBRefLike(value) { return (value != null && typeof value === 'object' && '$id' in value && value.$id != null && '$ref' in value && typeof value.$ref === 'string' && (!('$db' in value) || ('$db' in value && typeof value.$db === 'string'))); } class DBRef extends BSONValue { get _bsontype() { return 'DBRef'; } constructor(collection, oid, db, fields) { super(); const parts = collection.split('.'); if (parts.length === 2) { db = parts.shift(); collection = parts.shift(); } this.collection = collection; this.oid = oid; this.db = db; this.fields = fields || {}; } get namespace() { return this.collection; } set namespace(value) { this.collection = value; } toJSON() { const o = Object.assign({ $ref: this.collection, $id: this.oid }, this.fields); if (this.db != null) o.$db = this.db; return o; } toExtendedJSON(options) { options = options || {}; let o = { $ref: this.collection, $id: this.oid }; if (options.legacy) { return o; } if (this.db) o.$db = this.db; o = Object.assign(o, this.fields); return o; } static fromExtendedJSON(doc) { const copy = Object.assign({}, doc); delete copy.$ref; delete copy.$id; delete copy.$db; return new DBRef(doc.$ref, doc.$id, doc.$db, copy); } inspect(depth, options, inspect) { inspect ??= defaultInspect; const args = [ inspect(this.namespace, options), inspect(this.oid, options), ...(this.db ? [inspect(this.db, options)] : []), ...(Object.keys(this.fields).length > 0 ? [inspect(this.fields, options)] : []) ]; args[1] = inspect === defaultInspect ? `new ObjectId(${args[1]})` : args[1]; return `new DBRef(${args.join(', ')})`; } }  let wasm = undefined; try { wasm = new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 1, 13, 2, 96, 0, 1, 127, 96, 4, 127, 127, 127, 127, 1, 127, 3, 7, 6, 0, 1, 1, 1, 1, 1, 6, 6, 1, 127, 1, 65, 0, 11, 7, 50, 6, 3, 109, 117, 108, 0, 1, 5, 100, 105, 118, 95, 115, 0, 2, 5, 100, 105, 118, 95, 117, 0, 3, 5, 114, 101, 109, 95, 115, 0, 4, 5, 114, 101, 109, 95, 117, 0, 5, 8, 103, 101, 116, 95, 104, 105, 103, 104, 0, 0, 10, 191, 1, 6, 4, 0, 35, 0, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 126, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 127, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 128, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 129, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 130, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11])), {}).exports; } catch { } const TWO_PWR_16_DBL = 1 << 16; const TWO_PWR_24_DBL = 1 << 24; const TWO_PWR_32_DBL = TWO_PWR_16_DBL * TWO_PWR_16_DBL; const TWO_PWR_64_DBL = TWO_PWR_32_DBL * TWO_PWR_32_DBL; const TWO_PWR_63_DBL = TWO_PWR_64_DBL / 2; const INT_CACHE = {}; const UINT_CACHE = {}; const MAX_INT64_STRING_LENGTH = 20; const DECIMAL_REG_EX = /^(\+?0|(\+|-)?[1-9][0-9]*)$/; class Long extends BSONValue { get _bsontype() { return 'Long'; } get __isLong__() { return true; } constructor(low = 0, high, unsigned) { super(); if (typeof low === 'bigint') { Object.assign(this, Long.fromBigInt(low, !!high)); } else if (typeof low === 'string') { Object.assign(this, Long.fromString(low, !!high)); } else { this.low = low | 0; this.high = high | 0; this.unsigned = !!unsigned; } } static fromBits(lowBits, highBits, unsigned) { return new Long(lowBits, highBits, unsigned); } static fromInt(value, unsigned) { let obj, cachedObj, cache; if (unsigned) { value >>>= 0; if ((cache = 0 <= value && value < 256)) { cachedObj = UINT_CACHE[value]; if (cachedObj) return cachedObj; } obj = Long.fromBits(value, (value | 0) < 0 ? -1 : 0, true); if (cache) UINT_CACHE[value] = obj; return obj; } else { value |= 0; if ((cache = -128 <= value && value < 128)) { cachedObj = INT_CACHE[value]; if (cachedObj) return cachedObj; } obj = Long.fromBits(value, value < 0 ? -1 : 0, false); if (cache) INT_CACHE[value] = obj; return obj; } } static fromNumber(value, unsigned) { if (isNaN(value)) return unsigned ? Long.UZERO : Long.ZERO; if (unsigned) { if (value < 0) return Long.UZERO; if (value >= TWO_PWR_64_DBL) return Long.MAX_UNSIGNED_VALUE; } else { if (value <= -TWO_PWR_63_DBL) return Long.MIN_VALUE; if (value + 1 >= TWO_PWR_63_DBL) return Long.MAX_VALUE; } if (value < 0) return Long.fromNumber(-value, unsigned).neg(); return Long.fromBits(value % TWO_PWR_32_DBL | 0, (value / TWO_PWR_32_DBL) | 0, unsigned); } static fromBigInt(value, unsigned) { return Long.fromString(value.toString(), unsigned); } static fromString(str, unsigned, radix) { if (str.length === 0) throw new BSONError('empty string'); if (str === 'NaN' || str === 'Infinity' || str === '+Infinity' || str === '-Infinity') return Long.ZERO; if (typeof unsigned === 'number') { (radix = unsigned), (unsigned = false); } else { unsigned = !!unsigned; } radix = radix || 10; if (radix < 2 || 36 < radix) throw new BSONError('radix'); let p; if ((p = str.indexOf('-')) > 0) throw new BSONError('interior hyphen'); else if (p === 0) { return Long.fromString(str.substring(1), unsigned, radix).neg(); } const radixToPower = Long.fromNumber(Math.pow(radix, 8)); let result = Long.ZERO; for (let i = 0; i < str.length; i += 8) { const size = Math.min(8, str.length - i), value = parseInt(str.substring(i, i + size), radix); if (size < 8) { const power = Long.fromNumber(Math.pow(radix, size)); result = result.mul(power).add(Long.fromNumber(value)); } else { result = result.mul(radixToPower); result = result.add(Long.fromNumber(value)); } } result.unsigned = unsigned; return result; } static fromBytes(bytes, unsigned, le) { return le ? Long.fromBytesLE(bytes, unsigned) : Long.fromBytesBE(bytes, unsigned); } static fromBytesLE(bytes, unsigned) { return new Long(bytes[0] | (bytes[1] << 8) | (bytes[2] << 16) | (bytes[3] << 24), bytes[4] | (bytes[5] << 8) | (bytes[6] << 16) | (bytes[7] << 24), unsigned); } static fromBytesBE(bytes, unsigned) { return new Long((bytes[4] << 24) | (bytes[5] << 16) | (bytes[6] << 8) | bytes[7], (bytes[0] << 24) | (bytes[1] << 16) | (bytes[2] << 8) | bytes[3], unsigned); } static isLong(value) { return (value != null && typeof value === 'object' && '__isLong__' in value && value.__isLong__ === true); } static fromValue(val, unsigned) { if (typeof val === 'number') return Long.fromNumber(val, unsigned); if (typeof val === 'string') return Long.fromString(val, unsigned); return Long.fromBits(val.low, val.high, typeof unsigned === 'boolean' ? unsigned : val.unsigned); } add(addend) { if (!Long.isLong(addend)) addend = Long.fromValue(addend); const a48 = this.high >>> 16; const a32 = this.high & 0xffff; const a16 = this.low >>> 16; const a00 = this.low & 0xffff; const b48 = addend.high >>> 16; const b32 = addend.high & 0xffff; const b16 = addend.low >>> 16; const b00 = addend.low & 0xffff; let c48 = 0, c32 = 0, c16 = 0, c00 = 0; c00 += a00 + b00; c16 += c00 >>> 16; c00 &= 0xffff; c16 += a16 + b16; c32 += c16 >>> 16; c16 &= 0xffff; c32 += a32 + b32; c48 += c32 >>> 16; c32 &= 0xffff; c48 += a48 + b48; c48 &= 0xffff; return Long.fromBits((c16 << 16) | c00, (c48 << 16) | c32, this.unsigned); } and(other) { if (!Long.isLong(other)) other = Long.fromValue(other); return Long.fromBits(this.low & other.low, this.high & other.high, this.unsigned); } compare(other) { if (!Long.isLong(other)) other = Long.fromValue(other); if (this.eq(other)) return 0; const thisNeg = this.isNegative(), otherNeg = other.isNegative(); if (thisNeg && !otherNeg) return -1; if (!thisNeg && otherNeg) return 1; if (!this.unsigned) return this.sub(other).isNegative() ? -1 : 1; return other.high >>> 0 > this.high >>> 0 || (other.high === this.high && other.low >>> 0 > this.low >>> 0) ? -1 : 1; } comp(other) { return this.compare(other); } divide(divisor) { if (!Long.isLong(divisor)) divisor = Long.fromValue(divisor); if (divisor.isZero()) throw new BSONError('division by zero'); if (wasm) { if (!this.unsigned && this.high === -0x80000000 && divisor.low === -1 && divisor.high === -1) { return this; } const low = (this.unsigned ? wasm.div_u : wasm.div_s)(this.low, this.high, divisor.low, divisor.high); return Long.fromBits(low, wasm.get_high(), this.unsigned); } if (this.isZero()) return this.unsigned ? Long.UZERO : Long.ZERO; let approx, rem, res; if (!this.unsigned) { if (this.eq(Long.MIN_VALUE)) { if (divisor.eq(Long.ONE) || divisor.eq(Long.NEG_ONE)) return Long.MIN_VALUE; else if (divisor.eq(Long.MIN_VALUE)) return Long.ONE; else { const halfThis = this.shr(1); approx = halfThis.div(divisor).shl(1); if (approx.eq(Long.ZERO)) { return divisor.isNegative() ? Long.ONE : Long.NEG_ONE; } else { rem = this.sub(divisor.mul(approx)); res = approx.add(rem.div(divisor)); return res; } } } else if (divisor.eq(Long.MIN_VALUE)) return this.unsigned ? Long.UZERO : Long.ZERO; if (this.isNegative()) { if (divisor.isNegative()) return this.neg().div(divisor.neg()); return this.neg().div(divisor).neg(); } else if (divisor.isNegative()) return this.div(divisor.neg()).neg(); res = Long.ZERO; } else { if (!divisor.unsigned) divisor = divisor.toUnsigned(); if (divisor.gt(this)) return Long.UZERO; if (divisor.gt(this.shru(1))) return Long.UONE; res = Long.UZERO; } rem = this; while (rem.gte(divisor)) { approx = Math.max(1, Math.floor(rem.toNumber() / divisor.toNumber())); const log2 = Math.ceil(Math.log(approx) / Math.LN2); const delta = log2 <= 48 ? 1 : Math.pow(2, log2 - 48); let approxRes = Long.fromNumber(approx); let approxRem = approxRes.mul(divisor); while (approxRem.isNegative() || approxRem.gt(rem)) { approx -= delta; approxRes = Long.fromNumber(approx, this.unsigned); approxRem = approxRes.mul(divisor); } if (approxRes.isZero()) approxRes = Long.ONE; res = res.add(approxRes); rem = rem.sub(approxRem); } return res; } div(divisor) { return this.divide(divisor); } equals(other) { if (!Long.isLong(other)) other = Long.fromValue(other); if (this.unsigned !== other.unsigned && this.high >>> 31 === 1 && other.high >>> 31 === 1) return false; return this.high === other.high && this.low === other.low; } eq(other) { return this.equals(other); } getHighBits() { return this.high; } getHighBitsUnsigned() { return this.high >>> 0; } getLowBits() { return this.low; } getLowBitsUnsigned() { return this.low >>> 0; } getNumBitsAbs() { if (this.isNegative()) { return this.eq(Long.MIN_VALUE) ? 64 : this.neg().getNumBitsAbs(); } const val = this.high !== 0 ? this.high : this.low; let bit; for (bit = 31; bit > 0; bit--) if ((val & (1 << bit)) !== 0) break; return this.high !== 0 ? bit + 33 : bit + 1; } greaterThan(other) { return this.comp(other) > 0; } gt(other) { return this.greaterThan(other); } greaterThanOrEqual(other) { return this.comp(other) >= 0; } gte(other) { return this.greaterThanOrEqual(other); } ge(other) { return this.greaterThanOrEqual(other); } isEven() { return (this.low & 1) === 0; } isNegative() { return !this.unsigned && this.high < 0; } isOdd() { return (this.low & 1) === 1; } isPositive() { return this.unsigned || this.high >= 0; } isZero() { return this.high === 0 && this.low === 0; } lessThan(other) { return this.comp(other) < 0; } lt(other) { return this.lessThan(other); } lessThanOrEqual(other) { return this.comp(other) <= 0; } lte(other) { return this.lessThanOrEqual(other); } modulo(divisor) { if (!Long.isLong(divisor)) divisor = Long.fromValue(divisor); if (wasm) { const low = (this.unsigned ? wasm.rem_u : wasm.rem_s)(this.low, this.high, divisor.low, divisor.high); return Long.fromBits(low, wasm.get_high(), this.unsigned); } return this.sub(this.div(divisor).mul(divisor)); } mod(divisor) { return this.modulo(divisor); } rem(divisor) { return this.modulo(divisor); } multiply(multiplier) { if (this.isZero()) return Long.ZERO; if (!Long.isLong(multiplier)) multiplier = Long.fromValue(multiplier); if (wasm) { const low = wasm.mul(this.low, this.high, multiplier.low, multiplier.high); return Long.fromBits(low, wasm.get_high(), this.unsigned); } if (multiplier.isZero()) return Long.ZERO; if (this.eq(Long.MIN_VALUE)) return multiplier.isOdd() ? Long.MIN_VALUE : Long.ZERO; if (multiplier.eq(Long.MIN_VALUE)) return this.isOdd() ? Long.MIN_VALUE : Long.ZERO; if (this.isNegative()) { if (multiplier.isNegative()) return this.neg().mul(multiplier.neg()); else return this.neg().mul(multiplier).neg(); } else if (multiplier.isNegative()) return this.mul(multiplier.neg()).neg(); if (this.lt(Long.TWO_PWR_24) && multiplier.lt(Long.TWO_PWR_24)) return Long.fromNumber(this.toNumber() * multiplier.toNumber(), this.unsigned); const a48 = this.high >>> 16; const a32 = this.high & 0xffff; const a16 = this.low >>> 16; const a00 = this.low & 0xffff; const b48 = multiplier.high >>> 16; const b32 = multiplier.high & 0xffff; const b16 = multiplier.low >>> 16; const b00 = multiplier.low & 0xffff; let c48 = 0, c32 = 0, c16 = 0, c00 = 0; c00 += a00 * b00; c16 += c00 >>> 16; c00 &= 0xffff; c16 += a16 * b00; c32 += c16 >>> 16; c16 &= 0xffff; c16 += a00 * b16; c32 += c16 >>> 16; c16 &= 0xffff; c32 += a32 * b00; c48 += c32 >>> 16; c32 &= 0xffff; c32 += a16 * b16; c48 += c32 >>> 16; c32 &= 0xffff; c32 += a00 * b32; c48 += c32 >>> 16; c32 &= 0xffff; c48 += a48 * b00 + a32 * b16 + a16 * b32 + a00 * b48; c48 &= 0xffff; return Long.fromBits((c16 << 16) | c00, (c48 << 16) | c32, this.unsigned); } mul(multiplier) { return this.multiply(multiplier); } negate() { if (!this.unsigned && this.eq(Long.MIN_VALUE)) return Long.MIN_VALUE; return this.not().add(Long.ONE); } neg() { return this.negate(); } not() { return Long.fromBits(~this.low, ~this.high, this.unsigned); } notEquals(other) { return !this.equals(other); } neq(other) { return this.notEquals(other); } ne(other) { return this.notEquals(other); } or(other) { if (!Long.isLong(other)) other = Long.fromValue(other); return Long.fromBits(this.low | other.low, this.high | other.high, this.unsigned); } shiftLeft(numBits) { if (Long.isLong(numBits)) numBits = numBits.toInt(); if ((numBits &= 63) === 0) return this; else if (numBits < 32) return Long.fromBits(this.low << numBits, (this.high << numBits) | (this.low >>> (32 - numBits)), this.unsigned); else return Long.fromBits(0, this.low << (numBits - 32), this.unsigned); } shl(numBits) { return this.shiftLeft(numBits); } shiftRight(numBits) { if (Long.isLong(numBits)) numBits = numBits.toInt(); if ((numBits &= 63) === 0) return this; else if (numBits < 32) return Long.fromBits((this.low >>> numBits) | (this.high << (32 - numBits)), this.high >> numBits, this.unsigned); else return Long.fromBits(this.high >> (numBits - 32), this.high >= 0 ? 0 : -1, this.unsigned); } shr(numBits) { return this.shiftRight(numBits); } shiftRightUnsigned(numBits) { if (Long.isLong(numBits)) numBits = numBits.toInt(); numBits &= 63; if (numBits === 0) return this; else { const high = this.high; if (numBits < 32) { const low = this.low; return Long.fromBits((low >>> numBits) | (high << (32 - numBits)), high >>> numBits, this.unsigned); } else if (numBits === 32) return Long.fromBits(high, 0, this.unsigned); else return Long.fromBits(high >>> (numBits - 32), 0, this.unsigned); } } shr_u(numBits) { return this.shiftRightUnsigned(numBits); } shru(numBits) { return this.shiftRightUnsigned(numBits); } subtract(subtrahend) { if (!Long.isLong(subtrahend)) subtrahend = Long.fromValue(subtrahend); return this.add(subtrahend.neg()); } sub(subtrahend) { return this.subtract(subtrahend); } toInt() { return this.unsigned ? this.low >>> 0 : this.low; } toNumber() { if (this.unsigned) return (this.high >>> 0) * TWO_PWR_32_DBL + (this.low >>> 0); return this.high * TWO_PWR_32_DBL + (this.low >>> 0); } toBigInt() { return BigInt(this.toString()); } toBytes(le) { return le ? this.toBytesLE() : this.toBytesBE(); } toBytesLE() { const hi = this.high, lo = this.low; return [ lo & 0xff, (lo >>> 8) & 0xff, (lo >>> 16) & 0xff, lo >>> 24, hi & 0xff, (hi >>> 8) & 0xff, (hi >>> 16) & 0xff, hi >>> 24 ]; } toBytesBE() { const hi = this.high, lo = this.low; return [ hi >>> 24, (hi >>> 16) & 0xff, (hi >>> 8) & 0xff, hi & 0xff, lo >>> 24, (lo >>> 16) & 0xff, (lo >>> 8) & 0xff, lo & 0xff ]; } toSigned() { if (!this.unsigned) return this; return Long.fromBits(this.low, this.high, false); } toString(radix) { radix = radix || 10; if (radix < 2 || 36 < radix) throw new BSONError('radix'); if (this.isZero()) return '0'; if (this.isNegative()) { if (this.eq(Long.MIN_VALUE)) { const radixLong = Long.fromNumber(radix), div = this.div(radixLong), rem1 = div.mul(radixLong).sub(this); return div.toString(radix) + rem1.toInt().toString(radix); } else return '-' + this.neg().toString(radix); } const radixToPower = Long.fromNumber(Math.pow(radix, 6), this.unsigned); let rem = this; let result = ''; while (true) { const remDiv = rem.div(radixToPower); const intval = rem.sub(remDiv.mul(radixToPower)).toInt() >>> 0; let digits = intval.toString(radix); rem = remDiv; if (rem.isZero()) { return digits + result; } else { while (digits.length < 6) digits = '0' + digits; result = '' + digits + result; } } } toUnsigned() { if (this.unsigned) return this; return Long.fromBits(this.low, this.high, true); } xor(other) { if (!Long.isLong(other)) other = Long.fromValue(other); return Long.fromBits(this.low ^ other.low, this.high ^ other.high, this.unsigned); } eqz() { return this.isZero(); } le(other) { return this.lessThanOrEqual(other); } toExtendedJSON(options) { if (options && options.relaxed) return this.toNumber(); return { $numberLong: this.toString() }; } static fromExtendedJSON(doc, options) { const { useBigInt64 = false, relaxed = true } = { ...options }; if (doc.$numberLong.length > MAX_INT64_STRING_LENGTH) { throw new BSONError('$numberLong string is too long'); } if (!DECIMAL_REG_EX.test(doc.$numberLong)) { throw new BSONError(`$numberLong string "${doc.$numberLong}" is in an invalid format`); } if (useBigInt64) { const bigIntResult = BigInt(doc.$numberLong); return BigInt.asIntN(64, bigIntResult); } const longResult = Long.fromString(doc.$numberLong); if (relaxed) { return longResult.toNumber(); } return longResult; } inspect(depth, options, inspect) { inspect ??= defaultInspect; const longVal = inspect(this.toString(), options); const unsignedVal = this.unsigned ? `, ${inspect(this.unsigned, options)}` : ''; return `new Long(${longVal}${unsignedVal})`; } } Long.TWO_PWR_24 = Long.fromInt(TWO_PWR_24_DBL); Long.MAX_UNSIGNED_VALUE = Long.fromBits(0xffffffff | 0, 0xffffffff | 0, true); Long.ZERO = Long.fromInt(0); Long.UZERO = Long.fromInt(0, true); Long.ONE = Long.fromInt(1); Long.UONE = Long.fromInt(1, true); Long.NEG_ONE = Long.fromInt(-1); Long.MAX_VALUE = Long.fromBits(0xffffffff | 0, 0x7fffffff | 0, false); Long.MIN_VALUE = Long.fromBits(0, 0x80000000 | 0, false);  const PARSE_STRING_REGEXP = /^(\+|-)?(\d+|(\d*\.\d*))?(E|e)?([-+])?(\d+)?$/; const PARSE_INF_REGEXP = /^(\+|-)?(Infinity|inf)$/i; const PARSE_NAN_REGEXP = /^(\+|-)?NaN$/i; const EXPONENT_MAX = 6111; const EXPONENT_MIN = -6176; const EXPONENT_BIAS = 6176; const MAX_DIGITS = 34; const NAN_BUFFER = ByteUtils.fromNumberArray([ 0x7c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 ].reverse()); const INF_NEGATIVE_BUFFER = ByteUtils.fromNumberArray([ 0xf8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 ].reverse()); const INF_POSITIVE_BUFFER = ByteUtils.fromNumberArray([ 0x78, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 ].reverse()); const EXPONENT_REGEX = /^([-+])?(\d+)?$/; const COMBINATION_MASK = 0x1f; const EXPONENT_MASK = 0x3fff; const COMBINATION_INFINITY = 30; const COMBINATION_NAN = 31; function isDigit(value) { return !isNaN(parseInt(value, 10)); } function divideu128(value) { const DIVISOR = Long.fromNumber(1000 * 1000 * 1000); let _rem = Long.fromNumber(0); if (!value.parts[0] && !value.parts[1] && !value.parts[2] && !value.parts[3]) { return { quotient: value, rem: _rem }; } for (let i = 0; i <= 3; i++) { _rem = _rem.shiftLeft(32); _rem = _rem.add(new Long(value.parts[i], 0)); value.parts[i] = _rem.div(DIVISOR).low; _rem = _rem.modulo(DIVISOR); } return { quotient: value, rem: _rem }; } function multiply64x2(left, right) { if (!left && !right) { return { high: Long.fromNumber(0), low: Long.fromNumber(0) }; } const leftHigh = left.shiftRightUnsigned(32); const leftLow = new Long(left.getLowBits(), 0); const rightHigh = right.shiftRightUnsigned(32); const rightLow = new Long(right.getLowBits(), 0); let productHigh = leftHigh.multiply(rightHigh); let productMid = leftHigh.multiply(rightLow); const productMid2 = leftLow.multiply(rightHigh); let productLow = leftLow.multiply(rightLow); productHigh = productHigh.add(productMid.shiftRightUnsigned(32)); productMid = new Long(productMid.getLowBits(), 0) .add(productMid2) .add(productLow.shiftRightUnsigned(32)); productHigh = productHigh.add(productMid.shiftRightUnsigned(32)); productLow = productMid.shiftLeft(32).add(new Long(productLow.getLowBits(), 0)); return { high: productHigh, low: productLow }; } function lessThan(left, right) { const uhleft = left.high >>> 0; const uhright = right.high >>> 0; if (uhleft < uhright) { return true; } else if (uhleft === uhright) { const ulleft = left.low >>> 0; const ulright = right.low >>> 0; if (ulleft < ulright) return true; } return false; } function invalidErr(string, message) { throw new BSONError(`"${string}" is not a valid Decimal128 string - ${message}`); } class Decimal128 extends BSONValue { get _bsontype() { return 'Decimal128'; } constructor(bytes) { super(); if (typeof bytes === 'string') { this.bytes = Decimal128.fromString(bytes).bytes; } else if (isUint8Array(bytes)) { if (bytes.byteLength !== 16) { throw new BSONError('Decimal128 must take a Buffer of 16 bytes'); } this.bytes = bytes; } else { throw new BSONError('Decimal128 must take a Buffer or string'); } } static fromString(representation) { return Decimal128._fromString(representation, { allowRounding: false }); } static fromStringWithRounding(representation) { return Decimal128._fromString(representation, { allowRounding: true }); } static _fromString(representation, options) { let isNegative = false; let sawSign = false; let sawRadix = false; let foundNonZero = false; let significantDigits = 0; let nDigitsRead = 0; let nDigits = 0; let radixPosition = 0; let firstNonZero = 0; const digits = [0]; let nDigitsStored = 0; let digitsInsert = 0; let lastDigit = 0; let exponent = 0; let significandHigh = new Long(0, 0); let significandLow = new Long(0, 0); let biasedExponent = 0; let index = 0; if (representation.length >= 7000) { throw new BSONError('' + representation + ' not a valid Decimal128 string'); } const stringMatch = representation.match(PARSE_STRING_REGEXP); const infMatch = representation.match(PARSE_INF_REGEXP); const nanMatch = representation.match(PARSE_NAN_REGEXP); if ((!stringMatch && !infMatch && !nanMatch) || representation.length === 0) { throw new BSONError('' + representation + ' not a valid Decimal128 string'); } if (stringMatch) { const unsignedNumber = stringMatch[2]; const e = stringMatch[4]; const expSign = stringMatch[5]; const expNumber = stringMatch[6]; if (e && expNumber === undefined) invalidErr(representation, 'missing exponent power'); if (e && unsignedNumber === undefined) invalidErr(representation, 'missing exponent base'); if (e === undefined && (expSign || expNumber)) { invalidErr(representation, 'missing e before exponent'); } } if (representation[index] === '+' || representation[index] === '-') { sawSign = true; isNegative = representation[index++] === '-'; } if (!isDigit(representation[index]) && representation[index] !== '.') { if (representation[index] === 'i' || representation[index] === 'I') { return new Decimal128(isNegative ? INF_NEGATIVE_BUFFER : INF_POSITIVE_BUFFER); } else if (representation[index] === 'N') { return new Decimal128(NAN_BUFFER); } } while (isDigit(representation[index]) || representation[index] === '.') { if (representation[index] === '.') { if (sawRadix) invalidErr(representation, 'contains multiple periods'); sawRadix = true; index = index + 1; continue; } if (nDigitsStored < MAX_DIGITS) { if (representation[index] !== '0' || foundNonZero) { if (!foundNonZero) { firstNonZero = nDigitsRead; } foundNonZero = true; digits[digitsInsert++] = parseInt(representation[index], 10); nDigitsStored = nDigitsStored + 1; } } if (foundNonZero) nDigits = nDigits + 1; if (sawRadix) radixPosition = radixPosition + 1; nDigitsRead = nDigitsRead + 1; index = index + 1; } if (sawRadix && !nDigitsRead) throw new BSONError('' + representation + ' not a valid Decimal128 string'); if (representation[index] === 'e' || representation[index] === 'E') { const match = representation.substr(++index).match(EXPONENT_REGEX); if (!match || !match[2]) return new Decimal128(NAN_BUFFER); exponent = parseInt(match[0], 10); index = index + match[0].length; } if (representation[index]) return new Decimal128(NAN_BUFFER); if (!nDigitsStored) { digits[0] = 0; nDigits = 1; nDigitsStored = 1; significantDigits = 0; } else { lastDigit = nDigitsStored - 1; significantDigits = nDigits; if (significantDigits !== 1) { while (representation[firstNonZero + significantDigits - 1 + Number(sawSign) + Number(sawRadix)] === '0') { significantDigits = significantDigits - 1; } } } if (exponent <= radixPosition && radixPosition > exponent + (1 << 14)) { exponent = EXPONENT_MIN; } else { exponent = exponent - radixPosition; } while (exponent > EXPONENT_MAX) { lastDigit = lastDigit + 1; if (lastDigit >= MAX_DIGITS) { if (significantDigits === 0) { exponent = EXPONENT_MAX; break; } invalidErr(representation, 'overflow'); } exponent = exponent - 1; } if (options.allowRounding) { while (exponent < EXPONENT_MIN || nDigitsStored < nDigits) { if (lastDigit === 0 && significantDigits < nDigitsStored) { exponent = EXPONENT_MIN; significantDigits = 0; break; } if (nDigitsStored < nDigits) { nDigits = nDigits - 1; } else { lastDigit = lastDigit - 1; } if (exponent < EXPONENT_MAX) { exponent = exponent + 1; } else { const digitsString = digits.join(''); if (digitsString.match(/^0+$/)) { exponent = EXPONENT_MAX; break; } invalidErr(representation, 'overflow'); } } if (lastDigit + 1 < significantDigits) { let endOfString = nDigitsRead; if (sawRadix) { firstNonZero = firstNonZero + 1; endOfString = endOfString + 1; } if (sawSign) { firstNonZero = firstNonZero + 1; endOfString = endOfString + 1; } const roundDigit = parseInt(representation[firstNonZero + lastDigit + 1], 10); let roundBit = 0; if (roundDigit >= 5) { roundBit = 1; if (roundDigit === 5) { roundBit = digits[lastDigit] % 2 === 1 ? 1 : 0; for (let i = firstNonZero + lastDigit + 2; i < endOfString; i++) { if (parseInt(representation[i], 10)) { roundBit = 1; break; } } } } if (roundBit) { let dIdx = lastDigit; for (; dIdx >= 0; dIdx--) { if (++digits[dIdx] > 9) { digits[dIdx] = 0; if (dIdx === 0) { if (exponent < EXPONENT_MAX) { exponent = exponent + 1; digits[dIdx] = 1; } else { return new Decimal128(isNegative ? INF_NEGATIVE_BUFFER : INF_POSITIVE_BUFFER); } } } else { break; } } } } } else { while (exponent < EXPONENT_MIN || nDigitsStored < nDigits) { if (lastDigit === 0) { if (significantDigits === 0) { exponent = EXPONENT_MIN; break; } invalidErr(representation, 'exponent underflow'); } if (nDigitsStored < nDigits) { if (representation[nDigits - 1 + Number(sawSign) + Number(sawRadix)] !== '0' && significantDigits !== 0) { invalidErr(representation, 'inexact rounding'); } nDigits = nDigits - 1; } else { if (digits[lastDigit] !== 0) { invalidErr(representation, 'inexact rounding'); } lastDigit = lastDigit - 1; } if (exponent < EXPONENT_MAX) { exponent = exponent + 1; } else { invalidErr(representation, 'overflow'); } } if (lastDigit + 1 < significantDigits) { if (sawRadix) { firstNonZero = firstNonZero + 1; } if (sawSign) { firstNonZero = firstNonZero + 1; } const roundDigit = parseInt(representation[firstNonZero + lastDigit + 1], 10); if (roundDigit !== 0) { invalidErr(representation, 'inexact rounding'); } } } significandHigh = Long.fromNumber(0); significandLow = Long.fromNumber(0); if (significantDigits === 0) { significandHigh = Long.fromNumber(0); significandLow = Long.fromNumber(0); } else if (lastDigit < 17) { let dIdx = 0; significandLow = Long.fromNumber(digits[dIdx++]); significandHigh = new Long(0, 0); for (; dIdx <= lastDigit; dIdx++) { significandLow = significandLow.multiply(Long.fromNumber(10)); significandLow = significandLow.add(Long.fromNumber(digits[dIdx])); } } else { let dIdx = 0; significandHigh = Long.fromNumber(digits[dIdx++]); for (; dIdx <= lastDigit - 17; dIdx++) { significandHigh = significandHigh.multiply(Long.fromNumber(10)); significandHigh = significandHigh.add(Long.fromNumber(digits[dIdx])); } significandLow = Long.fromNumber(digits[dIdx++]); for (; dIdx <= lastDigit; dIdx++) { significandLow = significandLow.multiply(Long.fromNumber(10)); significandLow = significandLow.add(Long.fromNumber(digits[dIdx])); } } const significand = multiply64x2(significandHigh, Long.fromString('100000000000000000')); significand.low = significand.low.add(significandLow); if (lessThan(significand.low, significandLow)) { significand.high = significand.high.add(Long.fromNumber(1)); } biasedExponent = exponent + EXPONENT_BIAS; const dec = { low: Long.fromNumber(0), high: Long.fromNumber(0) }; if (significand.high.shiftRightUnsigned(49).and(Long.fromNumber(1)).equals(Long.fromNumber(1))) { dec.high = dec.high.or(Long.fromNumber(0x3).shiftLeft(61)); dec.high = dec.high.or(Long.fromNumber(biasedExponent).and(Long.fromNumber(0x3fff).shiftLeft(47))); dec.high = dec.high.or(significand.high.and(Long.fromNumber(0x7fffffffffff))); } else { dec.high = dec.high.or(Long.fromNumber(biasedExponent & 0x3fff).shiftLeft(49)); dec.high = dec.high.or(significand.high.and(Long.fromNumber(0x1ffffffffffff))); } dec.low = significand.low; if (isNegative) { dec.high = dec.high.or(Long.fromString('9223372036854775808')); } const buffer = ByteUtils.allocate(16); index = 0; buffer[index++] = dec.low.low & 0xff; buffer[index++] = (dec.low.low >> 8) & 0xff; buffer[index++] = (dec.low.low >> 16) & 0xff; buffer[index++] = (dec.low.low >> 24) & 0xff; buffer[index++] = dec.low.high & 0xff; buffer[index++] = (dec.low.high >> 8) & 0xff; buffer[index++] = (dec.low.high >> 16) & 0xff; buffer[index++] = (dec.low.high >> 24) & 0xff; buffer[index++] = dec.high.low & 0xff; buffer[index++] = (dec.high.low >> 8) & 0xff; buffer[index++] = (dec.high.low >> 16) & 0xff; buffer[index++] = (dec.high.low >> 24) & 0xff; buffer[index++] = dec.high.high & 0xff; buffer[index++] = (dec.high.high >> 8) & 0xff; buffer[index++] = (dec.high.high >> 16) & 0xff; buffer[index++] = (dec.high.high >> 24) & 0xff; return new Decimal128(buffer); } toString() { let biased_exponent; let significand_digits = 0; const significand = new Array(36); for (let i = 0; i < significand.length; i++) significand[i] = 0; let index = 0; let is_zero = false; let significand_msb; let significand128 = { parts: [0, 0, 0, 0] }; let j, k; const string = []; index = 0; const buffer = this.bytes; const low = buffer[index++] | (buffer[index++] << 8) | (buffer[index++] << 16) | (buffer[index++] << 24); const midl = buffer[index++] | (buffer[index++] << 8) | (buffer[index++] << 16) | (buffer[index++] << 24); const midh = buffer[index++] | (buffer[index++] << 8) | (buffer[index++] << 16) | (buffer[index++] << 24); const high = buffer[index++] | (buffer[index++] << 8) | (buffer[index++] << 16) | (buffer[index++] << 24); index = 0; const dec = { low: new Long(low, midl), high: new Long(midh, high) }; if (dec.high.lessThan(Long.ZERO)) { string.push('-'); } const combination = (high >> 26) & COMBINATION_MASK; if (combination >> 3 === 3) { if (combination === COMBINATION_INFINITY) { return string.join('') + 'Infinity'; } else if (combination === COMBINATION_NAN) { return 'NaN'; } else { biased_exponent = (high >> 15) & EXPONENT_MASK; significand_msb = 0x08 + ((high >> 14) & 0x01); } } else { significand_msb = (high >> 14) & 0x07; biased_exponent = (high >> 17) & EXPONENT_MASK; } const exponent = biased_exponent - EXPONENT_BIAS; significand128.parts[0] = (high & 0x3fff) + ((significand_msb & 0xf) << 14); significand128.parts[1] = midh; significand128.parts[2] = midl; significand128.parts[3] = low; if (significand128.parts[0] === 0 && significand128.parts[1] === 0 && significand128.parts[2] === 0 && significand128.parts[3] === 0) { is_zero = true; } else { for (k = 3; k >= 0; k--) { let least_digits = 0; const result = divideu128(significand128); significand128 = result.quotient; least_digits = result.rem.low; if (!least_digits) continue; for (j = 8; j >= 0; j--) { significand[k * 9 + j] = least_digits % 10; least_digits = Math.floor(least_digits / 10); } } } if (is_zero) { significand_digits = 1; significand[index] = 0; } else { significand_digits = 36; while (!significand[index]) { significand_digits = significand_digits - 1; index = index + 1; } } const scientific_exponent = significand_digits - 1 + exponent; if (scientific_exponent >= 34 || scientific_exponent <= -7 || exponent > 0) { if (significand_digits > 34) { string.push(`${0}`); if (exponent > 0) string.push(`E+${exponent}`); else if (exponent < 0) string.push(`E${exponent}`); return string.join(''); } string.push(`${significand[index++]}`); significand_digits = significand_digits - 1; if (significand_digits) { string.push('.'); } for (let i = 0; i < significand_digits; i++) { string.push(`${significand[index++]}`); } string.push('E'); if (scientific_exponent > 0) { string.push(`+${scientific_exponent}`); } else { string.push(`${scientific_exponent}`); } } else { if (exponent >= 0) { for (let i = 0; i < significand_digits; i++) { string.push(`${significand[index++]}`); } } else { let radix_position = significand_digits + exponent; if (radix_position > 0) { for (let i = 0; i < radix_position; i++) { string.push(`${significand[index++]}`); } } else { string.push('0'); } string.push('.'); while (radix_position++ < 0) { string.push('0'); } for (let i = 0; i < significand_digits - Math.max(radix_position - 1, 0); i++) { string.push(`${significand[index++]}`); } } } return string.join(''); } toJSON() { return { $numberDecimal: this.toString() }; } toExtendedJSON() { return { $numberDecimal: this.toString() }; } static fromExtendedJSON(doc) { return Decimal128.fromString(doc.$numberDecimal); } inspect(depth, options, inspect) { inspect ??= defaultInspect; const d128string = inspect(this.toString(), options); return `new Decimal128(${d128string})`; } }  class Double extends BSONValue { get _bsontype() { return 'Double'; } constructor(value) { super(); if (value instanceof Number) { value = value.valueOf(); } this.value = +value; } valueOf() { return this.value; } toJSON() { return this.value; } toString(radix) { return this.value.toString(radix); } toExtendedJSON(options) { if (options && (options.legacy || (options.relaxed && isFinite(this.value)))) { return this.value; } if (Object.is(Math.sign(this.value), -0)) { return { $numberDouble: '-0.0' }; } return { $numberDouble: Number.isInteger(this.value) ? this.value.toFixed(1) : this.value.toString() }; } static fromExtendedJSON(doc, options) { const doubleValue = parseFloat(doc.$numberDouble); return options && options.relaxed ? doubleValue : new Double(doubleValue); } inspect(depth, options, inspect) { inspect ??= defaultInspect; return `new Double(${inspect(this.value, options)})`; } }  class Int32 extends BSONValue { get _bsontype() { return 'Int32'; } constructor(value) { super(); if (value instanceof Number) { value = value.valueOf(); } this.value = +value | 0; } valueOf() { return this.value; } toString(radix) { return this.value.toString(radix); } toJSON() { return this.value; } toExtendedJSON(options) { if (options && (options.relaxed || options.legacy)) return this.value; return { $numberInt: this.value.toString() }; } static fromExtendedJSON(doc, options) { return options && options.relaxed ? parseInt(doc.$numberInt, 10) : new Int32(doc.$numberInt); } inspect(depth, options, inspect) { inspect ??= defaultInspect; return `new Int32(${inspect(this.value, options)})`; } }  class MaxKey extends BSONValue { get _bsontype() { return 'MaxKey'; } toExtendedJSON() { return { $maxKey: 1 }; } static fromExtendedJSON() { return new MaxKey(); } inspect() { return 'new MaxKey()'; } }  class MinKey extends BSONValue { get _bsontype() { return 'MinKey'; } toExtendedJSON() { return { $minKey: 1 }; } static fromExtendedJSON() { return new MinKey(); } inspect() { return 'new MinKey()'; } }  const checkForHexRegExp = new RegExp('^[0-9a-fA-F]{24}$'); let PROCESS_UNIQUE = null; const kId = Symbol('id'); class ObjectId extends BSONValue { get _bsontype() { return 'ObjectId'; } constructor(inputId) { super(); let workingId; if (typeof inputId === 'object' && inputId && 'id' in inputId) { if (typeof inputId.id !== 'string' && !ArrayBuffer.isView(inputId.id)) { throw new BSONError('Argument passed in must have an id that is of type string or Buffer'); } if ('toHexString' in inputId && typeof inputId.toHexString === 'function') { workingId = ByteUtils.fromHex(inputId.toHexString()); } else { workingId = inputId.id; } } else { workingId = inputId; } if (workingId == null || typeof workingId === 'number') { this[kId] = ObjectId.generate(typeof workingId === 'number' ? workingId : undefined); } else if (ArrayBuffer.isView(workingId) && workingId.byteLength === 12) { this[kId] = ByteUtils.toLocalBufferType(workingId); } else if (typeof workingId === 'string') { if (workingId.length === 24 && checkForHexRegExp.test(workingId)) { this[kId] = ByteUtils.fromHex(workingId); } else { throw new BSONError('input must be a 24 character hex string, 12 byte Uint8Array, or an integer'); } } else { throw new BSONError('Argument passed in does not match the accepted types'); } if (ObjectId.cacheHexString) { this.__id = ByteUtils.toHex(this.id); } } get id() { return this[kId]; } set id(value) { this[kId] = value; if (ObjectId.cacheHexString) { this.__id = ByteUtils.toHex(value); } } toHexString() { if (ObjectId.cacheHexString && this.__id) { return this.__id; } const hexString = ByteUtils.toHex(this.id); if (ObjectId.cacheHexString && !this.__id) { this.__id = hexString; } return hexString; } static getInc() { return (ObjectId.index = (ObjectId.index + 1) % 0xffffff); } static generate(time) { if ('number' !== typeof time) { time = Math.floor(Date.now() / 1000); } const inc = ObjectId.getInc(); const buffer = ByteUtils.allocate(12); BSONDataView.fromUint8Array(buffer).setUint32(0, time, false); if (PROCESS_UNIQUE === null) { PROCESS_UNIQUE = ByteUtils.randomBytes(5); } buffer[4] = PROCESS_UNIQUE[0]; buffer[5] = PROCESS_UNIQUE[1]; buffer[6] = PROCESS_UNIQUE[2]; buffer[7] = PROCESS_UNIQUE[3]; buffer[8] = PROCESS_UNIQUE[4]; buffer[11] = inc & 0xff; buffer[10] = (inc >> 8) & 0xff; buffer[9] = (inc >> 16) & 0xff; return buffer; } toString(encoding) { if (encoding === 'base64') return ByteUtils.toBase64(this.id); if (encoding === 'hex') return this.toHexString(); return this.toHexString(); } toJSON() { return this.toHexString(); } static is(variable) { return (variable != null && typeof variable === 'object' && '_bsontype' in variable && variable._bsontype === 'ObjectId'); } equals(otherId) { if (otherId === undefined || otherId === null) { return false; } if (ObjectId.is(otherId)) { return this[kId][11] === otherId[kId][11] && ByteUtils.equals(this[kId], otherId[kId]); } if (typeof otherId === 'string') { return otherId.toLowerCase() === this.toHexString(); } if (typeof otherId === 'object' && typeof otherId.toHexString === 'function') { const otherIdString = otherId.toHexString(); const thisIdString = this.toHexString(); return typeof otherIdString === 'string' && otherIdString.toLowerCase() === thisIdString; } return false; } getTimestamp() { const timestamp = new Date(); const time = BSONDataView.fromUint8Array(this.id).getUint32(0, false); timestamp.setTime(Math.floor(time) * 1000); return timestamp; } static createPk() { return new ObjectId(); } static createFromTime(time) { const buffer = ByteUtils.fromNumberArray([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]); BSONDataView.fromUint8Array(buffer).setUint32(0, time, false); return new ObjectId(buffer); } static createFromHexString(hexString) { if (hexString?.length !== 24) { throw new BSONError('hex string must be 24 characters'); } return new ObjectId(ByteUtils.fromHex(hexString)); } static createFromBase64(base64) { if (base64?.length !== 16) { throw new BSONError('base64 string must be 16 characters'); } return new ObjectId(ByteUtils.fromBase64(base64)); } static isValid(id) { if (id == null) return false; try { new ObjectId(id); return true; } catch { return false; } } toExtendedJSON() { if (this.toHexString) return { $oid: this.toHexString() }; return { $oid: this.toString('hex') }; } static fromExtendedJSON(doc) { return new ObjectId(doc.$oid); } inspect(depth, options, inspect) { inspect ??= defaultInspect; return `new ObjectId(${inspect(this.toHexString(), options)})`; } } ObjectId.index = Math.floor(Math.random() * 0xffffff);  function internalCalculateObjectSize(object, serializeFunctions, ignoreUndefined) { let totalLength = 4 + 1; if (Array.isArray(object)) { for (let i = 0; i < object.length; i++) { totalLength += calculateElement(i.toString(), object[i], serializeFunctions, true, ignoreUndefined); } } else { if (typeof object?.toBSON === 'function') { object = object.toBSON(); } for (const key of Object.keys(object)) { totalLength += calculateElement(key, object[key], serializeFunctions, false, ignoreUndefined); } } return totalLength; } function calculateElement(name, value, serializeFunctions = false, isArray = false, ignoreUndefined = false) { if (typeof value?.toBSON === 'function') { value = value.toBSON(); } switch (typeof value) { case 'string': return 1 + ByteUtils.utf8ByteLength(name) + 1 + 4 + ByteUtils.utf8ByteLength(value) + 1; case 'number': if (Math.floor(value) === value && value >= JS_INT_MIN && value <= JS_INT_MAX) { if (value >= BSON_INT32_MIN && value <= BSON_INT32_MAX) { return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + (4 + 1); } else { return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + (8 + 1); } } else { return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + (8 + 1); } case 'undefined': if (isArray || !ignoreUndefined) return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + 1; return 0; case 'boolean': return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + (1 + 1); case 'object': if (value != null && typeof value._bsontype === 'string' && value[Symbol.for('@@mdb.bson.version')] !== BSON_MAJOR_VERSION) { throw new BSONVersionError(); } else if (value == null || value._bsontype === 'MinKey' || value._bsontype === 'MaxKey') { return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + 1; } else if (value._bsontype === 'ObjectId') { return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + (12 + 1); } else if (value instanceof Date || isDate(value)) { return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + (8 + 1); } else if (ArrayBuffer.isView(value) || value instanceof ArrayBuffer || isAnyArrayBuffer(value)) { return ((name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + (1 + 4 + 1) + value.byteLength); } else if (value._bsontype === 'Long' || value._bsontype === 'Double' || value._bsontype === 'Timestamp') { return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + (8 + 1); } else if (value._bsontype === 'Decimal128') { return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + (16 + 1); } else if (value._bsontype === 'Code') { if (value.scope != null && Object.keys(value.scope).length > 0) { return ((name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + 1 + 4 + 4 + ByteUtils.utf8ByteLength(value.code.toString()) + 1 + internalCalculateObjectSize(value.scope, serializeFunctions, ignoreUndefined)); } else { return ((name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + 1 + 4 + ByteUtils.utf8ByteLength(value.code.toString()) + 1); } } else if (value._bsontype === 'Binary') { const binary = value; if (binary.sub_type === Binary.SUBTYPE_BYTE_ARRAY) { return ((name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + (binary.position + 1 + 4 + 1 + 4)); } else { return ((name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + (binary.position + 1 + 4 + 1)); } } else if (value._bsontype === 'Symbol') { return ((name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + ByteUtils.utf8ByteLength(value.value) + 4 + 1 + 1); } else if (value._bsontype === 'DBRef') { const ordered_values = Object.assign({ $ref: value.collection, $id: value.oid }, value.fields); if (value.db != null) { ordered_values['$db'] = value.db; } return ((name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + 1 + internalCalculateObjectSize(ordered_values, serializeFunctions, ignoreUndefined)); } else if (value instanceof RegExp || isRegExp(value)) { return ((name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + 1 + ByteUtils.utf8ByteLength(value.source) + 1 + (value.global ? 1 : 0) + (value.ignoreCase ? 1 : 0) + (value.multiline ? 1 : 0) + 1); } else if (value._bsontype === 'BSONRegExp') { return ((name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + 1 + ByteUtils.utf8ByteLength(value.pattern) + 1 + ByteUtils.utf8ByteLength(value.options) + 1); } else { return ((name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + internalCalculateObjectSize(value, serializeFunctions, ignoreUndefined) + 1); } case 'function': if (serializeFunctions) { return ((name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + 1 + 4 + ByteUtils.utf8ByteLength(value.toString()) + 1); } } return 0; }  function alphabetize(str) { return str.split('').sort().join(''); } class BSONRegExp extends BSONValue { get _bsontype() { return 'BSONRegExp'; } constructor(pattern, options) { super(); this.pattern = pattern; this.options = alphabetize(options ?? ''); if (this.pattern.indexOf('\x00') !== -1) { throw new BSONError(`BSON Regex patterns cannot contain null bytes, found: ${JSON.stringify(this.pattern)}`); } if (this.options.indexOf('\x00') !== -1) { throw new BSONError(`BSON Regex options cannot contain null bytes, found: ${JSON.stringify(this.options)}`); } for (let i = 0; i < this.options.length; i++) { if (!(this.options[i] === 'i' || this.options[i] === 'm' || this.options[i] === 'x' || this.options[i] === 'l' || this.options[i] === 's' || this.options[i] === 'u')) { throw new BSONError(`The regular expression option [${this.options[i]}] is not supported`); } } } static parseOptions(options) { return options ? options.split('').sort().join('') : ''; } toExtendedJSON(options) { options = options || {}; if (options.legacy) { return { $regex: this.pattern, $options: this.options }; } return { $regularExpression: { pattern: this.pattern, options: this.options } }; } static fromExtendedJSON(doc) { if ('$regex' in doc) { if (typeof doc.$regex !== 'string') { if (doc.$regex._bsontype === 'BSONRegExp') { return doc; } } else { return new BSONRegExp(doc.$regex, BSONRegExp.parseOptions(doc.$options)); } } if ('$regularExpression' in doc) { return new BSONRegExp(doc.$regularExpression.pattern, BSONRegExp.parseOptions(doc.$regularExpression.options)); } throw new BSONError(`Unexpected BSONRegExp EJSON object form: ${JSON.stringify(doc)}`); } inspect(depth, options, inspect) { const stylize = getStylizeFunction(options) ?? (v => v); inspect ??= defaultInspect; const pattern = stylize(inspect(this.pattern), 'regexp'); const flags = stylize(inspect(this.options), 'regexp'); return `new BSONRegExp(${pattern}, ${flags})`; } }  class BSONSymbol extends BSONValue { get _bsontype() { return 'BSONSymbol'; } constructor(value) { super(); this.value = value; } valueOf() { return this.value; } toString() { return this.value; } toJSON() { return this.value; } toExtendedJSON() { return { $symbol: this.value }; } static fromExtendedJSON(doc) { return new BSONSymbol(doc.$symbol); } inspect(depth, options, inspect) { inspect ??= defaultInspect; return `new BSONSymbol(${inspect(this.value, options)})`; } }  const LongWithoutOverridesClass = Long; class Timestamp extends LongWithoutOverridesClass { get _bsontype() { return 'Timestamp'; } constructor(low) { if (low == null) { super(0, 0, true); } else if (typeof low === 'bigint') { super(low, true); } else if (Long.isLong(low)) { super(low.low, low.high, true); } else if (typeof low === 'object' && 't' in low && 'i' in low) { if (typeof low.t !== 'number' && (typeof low.t !== 'object' || low.t._bsontype !== 'Int32')) { throw new BSONError('Timestamp constructed from { t, i } must provide t as a number'); } if (typeof low.i !== 'number' && (typeof low.i !== 'object' || low.i._bsontype !== 'Int32')) { throw new BSONError('Timestamp constructed from { t, i } must provide i as a number'); } const t = Number(low.t); const i = Number(low.i); if (t < 0 || Number.isNaN(t)) { throw new BSONError('Timestamp constructed from { t, i } must provide a positive t'); } if (i < 0 || Number.isNaN(i)) { throw new BSONError('Timestamp constructed from { t, i } must provide a positive i'); } if (t > 4294967295) { throw new BSONError('Timestamp constructed from { t, i } must provide t equal or less than uint32 max'); } if (i > 4294967295) { throw new BSONError('Timestamp constructed from { t, i } must provide i equal or less than uint32 max'); } super(i, t, true); } else { throw new BSONError('A Timestamp can only be constructed with: bigint, Long, or { t: number; i: number }'); } } toJSON() { return { $timestamp: this.toString() }; } static fromInt(value) { return new Timestamp(Long.fromInt(value, true)); } static fromNumber(value) { return new Timestamp(Long.fromNumber(value, true)); } static fromBits(lowBits, highBits) { return new Timestamp({ i: lowBits, t: highBits }); } static fromString(str, optRadix) { return new Timestamp(Long.fromString(str, true, optRadix)); } toExtendedJSON() { return { $timestamp: { t: this.high >>> 0, i: this.low >>> 0 } }; } static fromExtendedJSON(doc) { const i = Long.isLong(doc.$timestamp.i) ? doc.$timestamp.i.getLowBitsUnsigned() : doc.$timestamp.i; const t = Long.isLong(doc.$timestamp.t) ? doc.$timestamp.t.getLowBitsUnsigned() : doc.$timestamp.t; return new Timestamp({ t, i }); } inspect(depth, options, inspect) { inspect ??= defaultInspect; const t = inspect(this.high >>> 0, options); const i = inspect(this.low >>> 0, options); return `new Timestamp({ t: ${t}, i: ${i} })`; } } Timestamp.MAX_VALUE = Long.MAX_UNSIGNED_VALUE;  const JS_INT_MAX_LONG = Long.fromNumber(JS_INT_MAX); const JS_INT_MIN_LONG = Long.fromNumber(JS_INT_MIN); function internalDeserialize(buffer, options, isArray) { options = options == null ? {} : options; const index = options && options.index ? options.index : 0; const size = buffer[index] | (buffer[index + 1] << 8) | (buffer[index + 2] << 16) | (buffer[index + 3] << 24); if (size < 5) { throw new BSONError(`bson size must be >= 5, is ${size}`); } if (options.allowObjectSmallerThanBufferSize && buffer.length < size) { throw new BSONError(`buffer length ${buffer.length} must be >= bson size ${size}`); } if (!options.allowObjectSmallerThanBufferSize && buffer.length !== size) { throw new BSONError(`buffer length ${buffer.length} must === bson size ${size}`); } if (size + index > buffer.byteLength) { throw new BSONError(`(bson size ${size} + options.index ${index} must be <= buffer length ${buffer.byteLength})`); } if (buffer[index + size - 1] !== 0) { throw new BSONError("One object, sized correctly, with a spot for an EOO, but the EOO isn't 0x00"); } return deserializeObject(buffer, index, options, isArray); } const allowedDBRefKeys = /^\$ref$|^\$id$|^\$db$/; function deserializeObject(buffer, index, options, isArray = false) { const fieldsAsRaw = options['fieldsAsRaw'] == null ? null : options['fieldsAsRaw']; const raw = options['raw'] == null ? false : options['raw']; const bsonRegExp = typeof options['bsonRegExp'] === 'boolean' ? options['bsonRegExp'] : false; const promoteBuffers = options.promoteBuffers ?? false; const promoteLongs = options.promoteLongs ?? true; const promoteValues = options.promoteValues ?? true; const useBigInt64 = options.useBigInt64 ?? false; if (useBigInt64 && !promoteValues) { throw new BSONError('Must either request bigint or Long for int64 deserialization'); } if (useBigInt64 && !promoteLongs) { throw new BSONError('Must either request bigint or Long for int64 deserialization'); } const validation = options.validation == null ? { utf8: true } : options.validation; let globalUTFValidation = true; let validationSetting; const utf8KeysSet = new Set(); const utf8ValidatedKeys = validation.utf8; if (typeof utf8ValidatedKeys === 'boolean') { validationSetting = utf8ValidatedKeys; } else { globalUTFValidation = false; const utf8ValidationValues = Object.keys(utf8ValidatedKeys).map(function (key) { return utf8ValidatedKeys[key]; }); if (utf8ValidationValues.length === 0) { throw new BSONError('UTF-8 validation setting cannot be empty'); } if (typeof utf8ValidationValues[0] !== 'boolean') { throw new BSONError('Invalid UTF-8 validation option, must specify boolean values'); } validationSetting = utf8ValidationValues[0]; if (!utf8ValidationValues.every(item => item === validationSetting)) { throw new BSONError('Invalid UTF-8 validation option - keys must be all true or all false'); } } if (!globalUTFValidation) { for (const key of Object.keys(utf8ValidatedKeys)) { utf8KeysSet.add(key); } } const startIndex = index; if (buffer.length < 5) throw new BSONError('corrupt bson message < 5 bytes long'); const size = buffer[index++] | (buffer[index++] << 8) | (buffer[index++] << 16) | (buffer[index++] << 24); if (size < 5 || size > buffer.length) throw new BSONError('corrupt bson message'); const object = isArray ? [] : {}; let arrayIndex = 0; const done = false; let isPossibleDBRef = isArray ? false : null; const dataview = new DataView(buffer.buffer, buffer.byteOffset, buffer.byteLength); while (!done) { const elementType = buffer[index++]; if (elementType === 0) break; let i = index; while (buffer[i] !== 0x00 && i < buffer.length) { i++; } if (i >= buffer.byteLength) throw new BSONError('Bad BSON Document: illegal CString'); const name = isArray ? arrayIndex++ : ByteUtils.toUTF8(buffer, index, i, false); let shouldValidateKey = true; if (globalUTFValidation || utf8KeysSet.has(name)) { shouldValidateKey = validationSetting; } else { shouldValidateKey = !validationSetting; } if (isPossibleDBRef !== false && name[0] === '$') { isPossibleDBRef = allowedDBRefKeys.test(name); } let value; index = i + 1; if (elementType === BSON_DATA_STRING) { const stringSize = buffer[index++] | (buffer[index++] << 8) | (buffer[index++] << 16) | (buffer[index++] << 24); if (stringSize <= 0 || stringSize > buffer.length - index || buffer[index + stringSize - 1] !== 0) { throw new BSONError('bad string length in bson'); } value = ByteUtils.toUTF8(buffer, index, index + stringSize - 1, shouldValidateKey); index = index + stringSize; } else if (elementType === BSON_DATA_OID) { const oid = ByteUtils.allocate(12); oid.set(buffer.subarray(index, index + 12)); value = new ObjectId(oid); index = index + 12; } else if (elementType === BSON_DATA_INT && promoteValues === false) { value = new Int32(buffer[index++] | (buffer[index++] << 8) | (buffer[index++] << 16) | (buffer[index++] << 24)); } else if (elementType === BSON_DATA_INT) { value = buffer[index++] | (buffer[index++] << 8) | (buffer[index++] << 16) | (buffer[index++] << 24); } else if (elementType === BSON_DATA_NUMBER && promoteValues === false) { value = new Double(dataview.getFloat64(index, true)); index = index + 8; } else if (elementType === BSON_DATA_NUMBER) { value = dataview.getFloat64(index, true); index = index + 8; } else if (elementType === BSON_DATA_DATE) { const lowBits = buffer[index++] | (buffer[index++] << 8) | (buffer[index++] << 16) | (buffer[index++] << 24); const highBits = buffer[index++] | (buffer[index++] << 8) | (buffer[index++] << 16) | (buffer[index++] << 24); value = new Date(new Long(lowBits, highBits).toNumber()); } else if (elementType === BSON_DATA_BOOLEAN) { if (buffer[index] !== 0 && buffer[index] !== 1) throw new BSONError('illegal boolean type value'); value = buffer[index++] === 1; } else if (elementType === BSON_DATA_OBJECT) { const _index = index; const objectSize = buffer[index] | (buffer[index + 1] << 8) | (buffer[index + 2] << 16) | (buffer[index + 3] << 24); if (objectSize <= 0 || objectSize > buffer.length - index) throw new BSONError('bad embedded document length in bson'); if (raw) { value = buffer.slice(index, index + objectSize); } else { let objectOptions = options; if (!globalUTFValidation) { objectOptions = { ...options, validation: { utf8: shouldValidateKey } }; } value = deserializeObject(buffer, _index, objectOptions, false); } index = index + objectSize; } else if (elementType === BSON_DATA_ARRAY) { const _index = index; const objectSize = buffer[index] | (buffer[index + 1] << 8) | (buffer[index + 2] << 16) | (buffer[index + 3] << 24); let arrayOptions = options; const stopIndex = index + objectSize; if (fieldsAsRaw && fieldsAsRaw[name]) { arrayOptions = { ...options, raw: true }; } if (!globalUTFValidation) { arrayOptions = { ...arrayOptions, validation: { utf8: shouldValidateKey } }; } value = deserializeObject(buffer, _index, arrayOptions, true); index = index + objectSize; if (buffer[index - 1] !== 0) throw new BSONError('invalid array terminator byte'); if (index !== stopIndex) throw new BSONError('corrupted array bson'); } else if (elementType === BSON_DATA_UNDEFINED) { value = undefined; } else if (elementType === BSON_DATA_NULL) { value = null; } else if (elementType === BSON_DATA_LONG) { const dataview = BSONDataView.fromUint8Array(buffer.subarray(index, index + 8)); const lowBits = buffer[index++] | (buffer[index++] << 8) | (buffer[index++] << 16) | (buffer[index++] << 24); const highBits = buffer[index++] | (buffer[index++] << 8) | (buffer[index++] << 16) | (buffer[index++] << 24); const long = new Long(lowBits, highBits); if (useBigInt64) { value = dataview.getBigInt64(0, true); } else if (promoteLongs && promoteValues === true) { value = long.lessThanOrEqual(JS_INT_MAX_LONG) && long.greaterThanOrEqual(JS_INT_MIN_LONG) ? long.toNumber() : long; } else { value = long; } } else if (elementType === BSON_DATA_DECIMAL128) { const bytes = ByteUtils.allocate(16); bytes.set(buffer.subarray(index, index + 16), 0); index = index + 16; value = new Decimal128(bytes); } else if (elementType === BSON_DATA_BINARY) { let binarySize = buffer[index++] | (buffer[index++] << 8) | (buffer[index++] << 16) | (buffer[index++] << 24); const totalBinarySize = binarySize; const subType = buffer[index++]; if (binarySize < 0) throw new BSONError('Negative binary type element size found'); if (binarySize > buffer.byteLength) throw new BSONError('Binary type size larger than document size'); if (buffer['slice'] != null) { if (subType === Binary.SUBTYPE_BYTE_ARRAY) { binarySize = buffer[index++] | (buffer[index++] << 8) | (buffer[index++] << 16) | (buffer[index++] << 24); if (binarySize < 0) throw new BSONError('Negative binary type element size found for subtype 0x02'); if (binarySize > totalBinarySize - 4) throw new BSONError('Binary type with subtype 0x02 contains too long binary size'); if (binarySize < totalBinarySize - 4) throw new BSONError('Binary type with subtype 0x02 contains too short binary size'); } if (promoteBuffers && promoteValues) { value = ByteUtils.toLocalBufferType(buffer.slice(index, index + binarySize)); } else { value = new Binary(buffer.slice(index, index + binarySize), subType); if (subType === BSON_BINARY_SUBTYPE_UUID_NEW && UUID.isValid(value)) { value = value.toUUID(); } } } else { const _buffer = ByteUtils.allocate(binarySize); if (subType === Binary.SUBTYPE_BYTE_ARRAY) { binarySize = buffer[index++] | (buffer[index++] << 8) | (buffer[index++] << 16) | (buffer[index++] << 24); if (binarySize < 0) throw new BSONError('Negative binary type element size found for subtype 0x02'); if (binarySize > totalBinarySize - 4) throw new BSONError('Binary type with subtype 0x02 contains too long binary size'); if (binarySize < totalBinarySize - 4) throw new BSONError('Binary type with subtype 0x02 contains too short binary size'); } for (i = 0; i < binarySize; i++) { _buffer[i] = buffer[index + i]; } if (promoteBuffers && promoteValues) { value = _buffer; } else { value = new Binary(buffer.slice(index, index + binarySize), subType); if (subType === BSON_BINARY_SUBTYPE_UUID_NEW && UUID.isValid(value)) { value = value.toUUID(); } } } index = index + binarySize; } else if (elementType === BSON_DATA_REGEXP && bsonRegExp === false) { i = index; while (buffer[i] !== 0x00 && i < buffer.length) { i++; } if (i >= buffer.length) throw new BSONError('Bad BSON Document: illegal CString'); const source = ByteUtils.toUTF8(buffer, index, i, false); index = i + 1; i = index; while (buffer[i] !== 0x00 && i < buffer.length) { i++; } if (i >= buffer.length) throw new BSONError('Bad BSON Document: illegal CString'); const regExpOptions = ByteUtils.toUTF8(buffer, index, i, false); index = i + 1; const optionsArray = new Array(regExpOptions.length); for (i = 0; i < regExpOptions.length; i++) { switch (regExpOptions[i]) { case 'm': optionsArray[i] = 'm'; break; case 's': optionsArray[i] = 'g'; break; case 'i': optionsArray[i] = 'i'; break; } } value = new RegExp(source, optionsArray.join('')); } else if (elementType === BSON_DATA_REGEXP && bsonRegExp === true) { i = index; while (buffer[i] !== 0x00 && i < buffer.length) { i++; } if (i >= buffer.length) throw new BSONError('Bad BSON Document: illegal CString'); const source = ByteUtils.toUTF8(buffer, index, i, false); index = i + 1; i = index; while (buffer[i] !== 0x00 && i < buffer.length) { i++; } if (i >= buffer.length) throw new BSONError('Bad BSON Document: illegal CString'); const regExpOptions = ByteUtils.toUTF8(buffer, index, i, false); index = i + 1; value = new BSONRegExp(source, regExpOptions); } else if (elementType === BSON_DATA_SYMBOL) { const stringSize = buffer[index++] | (buffer[index++] << 8) | (buffer[index++] << 16) | (buffer[index++] << 24); if (stringSize <= 0 || stringSize > buffer.length - index || buffer[index + stringSize - 1] !== 0) { throw new BSONError('bad string length in bson'); } const symbol = ByteUtils.toUTF8(buffer, index, index + stringSize - 1, shouldValidateKey); value = promoteValues ? symbol : new BSONSymbol(symbol); index = index + stringSize; } else if (elementType === BSON_DATA_TIMESTAMP) { const i = buffer[index++] + buffer[index++] * (1 << 8) + buffer[index++] * (1 << 16) + buffer[index++] * (1 << 24); const t = buffer[index++] + buffer[index++] * (1 << 8) + buffer[index++] * (1 << 16) + buffer[index++] * (1 << 24); value = new Timestamp({ i, t }); } else if (elementType === BSON_DATA_MIN_KEY) { value = new MinKey(); } else if (elementType === BSON_DATA_MAX_KEY) { value = new MaxKey(); } else if (elementType === BSON_DATA_CODE) { const stringSize = buffer[index++] | (buffer[index++] << 8) | (buffer[index++] << 16) | (buffer[index++] << 24); if (stringSize <= 0 || stringSize > buffer.length - index || buffer[index + stringSize - 1] !== 0) { throw new BSONError('bad string length in bson'); } const functionString = ByteUtils.toUTF8(buffer, index, index + stringSize - 1, shouldValidateKey); value = new Code(functionString); index = index + stringSize; } else if (elementType === BSON_DATA_CODE_W_SCOPE) { const totalSize = buffer[index++] | (buffer[index++] << 8) | (buffer[index++] << 16) | (buffer[index++] << 24); if (totalSize < 4 + 4 + 4 + 1) { throw new BSONError('code_w_scope total size shorter minimum expected length'); } const stringSize = buffer[index++] | (buffer[index++] << 8) | (buffer[index++] << 16) | (buffer[index++] << 24); if (stringSize <= 0 || stringSize > buffer.length - index || buffer[index + stringSize - 1] !== 0) { throw new BSONError('bad string length in bson'); } const functionString = ByteUtils.toUTF8(buffer, index, index + stringSize - 1, shouldValidateKey); index = index + stringSize; const _index = index; const objectSize = buffer[index] | (buffer[index + 1] << 8) | (buffer[index + 2] << 16) | (buffer[index + 3] << 24); const scopeObject = deserializeObject(buffer, _index, options, false); index = index + objectSize; if (totalSize < 4 + 4 + objectSize + stringSize) { throw new BSONError('code_w_scope total size is too short, truncating scope'); } if (totalSize > 4 + 4 + objectSize + stringSize) { throw new BSONError('code_w_scope total size is too long, clips outer document'); } value = new Code(functionString, scopeObject); } else if (elementType === BSON_DATA_DBPOINTER) { const stringSize = buffer[index++] | (buffer[index++] << 8) | (buffer[index++] << 16) | (buffer[index++] << 24); if (stringSize <= 0 || stringSize > buffer.length - index || buffer[index + stringSize - 1] !== 0) throw new BSONError('bad string length in bson'); if (validation != null && validation.utf8) { if (!validateUtf8(buffer, index, index + stringSize - 1)) { throw new BSONError('Invalid UTF-8 string in BSON document'); } } const namespace = ByteUtils.toUTF8(buffer, index, index + stringSize - 1, false); index = index + stringSize; const oidBuffer = ByteUtils.allocate(12); oidBuffer.set(buffer.subarray(index, index + 12), 0); const oid = new ObjectId(oidBuffer); index = index + 12; value = new DBRef(namespace, oid); } else { throw new BSONError(`Detected unknown BSON type ${elementType.toString(16)} for fieldname "${name}"`); } if (name === '__proto__') { Object.defineProperty(object, name, { value, writable: true, enumerable: true, configurable: true }); } else { object[name] = value; } } if (size !== index - startIndex) { if (isArray) throw new BSONError('corrupt array bson'); throw new BSONError('corrupt object bson'); } if (!isPossibleDBRef) return object; if (isDBRefLike(object)) { const copy = Object.assign({}, object); delete copy.$ref; delete copy.$id; delete copy.$db; return new DBRef(object.$ref, object.$id, object.$db, copy); } return object; }  const regexp = /\x00/; const ignoreKeys = new Set(['$db', '$ref', '$id', '$clusterTime']); function serializeString(buffer, key, value, index) { buffer[index++] = BSON_DATA_STRING; const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer, key, index); index = index + numberOfWrittenBytes + 1; buffer[index - 1] = 0; const size = ByteUtils.encodeUTF8Into(buffer, value, index + 4); buffer[index + 3] = ((size + 1) >> 24) & 0xff; buffer[index + 2] = ((size + 1) >> 16) & 0xff; buffer[index + 1] = ((size + 1) >> 8) & 0xff; buffer[index] = (size + 1) & 0xff; index = index + 4 + size; buffer[index++] = 0; return index; } const NUMBER_SPACE = new DataView(new ArrayBuffer(8), 0, 8); const FOUR_BYTE_VIEW_ON_NUMBER = new Uint8Array(NUMBER_SPACE.buffer, 0, 4); const EIGHT_BYTE_VIEW_ON_NUMBER = new Uint8Array(NUMBER_SPACE.buffer, 0, 8); function serializeNumber(buffer, key, value, index) { const isNegativeZero = Object.is(value, -0); const type = !isNegativeZero && Number.isSafeInteger(value) && value <= BSON_INT32_MAX && value >= BSON_INT32_MIN ? BSON_DATA_INT : BSON_DATA_NUMBER; if (type === BSON_DATA_INT) { NUMBER_SPACE.setInt32(0, value, true); } else { NUMBER_SPACE.setFloat64(0, value, true); } const bytes = type === BSON_DATA_INT ? FOUR_BYTE_VIEW_ON_NUMBER : EIGHT_BYTE_VIEW_ON_NUMBER; buffer[index++] = type; const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer, key, index); index = index + numberOfWrittenBytes; buffer[index++] = 0x00; buffer.set(bytes, index); index += bytes.byteLength; return index; } function serializeBigInt(buffer, key, value, index) { buffer[index++] = BSON_DATA_LONG; const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer, key, index); index += numberOfWrittenBytes; buffer[index++] = 0; NUMBER_SPACE.setBigInt64(0, value, true); buffer.set(EIGHT_BYTE_VIEW_ON_NUMBER, index); index += EIGHT_BYTE_VIEW_ON_NUMBER.byteLength; return index; } function serializeNull(buffer, key, _, index) { buffer[index++] = BSON_DATA_NULL; const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer, key, index); index = index + numberOfWrittenBytes; buffer[index++] = 0; return index; } function serializeBoolean(buffer, key, value, index) { buffer[index++] = BSON_DATA_BOOLEAN; const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer, key, index); index = index + numberOfWrittenBytes; buffer[index++] = 0; buffer[index++] = value ? 1 : 0; return index; } function serializeDate(buffer, key, value, index) { buffer[index++] = BSON_DATA_DATE; const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer, key, index); index = index + numberOfWrittenBytes; buffer[index++] = 0; const dateInMilis = Long.fromNumber(value.getTime()); const lowBits = dateInMilis.getLowBits(); const highBits = dateInMilis.getHighBits(); buffer[index++] = lowBits & 0xff; buffer[index++] = (lowBits >> 8) & 0xff; buffer[index++] = (lowBits >> 16) & 0xff; buffer[index++] = (lowBits >> 24) & 0xff; buffer[index++] = highBits & 0xff; buffer[index++] = (highBits >> 8) & 0xff; buffer[index++] = (highBits >> 16) & 0xff; buffer[index++] = (highBits >> 24) & 0xff; return index; } function serializeRegExp(buffer, key, value, index) { buffer[index++] = BSON_DATA_REGEXP; const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer, key, index); index = index + numberOfWrittenBytes; buffer[index++] = 0; if (value.source && value.source.match(regexp) != null) { throw new BSONError('value ' + value.source + ' must not contain null bytes'); } index = index + ByteUtils.encodeUTF8Into(buffer, value.source, index); buffer[index++] = 0x00; if (value.ignoreCase) buffer[index++] = 0x69; if (value.global) buffer[index++] = 0x73; if (value.multiline) buffer[index++] = 0x6d; buffer[index++] = 0x00; return index; } function serializeBSONRegExp(buffer, key, value, index) { buffer[index++] = BSON_DATA_REGEXP; const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer, key, index); index = index + numberOfWrittenBytes; buffer[index++] = 0; if (value.pattern.match(regexp) != null) { throw new BSONError('pattern ' + value.pattern + ' must not contain null bytes'); } index = index + ByteUtils.encodeUTF8Into(buffer, value.pattern, index); buffer[index++] = 0x00; const sortedOptions = value.options.split('').sort().join(''); index = index + ByteUtils.encodeUTF8Into(buffer, sortedOptions, index); buffer[index++] = 0x00; return index; } function serializeMinMax(buffer, key, value, index) { if (value === null) { buffer[index++] = BSON_DATA_NULL; } else if (value._bsontype === 'MinKey') { buffer[index++] = BSON_DATA_MIN_KEY; } else { buffer[index++] = BSON_DATA_MAX_KEY; } const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer, key, index); index = index + numberOfWrittenBytes; buffer[index++] = 0; return index; } function serializeObjectId(buffer, key, value, index) { buffer[index++] = BSON_DATA_OID; const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer, key, index); index = index + numberOfWrittenBytes; buffer[index++] = 0; const idValue = value.id; if (isUint8Array(idValue)) { for (let i = 0; i < 12; i++) { buffer[index++] = idValue[i]; } } else { throw new BSONError('object [' + JSON.stringify(value) + '] is not a valid ObjectId'); } return index; } function serializeBuffer(buffer, key, value, index) { buffer[index++] = BSON_DATA_BINARY; const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer, key, index); index = index + numberOfWrittenBytes; buffer[index++] = 0; const size = value.length; buffer[index++] = size & 0xff; buffer[index++] = (size >> 8) & 0xff; buffer[index++] = (size >> 16) & 0xff; buffer[index++] = (size >> 24) & 0xff; buffer[index++] = BSON_BINARY_SUBTYPE_DEFAULT; buffer.set(value, index); index = index + size; return index; } function serializeObject(buffer, key, value, index, checkKeys, depth, serializeFunctions, ignoreUndefined, path) { if (path.has(value)) { throw new BSONError('Cannot convert circular structure to BSON'); } path.add(value); buffer[index++] = Array.isArray(value) ? BSON_DATA_ARRAY : BSON_DATA_OBJECT; const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer, key, index); index = index + numberOfWrittenBytes; buffer[index++] = 0; const endIndex = serializeInto(buffer, value, checkKeys, index, depth + 1, serializeFunctions, ignoreUndefined, path); path.delete(value); return endIndex; } function serializeDecimal128(buffer, key, value, index) { buffer[index++] = BSON_DATA_DECIMAL128; const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer, key, index); index = index + numberOfWrittenBytes; buffer[index++] = 0; buffer.set(value.bytes.subarray(0, 16), index); return index + 16; } function serializeLong(buffer, key, value, index) { buffer[index++] = value._bsontype === 'Long' ? BSON_DATA_LONG : BSON_DATA_TIMESTAMP; const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer, key, index); index = index + numberOfWrittenBytes; buffer[index++] = 0; const lowBits = value.getLowBits(); const highBits = value.getHighBits(); buffer[index++] = lowBits & 0xff; buffer[index++] = (lowBits >> 8) & 0xff; buffer[index++] = (lowBits >> 16) & 0xff; buffer[index++] = (lowBits >> 24) & 0xff; buffer[index++] = highBits & 0xff; buffer[index++] = (highBits >> 8) & 0xff; buffer[index++] = (highBits >> 16) & 0xff; buffer[index++] = (highBits >> 24) & 0xff; return index; } function serializeInt32(buffer, key, value, index) { value = value.valueOf(); buffer[index++] = BSON_DATA_INT; const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer, key, index); index = index + numberOfWrittenBytes; buffer[index++] = 0; buffer[index++] = value & 0xff; buffer[index++] = (value >> 8) & 0xff; buffer[index++] = (value >> 16) & 0xff; buffer[index++] = (value >> 24) & 0xff; return index; } function serializeDouble(buffer, key, value, index) { buffer[index++] = BSON_DATA_NUMBER; const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer, key, index); index = index + numberOfWrittenBytes; buffer[index++] = 0; NUMBER_SPACE.setFloat64(0, value.value, true); buffer.set(EIGHT_BYTE_VIEW_ON_NUMBER, index); index = index + 8; return index; } function serializeFunction(buffer, key, value, index) { buffer[index++] = BSON_DATA_CODE; const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer, key, index); index = index + numberOfWrittenBytes; buffer[index++] = 0; const functionString = value.toString(); const size = ByteUtils.encodeUTF8Into(buffer, functionString, index + 4) + 1; buffer[index] = size & 0xff; buffer[index + 1] = (size >> 8) & 0xff; buffer[index + 2] = (size >> 16) & 0xff; buffer[index + 3] = (size >> 24) & 0xff; index = index + 4 + size - 1; buffer[index++] = 0; return index; } function serializeCode(buffer, key, value, index, checkKeys = false, depth = 0, serializeFunctions = false, ignoreUndefined = true, path) { if (value.scope && typeof value.scope === 'object') { buffer[index++] = BSON_DATA_CODE_W_SCOPE; const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer, key, index); index = index + numberOfWrittenBytes; buffer[index++] = 0; let startIndex = index; const functionString = value.code; index = index + 4; const codeSize = ByteUtils.encodeUTF8Into(buffer, functionString, index + 4) + 1; buffer[index] = codeSize & 0xff; buffer[index + 1] = (codeSize >> 8) & 0xff; buffer[index + 2] = (codeSize >> 16) & 0xff; buffer[index + 3] = (codeSize >> 24) & 0xff; buffer[index + 4 + codeSize - 1] = 0; index = index + codeSize + 4; const endIndex = serializeInto(buffer, value.scope, checkKeys, index, depth + 1, serializeFunctions, ignoreUndefined, path); index = endIndex - 1; const totalSize = endIndex - startIndex; buffer[startIndex++] = totalSize & 0xff; buffer[startIndex++] = (totalSize >> 8) & 0xff; buffer[startIndex++] = (totalSize >> 16) & 0xff; buffer[startIndex++] = (totalSize >> 24) & 0xff; buffer[index++] = 0; } else { buffer[index++] = BSON_DATA_CODE; const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer, key, index); index = index + numberOfWrittenBytes; buffer[index++] = 0; const functionString = value.code.toString(); const size = ByteUtils.encodeUTF8Into(buffer, functionString, index + 4) + 1; buffer[index] = size & 0xff; buffer[index + 1] = (size >> 8) & 0xff; buffer[index + 2] = (size >> 16) & 0xff; buffer[index + 3] = (size >> 24) & 0xff; index = index + 4 + size - 1; buffer[index++] = 0; } return index; } function serializeBinary(buffer, key, value, index) { buffer[index++] = BSON_DATA_BINARY; const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer, key, index); index = index + numberOfWrittenBytes; buffer[index++] = 0; const data = value.buffer; let size = value.position; if (value.sub_type === Binary.SUBTYPE_BYTE_ARRAY) size = size + 4; buffer[index++] = size & 0xff; buffer[index++] = (size >> 8) & 0xff; buffer[index++] = (size >> 16) & 0xff; buffer[index++] = (size >> 24) & 0xff; buffer[index++] = value.sub_type; if (value.sub_type === Binary.SUBTYPE_BYTE_ARRAY) { size = size - 4; buffer[index++] = size & 0xff; buffer[index++] = (size >> 8) & 0xff; buffer[index++] = (size >> 16) & 0xff; buffer[index++] = (size >> 24) & 0xff; } buffer.set(data, index); index = index + value.position; return index; } function serializeSymbol(buffer, key, value, index) { buffer[index++] = BSON_DATA_SYMBOL; const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer, key, index); index = index + numberOfWrittenBytes; buffer[index++] = 0; const size = ByteUtils.encodeUTF8Into(buffer, value.value, index + 4) + 1; buffer[index] = size & 0xff; buffer[index + 1] = (size >> 8) & 0xff; buffer[index + 2] = (size >> 16) & 0xff; buffer[index + 3] = (size >> 24) & 0xff; index = index + 4 + size - 1; buffer[index++] = 0x00; return index; } function serializeDBRef(buffer, key, value, index, depth, serializeFunctions, path) { buffer[index++] = BSON_DATA_OBJECT; const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer, key, index); index = index + numberOfWrittenBytes; buffer[index++] = 0; let startIndex = index; let output = { $ref: value.collection || value.namespace, $id: value.oid }; if (value.db != null) { output.$db = value.db; } output = Object.assign(output, value.fields); const endIndex = serializeInto(buffer, output, false, index, depth + 1, serializeFunctions, true, path); const size = endIndex - startIndex; buffer[startIndex++] = size & 0xff; buffer[startIndex++] = (size >> 8) & 0xff; buffer[startIndex++] = (size >> 16) & 0xff; buffer[startIndex++] = (size >> 24) & 0xff; return endIndex; } function serializeInto(buffer, object, checkKeys, startingIndex, depth, serializeFunctions, ignoreUndefined, path) { if (path == null) { if (object == null) { buffer[0] = 0x05; buffer[1] = 0x00; buffer[2] = 0x00; buffer[3] = 0x00; buffer[4] = 0x00; return 5; } if (Array.isArray(object)) { throw new BSONError('serialize does not support an array as the root input'); } if (typeof object !== 'object') { throw new BSONError('serialize does not support non-object as the root input'); } else if ('_bsontype' in object && typeof object._bsontype === 'string') { throw new BSONError(`BSON types cannot be serialized as a document`); } else if (isDate(object) || isRegExp(object) || isUint8Array(object) || isAnyArrayBuffer(object)) { throw new BSONError(`date, regexp, typedarray, and arraybuffer cannot be BSON documents`); } path = new Set(); } path.add(object); let index = startingIndex + 4; if (Array.isArray(object)) { for (let i = 0; i < object.length; i++) { const key = `${i}`; let value = object[i]; if (typeof value?.toBSON === 'function') { value = value.toBSON(); } if (typeof value === 'string') { index = serializeString(buffer, key, value, index); } else if (typeof value === 'number') { index = serializeNumber(buffer, key, value, index); } else if (typeof value === 'bigint') { index = serializeBigInt(buffer, key, value, index); } else if (typeof value === 'boolean') { index = serializeBoolean(buffer, key, value, index); } else if (value instanceof Date || isDate(value)) { index = serializeDate(buffer, key, value, index); } else if (value === undefined) { index = serializeNull(buffer, key, value, index); } else if (value === null) { index = serializeNull(buffer, key, value, index); } else if (isUint8Array(value)) { index = serializeBuffer(buffer, key, value, index); } else if (value instanceof RegExp || isRegExp(value)) { index = serializeRegExp(buffer, key, value, index); } else if (typeof value === 'object' && value._bsontype == null) { index = serializeObject(buffer, key, value, index, checkKeys, depth, serializeFunctions, ignoreUndefined, path); } else if (typeof value === 'object' && value[Symbol.for('@@mdb.bson.version')] !== BSON_MAJOR_VERSION) { throw new BSONVersionError(); } else if (value._bsontype === 'ObjectId') { index = serializeObjectId(buffer, key, value, index); } else if (value._bsontype === 'Decimal128') { index = serializeDecimal128(buffer, key, value, index); } else if (value._bsontype === 'Long' || value._bsontype === 'Timestamp') { index = serializeLong(buffer, key, value, index); } else if (value._bsontype === 'Double') { index = serializeDouble(buffer, key, value, index); } else if (typeof value === 'function' && serializeFunctions) { index = serializeFunction(buffer, key, value, index); } else if (value._bsontype === 'Code') { index = serializeCode(buffer, key, value, index, checkKeys, depth, serializeFunctions, ignoreUndefined, path); } else if (value._bsontype === 'Binary') { index = serializeBinary(buffer, key, value, index); } else if (value._bsontype === 'BSONSymbol') { index = serializeSymbol(buffer, key, value, index); } else if (value._bsontype === 'DBRef') { index = serializeDBRef(buffer, key, value, index, depth, serializeFunctions, path); } else if (value._bsontype === 'BSONRegExp') { index = serializeBSONRegExp(buffer, key, value, index); } else if (value._bsontype === 'Int32') { index = serializeInt32(buffer, key, value, index); } else if (value._bsontype === 'MinKey' || value._bsontype === 'MaxKey') { index = serializeMinMax(buffer, key, value, index); } else if (typeof value._bsontype !== 'undefined') { throw new BSONError(`Unrecognized or invalid _bsontype: ${String(value._bsontype)}`); } } } else if (object instanceof Map || isMap(object)) { const iterator = object.entries(); let done = false; while (!done) { const entry = iterator.next(); done = !!entry.done; if (done) continue; const key = entry.value[0]; let value = entry.value[1]; if (typeof value?.toBSON === 'function') { value = value.toBSON(); } const type = typeof value; if (typeof key === 'string' && !ignoreKeys.has(key)) { if (key.match(regexp) != null) { throw new BSONError('key ' + key + ' must not contain null bytes'); } if (checkKeys) { if ('$' === key[0]) { throw new BSONError('key ' + key + " must not start with '$'"); } else if (~key.indexOf('.')) { throw new BSONError('key ' + key + " must not contain '.'"); } } } if (type === 'string') { index = serializeString(buffer, key, value, index); } else if (type === 'number') { index = serializeNumber(buffer, key, value, index); } else if (type === 'bigint') { index = serializeBigInt(buffer, key, value, index); } else if (type === 'boolean') { index = serializeBoolean(buffer, key, value, index); } else if (value instanceof Date || isDate(value)) { index = serializeDate(buffer, key, value, index); } else if (value === null || (value === undefined && ignoreUndefined === false)) { index = serializeNull(buffer, key, value, index); } else if (isUint8Array(value)) { index = serializeBuffer(buffer, key, value, index); } else if (value instanceof RegExp || isRegExp(value)) { index = serializeRegExp(buffer, key, value, index); } else if (type === 'object' && value._bsontype == null) { index = serializeObject(buffer, key, value, index, checkKeys, depth, serializeFunctions, ignoreUndefined, path); } else if (typeof value === 'object' && value[Symbol.for('@@mdb.bson.version')] !== BSON_MAJOR_VERSION) { throw new BSONVersionError(); } else if (value._bsontype === 'ObjectId') { index = serializeObjectId(buffer, key, value, index); } else if (type === 'object' && value._bsontype === 'Decimal128') { index = serializeDecimal128(buffer, key, value, index); } else if (value._bsontype === 'Long' || value._bsontype === 'Timestamp') { index = serializeLong(buffer, key, value, index); } else if (value._bsontype === 'Double') { index = serializeDouble(buffer, key, value, index); } else if (value._bsontype === 'Code') { index = serializeCode(buffer, key, value, index, checkKeys, depth, serializeFunctions, ignoreUndefined, path); } else if (typeof value === 'function' && serializeFunctions) { index = serializeFunction(buffer, key, value, index); } else if (value._bsontype === 'Binary') { index = serializeBinary(buffer, key, value, index); } else if (value._bsontype === 'BSONSymbol') { index = serializeSymbol(buffer, key, value, index); } else if (value._bsontype === 'DBRef') { index = serializeDBRef(buffer, key, value, index, depth, serializeFunctions, path); } else if (value._bsontype === 'BSONRegExp') { index = serializeBSONRegExp(buffer, key, value, index); } else if (value._bsontype === 'Int32') { index = serializeInt32(buffer, key, value, index); } else if (value._bsontype === 'MinKey' || value._bsontype === 'MaxKey') { index = serializeMinMax(buffer, key, value, index); } else if (typeof value._bsontype !== 'undefined') { throw new BSONError(`Unrecognized or invalid _bsontype: ${String(value._bsontype)}`); } } } else { if (typeof object?.toBSON === 'function') { object = object.toBSON(); if (object != null && typeof object !== 'object') { throw new BSONError('toBSON function did not return an object'); } } for (const key of Object.keys(object)) { let value = object[key]; if (typeof value?.toBSON === 'function') { value = value.toBSON(); } const type = typeof value; if (typeof key === 'string' && !ignoreKeys.has(key)) { if (key.match(regexp) != null) { throw new BSONError('key ' + key + ' must not contain null bytes'); } if (checkKeys) { if ('$' === key[0]) { throw new BSONError('key ' + key + " must not start with '$'"); } else if (~key.indexOf('.')) { throw new BSONError('key ' + key + " must not contain '.'"); } } } if (type === 'string') { index = serializeString(buffer, key, value, index); } else if (type === 'number') { index = serializeNumber(buffer, key, value, index); } else if (type === 'bigint') { index = serializeBigInt(buffer, key, value, index); } else if (type === 'boolean') { index = serializeBoolean(buffer, key, value, index); } else if (value instanceof Date || isDate(value)) { index = serializeDate(buffer, key, value, index); } else if (value === undefined) { if (ignoreUndefined === false) index = serializeNull(buffer, key, value, index); } else if (value === null) { index = serializeNull(buffer, key, value, index); } else if (isUint8Array(value)) { index = serializeBuffer(buffer, key, value, index); } else if (value instanceof RegExp || isRegExp(value)) { index = serializeRegExp(buffer, key, value, index); } else if (type === 'object' && value._bsontype == null) { index = serializeObject(buffer, key, value, index, checkKeys, depth, serializeFunctions, ignoreUndefined, path); } else if (typeof value === 'object' && value[Symbol.for('@@mdb.bson.version')] !== BSON_MAJOR_VERSION) { throw new BSONVersionError(); } else if (value._bsontype === 'ObjectId') { index = serializeObjectId(buffer, key, value, index); } else if (type === 'object' && value._bsontype === 'Decimal128') { index = serializeDecimal128(buffer, key, value, index); } else if (value._bsontype === 'Long' || value._bsontype === 'Timestamp') { index = serializeLong(buffer, key, value, index); } else if (value._bsontype === 'Double') { index = serializeDouble(buffer, key, value, index); } else if (value._bsontype === 'Code') { index = serializeCode(buffer, key, value, index, checkKeys, depth, serializeFunctions, ignoreUndefined, path); } else if (typeof value === 'function' && serializeFunctions) { index = serializeFunction(buffer, key, value, index); } else if (value._bsontype === 'Binary') { index = serializeBinary(buffer, key, value, index); } else if (value._bsontype === 'BSONSymbol') { index = serializeSymbol(buffer, key, value, index); } else if (value._bsontype === 'DBRef') { index = serializeDBRef(buffer, key, value, index, depth, serializeFunctions, path); } else if (value._bsontype === 'BSONRegExp') { index = serializeBSONRegExp(buffer, key, value, index); } else if (value._bsontype === 'Int32') { index = serializeInt32(buffer, key, value, index); } else if (value._bsontype === 'MinKey' || value._bsontype === 'MaxKey') { index = serializeMinMax(buffer, key, value, index); } else if (typeof value._bsontype !== 'undefined') { throw new BSONError(`Unrecognized or invalid _bsontype: ${String(value._bsontype)}`); } } } path.delete(object); buffer[index++] = 0x00; const size = index - startingIndex; buffer[startingIndex++] = size & 0xff; buffer[startingIndex++] = (size >> 8) & 0xff; buffer[startingIndex++] = (size >> 16) & 0xff; buffer[startingIndex++] = (size >> 24) & 0xff; return index; }  function isBSONType(value) { return (value != null && typeof value === 'object' && '_bsontype' in value && typeof value._bsontype === 'string'); } const keysToCodecs = { $oid: ObjectId, $binary: Binary, $uuid: Binary, $symbol: BSONSymbol, $numberInt: Int32, $numberDecimal: Decimal128, $numberDouble: Double, $numberLong: Long, $minKey: MinKey, $maxKey: MaxKey, $regex: BSONRegExp, $regularExpression: BSONRegExp, $timestamp: Timestamp }; function deserializeValue(value, options = {}) { if (typeof value === 'number') { const in32BitRange = value <= BSON_INT32_MAX && value >= BSON_INT32_MIN; const in64BitRange = value <= BSON_INT64_MAX && value >= BSON_INT64_MIN; if (options.relaxed || options.legacy) { return value; } if (Number.isInteger(value) && !Object.is(value, -0)) { if (in32BitRange) { return new Int32(value); } if (in64BitRange) { if (options.useBigInt64) { return BigInt(value); } return Long.fromNumber(value); } } return new Double(value); } if (value == null || typeof value !== 'object') return value; if (value.$undefined) return null; const keys = Object.keys(value).filter(k => k.startsWith('$') && value[k] != null); for (let i = 0; i < keys.length; i++) { const c = keysToCodecs[keys[i]]; if (c) return c.fromExtendedJSON(value, options); } if (value.$date != null) { const d = value.$date; const date = new Date(); if (options.legacy) { if (typeof d === 'number') date.setTime(d); else if (typeof d === 'string') date.setTime(Date.parse(d)); else if (typeof d === 'bigint') date.setTime(Number(d)); else throw new BSONRuntimeError(`Unrecognized type for EJSON date: ${typeof d}`); } else { if (typeof d === 'string') date.setTime(Date.parse(d)); else if (Long.isLong(d)) date.setTime(d.toNumber()); else if (typeof d === 'number' && options.relaxed) date.setTime(d); else if (typeof d === 'bigint') date.setTime(Number(d)); else throw new BSONRuntimeError(`Unrecognized type for EJSON date: ${typeof d}`); } return date; } if (value.$code != null) { const copy = Object.assign({}, value); if (value.$scope) { copy.$scope = deserializeValue(value.$scope); } return Code.fromExtendedJSON(value); } if (isDBRefLike(value) || value.$dbPointer) { const v = value.$ref ? value : value.$dbPointer; if (v instanceof DBRef) return v; const dollarKeys = Object.keys(v).filter(k => k.startsWith('$')); let valid = true; dollarKeys.forEach(k => { if (['$ref', '$id', '$db'].indexOf(k) === -1) valid = false; }); if (valid) return DBRef.fromExtendedJSON(v); } return value; } function serializeArray(array, options) { return array.map((v, index) => { options.seenObjects.push({ propertyName: `index ${index}`, obj: null }); try { return serializeValue(v, options); } finally { options.seenObjects.pop(); } }); } function getISOString(date) { const isoStr = date.toISOString(); return date.getUTCMilliseconds() !== 0 ? isoStr : isoStr.slice(0, -5) + 'Z'; } function serializeValue(value, options) { if (value instanceof Map || isMap(value)) { const obj = Object.create(null); for (const [k, v] of value) { if (typeof k !== 'string') { throw new BSONError('Can only serialize maps with string keys'); } obj[k] = v; } return serializeValue(obj, options); } if ((typeof value === 'object' || typeof value === 'function') && value !== null) { const index = options.seenObjects.findIndex(entry => entry.obj === value); if (index !== -1) { const props = options.seenObjects.map(entry => entry.propertyName); const leadingPart = props .slice(0, index) .map(prop => `${prop} -> `) .join(''); const alreadySeen = props[index]; const circularPart = ' -> ' + props .slice(index + 1, props.length - 1) .map(prop => `${prop} -> `) .join(''); const current = props[props.length - 1]; const leadingSpace = ' '.repeat(leadingPart.length + alreadySeen.length / 2); const dashes = '-'.repeat(circularPart.length + (alreadySeen.length + current.length) / 2 - 1); throw new BSONError('Converting circular structure to EJSON:\n' + `    ${leadingPart}${alreadySeen}${circularPart}${current}\n` + `    ${leadingSpace}\\${dashes}/`); } options.seenObjects[options.seenObjects.length - 1].obj = value; } if (Array.isArray(value)) return serializeArray(value, options); if (value === undefined) return null; if (value instanceof Date || isDate(value)) { const dateNum = value.getTime(), inRange = dateNum > -1 && dateNum < 253402318800000; if (options.legacy) { return options.relaxed && inRange ? { $date: value.getTime() } : { $date: getISOString(value) }; } return options.relaxed && inRange ? { $date: getISOString(value) } : { $date: { $numberLong: value.getTime().toString() } }; } if (typeof value === 'number' && (!options.relaxed || !isFinite(value))) { if (Number.isInteger(value) && !Object.is(value, -0)) { if (value >= BSON_INT32_MIN && value <= BSON_INT32_MAX) { return { $numberInt: value.toString() }; } if (value >= BSON_INT64_MIN && value <= BSON_INT64_MAX) { return { $numberLong: value.toString() }; } } return { $numberDouble: Object.is(value, -0) ? '-0.0' : value.toString() }; } if (typeof value === 'bigint') { if (!options.relaxed) { return { $numberLong: BigInt.asIntN(64, value).toString() }; } return Number(BigInt.asIntN(64, value)); } if (value instanceof RegExp || isRegExp(value)) { let flags = value.flags; if (flags === undefined) { const match = value.toString().match(/[gimuy]*$/); if (match) { flags = match[0]; } } const rx = new BSONRegExp(value.source, flags); return rx.toExtendedJSON(options); } if (value != null && typeof value === 'object') return serializeDocument(value, options); return value; } const BSON_TYPE_MAPPINGS = { Binary: (o) => new Binary(o.value(), o.sub_type), Code: (o) => new Code(o.code, o.scope), DBRef: (o) => new DBRef(o.collection || o.namespace, o.oid, o.db, o.fields), Decimal128: (o) => new Decimal128(o.bytes), Double: (o) => new Double(o.value), Int32: (o) => new Int32(o.value), Long: (o) => Long.fromBits(o.low != null ? o.low : o.low_, o.low != null ? o.high : o.high_, o.low != null ? o.unsigned : o.unsigned_), MaxKey: () => new MaxKey(), MinKey: () => new MinKey(), ObjectId: (o) => new ObjectId(o), BSONRegExp: (o) => new BSONRegExp(o.pattern, o.options), BSONSymbol: (o) => new BSONSymbol(o.value), Timestamp: (o) => Timestamp.fromBits(o.low, o.high) }; function serializeDocument(doc, options) { if (doc == null || typeof doc !== 'object') throw new BSONError('not an object instance'); const bsontype = doc._bsontype; if (typeof bsontype === 'undefined') { const _doc = {}; for (const name of Object.keys(doc)) { options.seenObjects.push({ propertyName: name, obj: null }); try { const value = serializeValue(doc[name], options); if (name === '__proto__') { Object.defineProperty(_doc, name, { value, writable: true, enumerable: true, configurable: true }); } else { _doc[name] = value; } } finally { options.seenObjects.pop(); } } return _doc; } else if (doc != null && typeof doc === 'object' && typeof doc._bsontype === 'string' && doc[Symbol.for('@@mdb.bson.version')] !== BSON_MAJOR_VERSION) { throw new BSONVersionError(); } else if (isBSONType(doc)) { let outDoc = doc; if (typeof outDoc.toExtendedJSON !== 'function') { const mapper = BSON_TYPE_MAPPINGS[doc._bsontype]; if (!mapper) { throw new BSONError('Unrecognized or invalid _bsontype: ' + doc._bsontype); } outDoc = mapper(outDoc); } if (bsontype === 'Code' && outDoc.scope) { outDoc = new Code(outDoc.code, serializeValue(outDoc.scope, options)); } else if (bsontype === 'DBRef' && outDoc.oid) { outDoc = new DBRef(serializeValue(outDoc.collection, options), serializeValue(outDoc.oid, options), serializeValue(outDoc.db, options), serializeValue(outDoc.fields, options)); } return outDoc.toExtendedJSON(options); } else { throw new BSONError('_bsontype must be a string, but was: ' + typeof bsontype); } } function parse(text, options) { const ejsonOptions = { useBigInt64: options?.useBigInt64 ?? false, relaxed: options?.relaxed ?? true, legacy: options?.legacy ?? false }; return JSON.parse(text, (key, value) => { if (key.indexOf('\x00') !== -1) { throw new BSONError(`BSON Document field names cannot contain null bytes, found: ${JSON.stringify(key)}`); } return deserializeValue(value, ejsonOptions); }); } function stringify(value, replacer, space, options) { if (space != null && typeof space === 'object') { options = space; space = 0; } if (replacer != null && typeof replacer === 'object' && !Array.isArray(replacer)) { options = replacer; replacer = undefined; space = 0; } const serializeOptions = Object.assign({ relaxed: true, legacy: false }, options, { seenObjects: [{ propertyName: '(root)', obj: null }] }); const doc = serializeValue(value, serializeOptions); return JSON.stringify(doc, replacer, space); } function EJSONserialize(value, options) { options = options || {}; return JSON.parse(stringify(value, options)); } function EJSONdeserialize(ejson, options) { options = options || {}; return parse(JSON.stringify(ejson), options); } const EJSON = Object.create(null); EJSON.parse = parse; EJSON.stringify = stringify; EJSON.serialize = EJSONserialize; EJSON.deserialize = EJSONdeserialize; Object.freeze(EJSON);  const MAXSIZE = 1024 * 1024 * 17; let buffer = ByteUtils.allocate(MAXSIZE); function setInternalBufferSize(size) { if (buffer.length < size) { buffer = ByteUtils.allocate(size); } } function serialize(object, options = {}) { const checkKeys = typeof options.checkKeys === 'boolean' ? options.checkKeys : false; const serializeFunctions = typeof options.serializeFunctions === 'boolean' ? options.serializeFunctions : false; const ignoreUndefined = typeof options.ignoreUndefined === 'boolean' ? options.ignoreUndefined : true; const minInternalBufferSize = typeof options.minInternalBufferSize === 'number' ? options.minInternalBufferSize : MAXSIZE; if (buffer.length < minInternalBufferSize) { buffer = ByteUtils.allocate(minInternalBufferSize); } const serializationIndex = serializeInto(buffer, object, checkKeys, 0, 0, serializeFunctions, ignoreUndefined, null); const finishedBuffer = ByteUtils.allocate(serializationIndex); finishedBuffer.set(buffer.subarray(0, serializationIndex), 0); return finishedBuffer; } function serializeWithBufferAndIndex(object, finalBuffer, options = {}) { const checkKeys = typeof options.checkKeys === 'boolean' ? options.checkKeys : false; const serializeFunctions = typeof options.serializeFunctions === 'boolean' ? options.serializeFunctions : false; const ignoreUndefined = typeof options.ignoreUndefined === 'boolean' ? options.ignoreUndefined : true; const startIndex = typeof options.index === 'number' ? options.index : 0; const serializationIndex = serializeInto(buffer, object, checkKeys, 0, 0, serializeFunctions, ignoreUndefined, null); finalBuffer.set(buffer.subarray(0, serializationIndex), startIndex); return startIndex + serializationIndex - 1; } function deserialize(buffer, options = {}) { return internalDeserialize(ByteUtils.toLocalBufferType(buffer), options); } function calculateObjectSize(object, options = {}) { options = options || {}; const serializeFunctions = typeof options.serializeFunctions === 'boolean' ? options.serializeFunctions : false; const ignoreUndefined = typeof options.ignoreUndefined === 'boolean' ? options.ignoreUndefined : true; return internalCalculateObjectSize(object, serializeFunctions, ignoreUndefined); } function deserializeStream(data, startIndex, numberOfDocuments, documents, docStartIndex, options) { const internalOptions = Object.assign({ allowObjectSmallerThanBufferSize: true, index: 0 }, options); const bufferData = ByteUtils.toLocalBufferType(data); let index = startIndex; for (let i = 0; i < numberOfDocuments; i++) { const size = bufferData[index] | (bufferData[index + 1] << 8) | (bufferData[index + 2] << 16) | (bufferData[index + 3] << 24); internalOptions.index = index; documents[docStartIndex + i] = internalDeserialize(bufferData, internalOptions); index = index + size; } return index; }  var bson = /*#__PURE__*/Object.freeze({ __proto__: null, BSONError: BSONError, BSONRegExp: BSONRegExp, BSONRuntimeError: BSONRuntimeError, BSONSymbol: BSONSymbol, BSONType: BSONType, BSONValue: BSONValue, BSONVersionError: BSONVersionError, Binary: Binary, Code: Code, DBRef: DBRef, Decimal128: Decimal128, Double: Double, EJSON: EJSON, Int32: Int32, Long: Long, MaxKey: MaxKey, MinKey: MinKey, ObjectId: ObjectId, Timestamp: Timestamp, UUID: UUID, calculateObjectSize: calculateObjectSize, deserialize: deserialize, deserializeStream: deserializeStream, serialize: serialize, serializeWithBufferAndIndex: serializeWithBufferAndIndex, setInternalBufferSize: setInternalBufferSize });  exports.BSON = bson; exports.BSONError = BSONError; exports.BSONRegExp = BSONRegExp; exports.BSONRuntimeError = BSONRuntimeError; exports.BSONSymbol = BSONSymbol; exports.BSONType = BSONType; exports.BSONValue = BSONValue; exports.BSONVersionError = BSONVersionError; exports.Binary = Binary; exports.Code = Code; exports.DBRef = DBRef; exports.Decimal128 = Decimal128; exports.Double = Double; exports.EJSON = EJSON; exports.Int32 = Int32; exports.Long = Long; exports.MaxKey = MaxKey; exports.MinKey = MinKey; exports.ObjectId = ObjectId; exports.Timestamp = Timestamp; exports.UUID = UUID; exports.calculateObjectSize = calculateObjectSize; exports.deserialize = deserialize; exports.deserializeStream = deserializeStream; exports.serialize = serialize; exports.serializeWithBufferAndIndex = serializeWithBufferAndIndex; exports.setInternalBufferSize = setInternalBufferSize;  return exports;  })({}); //# sourceMappingURL=bson.bundle.js.map</script>
  </head>
  <body>
    <div id="pseudo-body">
      <header>
        <div id="title">
          <a href="https://zoo.dev"><img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjQ2IiBoZWlnaHQ9IjcwIiB2aWV3Qm94PSIwIDAgMjQ2IDcwIiBmaWxsPSJub25lIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciPgo8cGF0aCBkPSJNNjAuODIgMjAuMzdDNjAuMjg2NyAyMC40OSA1OS43NCAyMC41NyA1OS4xOCAyMC42MUM1OC42MzMzIDIwLjY2MzMgNTguMDkzMyAyMC42OSA1Ny41NiAyMC42OUM1Ny4wNCAyMC42OSA1Ni42MzMzIDIwLjY3NjcgNTYuMzQgMjAuNjVDNTYuMDYgMjAuNjIzMyA1NS42ODY3IDIwLjU1NjcgNTUuMjIgMjAuNDVDNTQuNzUzMyAyMC4zNDMzIDU0LjMyNjcgMjAuMTk2NyA1My45NCAyMC4wMUM1My41NTMzIDE5LjgyMzMgNTMuMTQgMTkuNTUgNTIuNyAxOS4xOUM1Mi4yNzMzIDE4LjgzIDUxLjkxMzMgMTguNDAzMyA1MS42MiAxNy45MUM1MC45NCAxNi43NjMzIDUwLjYgMTUuMjgzMyA1MC42IDEzLjQ3QzUwLjYgMTIuMjU2NyA1MC43ODY3IDExLjE4MzMgNTEuMTYgMTAuMjVDNTEuNTQ2NyA5LjMxNjY4IDUyLjAwNjcgOC41OTY2OCA1Mi41NCA4LjA5MDAxQzUzLjA4NjcgNy41ODMzNCA1My43MDY3IDcuMTc2NjggNTQuNCA2Ljg3MDAxQzU1LjUyIDYuMzYzMzQgNTYuNjQ2NyA2LjExMDAxIDU3Ljc4IDYuMTEwMDFDNTkuNDA2NyA2LjExMDAxIDYwLjU3MzMgNi4yNDMzNCA2MS4yOCA2LjUxMDAxQzYxLjYgNi42MzAwMSA2MS44ODY3IDYuODE2NjggNjIuMTQgNy4wNzAwMUM2Mi4zOTMzIDcuMzIzMzQgNjIuNTIgNy42OTAwMSA2Mi41MiA4LjE3MDAxQzYyLjUyIDguNjUwMDEgNjIuNCA5LjI1NjY4IDYyLjE2IDkuOTkwMDFDNjEuOTMzMyAxMC43MjMzIDYxLjYgMTEuMDkgNjEuMTYgMTEuMDlDNjEuMDI2NyAxMS4wOSA2MC41MzMzIDEwLjk4MzMgNTkuNjggMTAuNzdDNTguODI2NyAxMC41NTY3IDU4LjI0NjcgMTAuNDUgNTcuOTQgMTAuNDVDNTcuNDczMyAxMC40NSA1Ny4wNzMzIDEwLjcxIDU2Ljc0IDExLjIzQzU2LjQyIDExLjc1IDU2LjI2IDEyLjQ5IDU2LjI2IDEzLjQ1QzU2LjI2IDE0LjQxIDU2LjQgMTUuMTU2NyA1Ni42OCAxNS42OUM1Ni45NzMzIDE2LjIyMzMgNTcuMzUzMyAxNi40OSA1Ny44MiAxNi40OUM1OC4xNTMzIDE2LjQ5IDU4Ljc1MzMgMTYuMzU2NyA1OS42MiAxNi4wOUM2MC41IDE1LjgxIDYxLjAxMzMgMTUuNjcgNjEuMTYgMTUuNjdDNjEuNTczMyAxNS42NyA2MS44OTMzIDE2LjA1IDYyLjEyIDE2LjgxQzYyLjM2IDE3LjU3IDYyLjQ4IDE4LjE4MzMgNjIuNDggMTguNjVDNjIuNDggMTkuMTE2NyA2Mi4zMzMzIDE5LjQ5IDYyLjA0IDE5Ljc3QzYxLjc2IDIwLjAzNjcgNjEuMzUzMyAyMC4yMzY3IDYwLjgyIDIwLjM3Wk02OS45ODUgMjAuNjlDNjguOTg1IDIwLjY5IDY4LjEyNSAyMC42MDMzIDY3LjQwNSAyMC40M0M2Ni42ODUgMjAuMjU2NyA2Ni4wMzE3IDE5Ljk1IDY1LjQ0NSAxOS41MUM2NC4yMzE3IDE4LjYzIDYzLjYyNSAxNi45OSA2My42MjUgMTQuNTlDNjMuNjI1IDEyLjQ1NjcgNjQuMjQ1IDEwLjkzIDY1LjQ4NSAxMC4wMUM2Ni42NDUgOS4xNTY2OCA2OC4xNDUgOC43MzAwMSA2OS45ODUgOC43MzAwMUM3MC43NzE3IDguNzMwMDEgNzEuNDQ1IDguNzcwMDEgNzIuMDA1IDguODUwMDFDNzIuNTY1IDguOTE2NjggNzMuMTMxNyA5LjA3MDAxIDczLjcwNSA5LjMxMDAxQzc0LjI5MTcgOS41NTAwMSA3NC43NTgzIDkuODc2NjggNzUuMTA1IDEwLjI5Qzc1LjQ2NSAxMC43MDMzIDc1Ljc1ODMgMTEuMjc2NyA3NS45ODUgMTIuMDFDNzYuMjExNyAxMi43MyA3Ni4zMjUgMTMuNTkgNzYuMzI1IDE0LjU5Qzc2LjMyNSAxNi42MTY3IDc1Ljc1MTcgMTguMTQzMyA3NC42MDUgMTkuMTdDNzMuNDU4MyAyMC4xODMzIDcxLjkxODMgMjAuNjkgNjkuOTg1IDIwLjY5Wk02OS4yODUgMTYuNzlDNjkuMzc4MyAxNy4yNyA2OS40NzE3IDE3LjU1NjcgNjkuNTY1IDE3LjY1QzY5LjY3MTcgMTcuNzQzMyA2OS44MDUgMTcuNzkgNjkuOTY1IDE3Ljc5QzcwLjEzODMgMTcuNzkgNzAuMjcxNyAxNy43NDMzIDcwLjM2NSAxNy42NUM3MC40NzE3IDE3LjU1NjcgNzAuNTY1IDE3LjI3IDcwLjY0NSAxNi43OUM3MC43MzgzIDE2LjMxIDcwLjc4NSAxNS43MSA3MC43ODUgMTQuOTlDNzAuNzg1IDE0LjI1NjcgNzAuNzY1IDEzLjY5NjcgNzAuNzI1IDEzLjMxQzcwLjY5ODMgMTIuOTEgNzAuNjU4MyAxMi42MDMzIDcwLjYwNSAxMi4zOUM3MC41NjUgMTIuMTc2NyA3MC41MDUgMTIuMDEgNzAuNDI1IDExLjg5QzcwLjMwNSAxMS43MTY3IDcwLjE1ODMgMTEuNjMgNjkuOTg1IDExLjYzQzY5LjgyNSAxMS42MyA2OS42OTE3IDExLjY4MzMgNjkuNTg1IDExLjc5QzY5LjQ3ODMgMTEuODgzMyA2OS4zNzgzIDEyLjE3NjcgNjkuMjg1IDEyLjY3QzY5LjE5MTcgMTMuMTUgNjkuMTQ1IDEzLjgzNjcgNjkuMTQ1IDE0LjczQzY5LjE0NSAxNS42MjMzIDY5LjE5MTcgMTYuMzEgNjkuMjg1IDE2Ljc5Wk04My42NzY0IDIwLjY5QzgyLjY3NjQgMjAuNjkgODEuODE2NCAyMC42MDMzIDgxLjA5NjQgMjAuNDNDODAuMzc2NCAyMC4yNTY3IDc5LjcyMzEgMTkuOTUgNzkuMTM2NCAxOS41MUM3Ny45MjMxIDE4LjYzIDc3LjMxNjQgMTYuOTkgNzcuMzE2NCAxNC41OUM3Ny4zMTY0IDEyLjQ1NjcgNzcuOTM2NCAxMC45MyA3OS4xNzY0IDEwLjAxQzgwLjMzNjQgOS4xNTY2OCA4MS44MzY0IDguNzMwMDEgODMuNjc2NCA4LjczMDAxQzg0LjQ2MzEgOC43MzAwMSA4NS4xMzY0IDguNzcwMDEgODUuNjk2NCA4Ljg1MDAxQzg2LjI1NjQgOC45MTY2OCA4Ni44MjMxIDkuMDcwMDEgODcuMzk2NCA5LjMxMDAxQzg3Ljk4MzEgOS41NTAwMSA4OC40NDk3IDkuODc2NjggODguNzk2NCAxMC4yOUM4OS4xNTY0IDEwLjcwMzMgODkuNDQ5NyAxMS4yNzY3IDg5LjY3NjQgMTIuMDFDODkuOTAzMSAxMi43MyA5MC4wMTY0IDEzLjU5IDkwLjAxNjQgMTQuNTlDOTAuMDE2NCAxNi42MTY3IDg5LjQ0MzEgMTguMTQzMyA4OC4yOTY0IDE5LjE3Qzg3LjE0OTcgMjAuMTgzMyA4NS42MDk3IDIwLjY5IDgzLjY3NjQgMjAuNjlaTTgyLjk3NjQgMTYuNzlDODMuMDY5NyAxNy4yNyA4My4xNjMxIDE3LjU1NjcgODMuMjU2NCAxNy42NUM4My4zNjMxIDE3Ljc0MzMgODMuNDk2NCAxNy43OSA4My42NTY0IDE3Ljc5QzgzLjgyOTcgMTcuNzkgODMuOTYzMSAxNy43NDMzIDg0LjA1NjQgMTcuNjVDODQuMTYzMSAxNy41NTY3IDg0LjI1NjQgMTcuMjcgODQuMzM2NCAxNi43OUM4NC40Mjk3IDE2LjMxIDg0LjQ3NjQgMTUuNzEgODQuNDc2NCAxNC45OUM4NC40NzY0IDE0LjI1NjcgODQuNDU2NCAxMy42OTY3IDg0LjQxNjQgMTMuMzFDODQuMzg5NyAxMi45MSA4NC4zNDk3IDEyLjYwMzMgODQuMjk2NCAxMi4zOUM4NC4yNTY0IDEyLjE3NjcgODQuMTk2NCAxMi4wMSA4NC4xMTY0IDExLjg5QzgzLjk5NjQgMTEuNzE2NyA4My44NDk3IDExLjYzIDgzLjY3NjQgMTEuNjNDODMuNTE2NCAxMS42MyA4My4zODMxIDExLjY4MzMgODMuMjc2NCAxMS43OUM4My4xNjk3IDExLjg4MzMgODMuMDY5NyAxMi4xNzY3IDgyLjk3NjQgMTIuNjdDODIuODgzMSAxMy4xNSA4Mi44MzY0IDEzLjgzNjcgODIuODM2NCAxNC43M0M4Mi44MzY0IDE1LjYyMzMgODIuODgzMSAxNi4zMSA4Mi45NzY0IDE2Ljc5Wk05Ni42MDc4IDIwLjAzQzk2LjYwNzggMjAuMTc2NyA5Ni4yMzQ1IDIwLjI5NjcgOTUuNDg3OCAyMC4zOUM5NC43NDExIDIwLjQ3IDkzLjk2MTEgMjAuNTEgOTMuMTQ3OCAyMC41MUM5Mi4zMzQ1IDIwLjUxIDkxLjgwNzggMjAuNDc2NyA5MS41Njc4IDIwLjQxQzkxLjMyNzggMjAuMzMgOTEuMjA3OCAyMC4yMDMzIDkxLjIwNzggMjAuMDNWNi4xOTAwMUM5MS4yMDc4IDUuODk2NjggOTEuNTgxMSA1LjYxMDAxIDkyLjMyNzggNS4zMzAwMUM5My4wODc4IDUuMDUwMDEgOTMuOTAxMSA0LjkxMDAxIDk0Ljc2NzggNC45MTAwMUM5NS45OTQ1IDQuOTEwMDEgOTYuNjA3OCA1LjIxNjY4IDk2LjYwNzggNS44MzAwMVYxMy4zMUg5Ni44Njc4Qzk3LjUwNzggMTAuMjU2NyA5Ny45ODExIDguNzMwMDEgOTguMjg3OCA4LjczMDAxQzk5LjA2MTEgOC43MzAwMSA5OS45OTQ1IDguOTEwMDEgMTAxLjA4OCA5LjI3MDAxQzEwMi4xODEgOS42MzAwMSAxMDIuNzI4IDEwLjAzIDEwMi43MjggMTAuNDdDMTAyLjcyOCAxMC43OSAxMDIuNDYxIDExLjQwMzMgMTAxLjkyOCAxMi4zMUMxMDEuMzk0IDEzLjIxNjcgMTAwLjg0MSAxMy45NTY3IDEwMC4yNjggMTQuNTNDMTAyLjE3NCAxNi44MSAxMDMuMTI4IDE4LjE2MzMgMTAzLjEyOCAxOC41OUMxMDMuMTI4IDE4Ljk5IDEwMi41MjEgMTkuNDc2NyAxMDEuMzA4IDIwLjA1QzEwMC4wOTQgMjAuNjIzMyA5OS4yNDExIDIwLjkxIDk4Ljc0NzggMjAuOTFDOTguNTA3OCAyMC45MSA5OC4yNTQ1IDIwLjYyMzMgOTcuOTg3OCAyMC4wNUM5Ny43MjExIDE5LjQ2MzMgOTcuNDM0NSAxOC41OSA5Ny4xMjc4IDE3LjQzTDk2LjYwNzggMTguMDVWMjAuMDNaTTEwOS40MjMgMTAuMTdWMjAuMDNDMTA5LjQyMyAyMC4xNzY3IDEwOS4wMzYgMjAuMjk2NyAxMDguMjYzIDIwLjM5QzEwNy41MDMgMjAuNDcgMTA2LjcxNiAyMC41MSAxMDUuOTAzIDIwLjUxQzEwNS4xMDMgMjAuNTEgMTA0LjU4MyAyMC40NzY3IDEwNC4zNDMgMjAuNDFDMTA0LjExNiAyMC4zMyAxMDQuMDAzIDIwLjIwMzMgMTA0LjAwMyAyMC4wM1YxMC41M0MxMDQuMDAzIDEwLjIzNjcgMTA0LjM3NiA5Ljk1MDAxIDEwNS4xMjMgOS42NzAwMUMxMDUuODgzIDkuMzc2NjggMTA2LjcwOSA5LjIzMDAxIDEwNy42MDMgOS4yMzAwMUMxMDguODE2IDkuMjMwMDEgMTA5LjQyMyA5LjU0MzM0IDEwOS40MjMgMTAuMTdaTTEwNi43MDMgNC45MTAwMUMxMDcuNTgzIDQuOTEwMDEgMTA4LjI2OSA1LjA0MzM0IDEwOC43NjMgNS4zMTAwMUMxMDkuMjY5IDUuNTYzMzQgMTA5LjUyMyA2LjAzMDAxIDEwOS41MjMgNi43MTAwMUMxMDkuNTIzIDcuOTEwMDEgMTA4LjU4OSA4LjUxMDAxIDEwNi43MjMgOC41MTAwMUMxMDQuODU2IDguNTEwMDEgMTAzLjkyMyA3LjkxMDAxIDEwMy45MjMgNi43MTAwMUMxMDMuOTIzIDUuNTEwMDEgMTA0Ljg0OSA0LjkxMDAxIDEwNi43MDMgNC45MTAwMVpNMTE2LjE3NSAxNS45OUMxMTYuMTc1IDE2Ljg1NjcgMTE2LjU4OCAxNy4yOSAxMTcuNDE1IDE3LjI5QzExNy44OTUgMTcuMjkgMTE4LjUyMiAxNy4xMyAxMTkuMjk1IDE2LjgxQzEyMC4wNjggMTYuNDc2NyAxMjAuNDc1IDE2LjMxIDEyMC41MTUgMTYuMzFDMTIwLjc2OCAxNi4zMSAxMjEuMTAyIDE2LjY5IDEyMS41MTUgMTcuNDVDMTIxLjkyOCAxOC4yMSAxMjIuMTM1IDE4Ljc3IDEyMi4xMzUgMTkuMTNDMTIyLjEzNSAxOS42NSAxMjEuNjAyIDIwLjA0MzMgMTIwLjUzNSAyMC4zMUMxMTkuNDY4IDIwLjU3NjcgMTE4LjQyMiAyMC43MSAxMTcuMzk1IDIwLjcxQzExNi4zODIgMjAuNzEgMTE1LjUyOCAyMC42MyAxMTQuODM1IDIwLjQ3QzExNC4xNTUgMjAuMzEgMTEzLjU5NSAyMC4xMSAxMTMuMTU1IDE5Ljg3QzExMi43MjggMTkuNjE2NyAxMTIuMzQ4IDE5LjMxIDExMi4wMTUgMTguOTVDMTExLjY5NSAxOC41OSAxMTEuNDU1IDE4LjI1IDExMS4yOTUgMTcuOTNDMTExLjEzNSAxNy41OTY3IDExMS4wMDggMTcuMjMgMTEwLjkxNSAxNi44M0MxMTAuNzgyIDE2LjI0MzMgMTEwLjcxNSAxNS42MzY3IDExMC43MTUgMTUuMDFDMTEwLjcxNSAxMi41ODMzIDExMS4zNDggMTAuOTEgMTEyLjYxNSA5Ljk5MDAxQzExMy4yNDIgOS41MjMzNCAxMTMuOTQyIDkuMTk2NjggMTE0LjcxNSA5LjAxMDAxQzExNS40ODggOC44MjMzNCAxMTYuNDAyIDguNzMwMDEgMTE3LjQ1NSA4LjczMDAxQzEyMC44MjggOC43MzAwMSAxMjIuNTE1IDkuOTAzMzQgMTIyLjUxNSAxMi4yNUMxMjIuNTE1IDE0Ljc0MzMgMTIwLjYyMiAxNS45OSAxMTYuODM1IDE1Ljk5SDExNi4xNzVaTTExNi4xMzUgMTMuMDdWMTQuMzlDMTE2LjUyMiAxNC4zOSAxMTYuODM1IDE0LjIzNjcgMTE3LjA3NSAxMy45M0MxMTcuMzI4IDEzLjYyMzMgMTE3LjQ1NSAxMy4yNSAxMTcuNDU1IDEyLjgxQzExNy40NTUgMTIuMDEgMTE3LjI0OCAxMS42MSAxMTYuODM1IDExLjYxQzExNi4zNjggMTEuNjEgMTE2LjEzNSAxMi4wOTY3IDExNi4xMzUgMTMuMDdaTTEzOC4zMiAyMC4zN0MxMzcuNzg3IDIwLjQ5IDEzNy4yNCAyMC41NyAxMzYuNjggMjAuNjFDMTM2LjEzMyAyMC42NjMzIDEzNS41OTMgMjAuNjkgMTM1LjA2IDIwLjY5QzEzNC41NCAyMC42OSAxMzQuMTMzIDIwLjY3NjcgMTMzLjg0IDIwLjY1QzEzMy41NiAyMC42MjMzIDEzMy4xODcgMjAuNTU2NyAxMzIuNzIgMjAuNDVDMTMyLjI1MyAyMC4zNDMzIDEzMS44MjcgMjAuMTk2NyAxMzEuNDQgMjAuMDFDMTMxLjA1MyAxOS44MjMzIDEzMC42NCAxOS41NSAxMzAuMiAxOS4xOUMxMjkuNzczIDE4LjgzIDEyOS40MTMgMTguNDAzMyAxMjkuMTIgMTcuOTFDMTI4LjQ0IDE2Ljc2MzMgMTI4LjEgMTUuMjgzMyAxMjguMSAxMy40N0MxMjguMSAxMi4yNTY3IDEyOC4yODcgMTEuMTgzMyAxMjguNjYgMTAuMjVDMTI5LjA0NyA5LjMxNjY4IDEyOS41MDcgOC41OTY2OCAxMzAuMDQgOC4wOTAwMUMxMzAuNTg3IDcuNTgzMzQgMTMxLjIwNyA3LjE3NjY4IDEzMS45IDYuODcwMDFDMTMzLjAyIDYuMzYzMzQgMTM0LjE0NyA2LjExMDAxIDEzNS4yOCA2LjExMDAxQzEzNi45MDcgNi4xMTAwMSAxMzguMDczIDYuMjQzMzQgMTM4Ljc4IDYuNTEwMDFDMTM5LjEgNi42MzAwMSAxMzkuMzg3IDYuODE2NjggMTM5LjY0IDcuMDcwMDFDMTM5Ljg5MyA3LjMyMzM0IDE0MC4wMiA3LjY5MDAxIDE0MC4wMiA4LjE3MDAxQzE0MC4wMiA4LjY1MDAxIDEzOS45IDkuMjU2NjggMTM5LjY2IDkuOTkwMDFDMTM5LjQzMyAxMC43MjMzIDEzOS4xIDExLjA5IDEzOC42NiAxMS4wOUMxMzguNTI3IDExLjA5IDEzOC4wMzMgMTAuOTgzMyAxMzcuMTggMTAuNzdDMTM2LjMyNyAxMC41NTY3IDEzNS43NDcgMTAuNDUgMTM1LjQ0IDEwLjQ1QzEzNC45NzMgMTAuNDUgMTM0LjU3MyAxMC43MSAxMzQuMjQgMTEuMjNDMTMzLjkyIDExLjc1IDEzMy43NiAxMi40OSAxMzMuNzYgMTMuNDVDMTMzLjc2IDE0LjQxIDEzMy45IDE1LjE1NjcgMTM0LjE4IDE1LjY5QzEzNC40NzMgMTYuMjIzMyAxMzQuODUzIDE2LjQ5IDEzNS4zMiAxNi40OUMxMzUuNjUzIDE2LjQ5IDEzNi4yNTMgMTYuMzU2NyAxMzcuMTIgMTYuMDlDMTM4IDE1LjgxIDEzOC41MTMgMTUuNjcgMTM4LjY2IDE1LjY3QzEzOS4wNzMgMTUuNjcgMTM5LjM5MyAxNi4wNSAxMzkuNjIgMTYuODFDMTM5Ljg2IDE3LjU3IDEzOS45OCAxOC4xODMzIDEzOS45OCAxOC42NUMxMzkuOTggMTkuMTE2NyAxMzkuODMzIDE5LjQ5IDEzOS41NCAxOS43N0MxMzkuMjYgMjAuMDM2NyAxMzguODUzIDIwLjIzNjcgMTM4LjMyIDIwLjM3Wk0xNDUuMzQ1IDIwLjY5QzE0My44NTIgMjAuNjkgMTQyLjgwNSAyMC4zMDMzIDE0Mi4yMDUgMTkuNTNDMTQxLjYxOCAxOC43NTY3IDE0MS4zMjUgMTcuNDEgMTQxLjMyNSAxNS40OVYxMC4wNUMxNDEuMzI1IDkuNzgzMzQgMTQxLjcxOCA5LjUzMDAxIDE0Mi41MDUgOS4yOTAwMUMxNDMuMjkyIDkuMDM2NjggMTQ0LjExOCA4LjkxMDAxIDE0NC45ODUgOC45MTAwMUMxNDYuMTQ1IDguOTEwMDEgMTQ2LjcyNSA5LjIxMDAxIDE0Ni43MjUgOS44MTAwMVYxNC44OUMxNDYuNzI1IDE1LjkwMzMgMTQ2Ljc2NSAxNi42NDMzIDE0Ni44NDUgMTcuMTFDMTQ2LjkyNSAxNy41NjMzIDE0Ny4xMjUgMTcuNzkgMTQ3LjQ0NSAxNy43OUMxNDcuODcyIDE3Ljc5IDE0OC4wODUgMTcuNjEgMTQ4LjA4NSAxNy4yNVYxMC4wNUMxNDguMDg1IDkuNzcwMDEgMTQ4LjQ5OCA5LjUxMDAxIDE0OS4zMjUgOS4yNzAwMUMxNTAuMTUyIDkuMDMwMDEgMTUxLjA1MiA4LjkxMDAxIDE1Mi4wMjUgOC45MTAwMUMxNTIuOTk4IDguOTEwMDEgMTUzLjQ4NSA5LjE3MDAxIDE1My40ODUgOS42OTAwMVYxOS45OUMxNTMuNDg1IDIwLjE3NjcgMTUzLjA2NSAyMC4zMSAxNTIuMjI1IDIwLjM5QzE1MS4zODUgMjAuNDcgMTUwLjU1OCAyMC41MSAxNDkuNzQ1IDIwLjUxQzE0OC45MzIgMjAuNTEgMTQ4LjUxOCAyMC40MDMzIDE0OC41MDUgMjAuMTlMMTQ4LjMwNSAxOC44OUgxNDguMTQ1QzE0OC4wMjUgMTkuMzcgMTQ3Ljc4NSAxOS43NjMzIDE0Ny40MjUgMjAuMDdDMTQ3LjIzOCAyMC4yMyAxNDYuOTU4IDIwLjM3NjcgMTQ2LjU4NSAyMC41MUMxNDYuMjI1IDIwLjYzIDE0NS44MTIgMjAuNjkgMTQ1LjM0NSAyMC42OVpNMTYyLjc0IDIwLjMzQzE2Mi41IDIwLjU1NjcgMTYxLjk1MyAyMC42NyAxNjEuMSAyMC42N0MxNjAuMjQ2IDIwLjY3IDE1OS41NCAyMC42MTY3IDE1OC45OCAyMC41MUMxNTguNDIgMjAuMzkgMTU3Ljg4NiAyMC4xNjMzIDE1Ny4zOCAxOS44M0MxNTYuNDA2IDE5LjE3NjcgMTU1LjkyIDE3LjgxNjcgMTU1LjkyIDE1Ljc1VjEyLjYzSDE1NC45MkMxNTQuNzczIDEyLjYzIDE1NC42NDYgMTIuNDc2NyAxNTQuNTQgMTIuMTdDMTU0LjQzMyAxMS44NjMzIDE1NC4zOCAxMS40NDMzIDE1NC4zOCAxMC45MUMxNTQuMzggMTAuMzc2NyAxNTQuNDYgOS45MTAwMSAxNTQuNjIgOS41MTAwMUMxNTQuNzkzIDkuMDk2NjggMTU1LjAxMyA4Ljg5MDAxIDE1NS4yOCA4Ljg5MDAxSDE1NS45MlY2LjQ3MDAxQzE1NS45MiA2LjA1NjY4IDE1Ni4zMiA1LjcyMzM0IDE1Ny4xMiA1LjQ3MDAxQzE1Ny45MzMgNS4yMTY2OCAxNTguNzI2IDUuMDkwMDEgMTU5LjUgNS4wOTAwMUMxNjAuNzEzIDUuMDkwMDEgMTYxLjMyIDUuMzkwMDEgMTYxLjMyIDUuOTkwMDFWOC44OTAwMUgxNjIuOEMxNjMuMTQ2IDguODkwMDEgMTYzLjMyIDkuMzkwMDEgMTYzLjMyIDEwLjM5QzE2My4zMiAxMS4wNDMzIDE2My4yNCAxMS41ODMzIDE2My4wOCAxMi4wMUMxNjIuOTMzIDEyLjQyMzMgMTYyLjc0IDEyLjYzIDE2Mi41IDEyLjYzSDE2MS4zMlYxNi4yOUMxNjEuMzIgMTYuNjUgMTYxLjQ3MyAxNi45MSAxNjEuNzggMTcuMDdDMTYyLjA4NiAxNy4yMTY3IDE2Mi4zNTMgMTcuMjkgMTYyLjU4IDE3LjI5QzE2Mi44MiAxNy4yOSAxNjIuOTY2IDE3LjQwMzMgMTYzLjAyIDE3LjYzQzE2My4wNzMgMTcuODU2NyAxNjMuMSAxOC4xOTY3IDE2My4xIDE4LjY1QzE2My4xIDE5LjU0MzMgMTYyLjk4IDIwLjEwMzMgMTYyLjc0IDIwLjMzWk0xNzIuMzg4IDIwLjMzQzE3Mi4xNDggMjAuNTU2NyAxNzEuNjAxIDIwLjY3IDE3MC43NDggMjAuNjdDMTY5Ljg5NSAyMC42NyAxNjkuMTg4IDIwLjYxNjcgMTY4LjYyOCAyMC41MUMxNjguMDY4IDIwLjM5IDE2Ny41MzUgMjAuMTYzMyAxNjcuMDI4IDE5LjgzQzE2Ni4wNTUgMTkuMTc2NyAxNjUuNTY4IDE3LjgxNjcgMTY1LjU2OCAxNS43NVYxMi42M0gxNjQuNTY4QzE2NC40MjEgMTIuNjMgMTY0LjI5NSAxMi40NzY3IDE2NC4xODggMTIuMTdDMTY0LjA4MSAxMS44NjMzIDE2NC4wMjggMTEuNDQzMyAxNjQuMDI4IDEwLjkxQzE2NC4wMjggMTAuMzc2NyAxNjQuMTA4IDkuOTEwMDEgMTY0LjI2OCA5LjUxMDAxQzE2NC40NDEgOS4wOTY2OCAxNjQuNjYxIDguODkwMDEgMTY0LjkyOCA4Ljg5MDAxSDE2NS41NjhWNi40NzAwMUMxNjUuNTY4IDYuMDU2NjggMTY1Ljk2OCA1LjcyMzM0IDE2Ni43NjggNS40NzAwMUMxNjcuNTgxIDUuMjE2NjggMTY4LjM3NSA1LjA5MDAxIDE2OS4xNDggNS4wOTAwMUMxNzAuMzYxIDUuMDkwMDEgMTcwLjk2OCA1LjM5MDAxIDE3MC45NjggNS45OTAwMVY4Ljg5MDAxSDE3Mi40NDhDMTcyLjc5NSA4Ljg5MDAxIDE3Mi45NjggOS4zOTAwMSAxNzIuOTY4IDEwLjM5QzE3Mi45NjggMTEuMDQzMyAxNzIuODg4IDExLjU4MzMgMTcyLjcyOCAxMi4wMUMxNzIuNTgxIDEyLjQyMzMgMTcyLjM4OCAxMi42MyAxNzIuMTQ4IDEyLjYzSDE3MC45NjhWMTYuMjlDMTcwLjk2OCAxNi42NSAxNzEuMTIxIDE2LjkxIDE3MS40MjggMTcuMDdDMTcxLjczNSAxNy4yMTY3IDE3Mi4wMDEgMTcuMjkgMTcyLjIyOCAxNy4yOUMxNzIuNDY4IDE3LjI5IDE3Mi42MTUgMTcuNDAzMyAxNzIuNjY4IDE3LjYzQzE3Mi43MjEgMTcuODU2NyAxNzIuNzQ4IDE4LjE5NjcgMTcyLjc0OCAxOC42NUMxNzIuNzQ4IDE5LjU0MzMgMTcyLjYyOCAyMC4xMDMzIDE3Mi4zODggMjAuMzNaTTE3OS40MzcgMTUuOTlDMTc5LjQzNyAxNi44NTY3IDE3OS44NSAxNy4yOSAxODAuNjc3IDE3LjI5QzE4MS4xNTcgMTcuMjkgMTgxLjc4MyAxNy4xMyAxODIuNTU3IDE2LjgxQzE4My4zMyAxNi40NzY3IDE4My43MzcgMTYuMzEgMTgzLjc3NyAxNi4zMUMxODQuMDMgMTYuMzEgMTg0LjM2MyAxNi42OSAxODQuNzc3IDE3LjQ1QzE4NS4xOSAxOC4yMSAxODUuMzk3IDE4Ljc3IDE4NS4zOTcgMTkuMTNDMTg1LjM5NyAxOS42NSAxODQuODYzIDIwLjA0MzMgMTgzLjc5NyAyMC4zMUMxODIuNzMgMjAuNTc2NyAxODEuNjgzIDIwLjcxIDE4MC42NTcgMjAuNzFDMTc5LjY0MyAyMC43MSAxNzguNzkgMjAuNjMgMTc4LjA5NyAyMC40N0MxNzcuNDE3IDIwLjMxIDE3Ni44NTcgMjAuMTEgMTc2LjQxNyAxOS44N0MxNzUuOTkgMTkuNjE2NyAxNzUuNjEgMTkuMzEgMTc1LjI3NyAxOC45NUMxNzQuOTU3IDE4LjU5IDE3NC43MTcgMTguMjUgMTc0LjU1NyAxNy45M0MxNzQuMzk3IDE3LjU5NjcgMTc0LjI3IDE3LjIzIDE3NC4xNzcgMTYuODNDMTc0LjA0MyAxNi4yNDMzIDE3My45NzcgMTUuNjM2NyAxNzMuOTc3IDE1LjAxQzE3My45NzcgMTIuNTgzMyAxNzQuNjEgMTAuOTEgMTc1Ljg3NyA5Ljk5MDAxQzE3Ni41MDMgOS41MjMzNCAxNzcuMjAzIDkuMTk2NjggMTc3Ljk3NyA5LjAxMDAxQzE3OC43NSA4LjgyMzM0IDE3OS42NjMgOC43MzAwMSAxODAuNzE3IDguNzMwMDFDMTg0LjA5IDguNzMwMDEgMTg1Ljc3NyA5LjkwMzM0IDE4NS43NzcgMTIuMjVDMTg1Ljc3NyAxNC43NDMzIDE4My44ODMgMTUuOTkgMTgwLjA5NyAxNS45OUgxNzkuNDM3Wk0xNzkuMzk3IDEzLjA3VjE0LjM5QzE3OS43ODMgMTQuMzkgMTgwLjA5NyAxNC4yMzY3IDE4MC4zMzcgMTMuOTNDMTgwLjU5IDEzLjYyMzMgMTgwLjcxNyAxMy4yNSAxODAuNzE3IDEyLjgxQzE4MC43MTcgMTIuMDEgMTgwLjUxIDExLjYxIDE4MC4wOTcgMTEuNjFDMTc5LjYzIDExLjYxIDE3OS4zOTcgMTIuMDk2NyAxNzkuMzk3IDEzLjA3Wk0xOTIuMzcgMTQuMTlWMjAuMDNDMTkyLjM3IDIwLjE3NjcgMTkxLjk5IDIwLjI5NjcgMTkxLjIzIDIwLjM5QzE5MC40ODMgMjAuNDcgMTg5LjcwMyAyMC41MSAxODguODkgMjAuNTFDMTg4LjA5IDIwLjUxIDE4Ny41NyAyMC40NzY3IDE4Ny4zMyAyMC40MUMxODcuMDkgMjAuMzMgMTg2Ljk3IDIwLjIwMzMgMTg2Ljk3IDIwLjAzVjEwLjE3QzE4Ni45NyA5LjkxNjY4IDE4Ny4zMzYgOS42NDMzNCAxODguMDcgOS4zNTAwMUMxODguODE2IDkuMDU2NjggMTg5LjYyMyA4LjkxMDAxIDE5MC40OSA4LjkxMDAxQzE5MS4zNyA4LjkxMDAxIDE5MS44NjMgOS4xNTAwMSAxOTEuOTcgOS42MzAwMUwxOTIuMTcgMTAuNTVIMTkyLjMxQzE5Mi40OTYgMTAuMDQzMyAxOTIuOTQzIDkuNjE2NjggMTkzLjY1IDkuMjcwMDFDMTk0LjM1NiA4LjkxMDAxIDE5NS4wNjMgOC43MzAwMSAxOTUuNzcgOC43MzAwMUMxOTYuNDc2IDguNzMwMDEgMTk2Ljk3IDguODQzMzQgMTk3LjI1IDkuMDcwMDFDMTk3LjU0MyA5LjI5NjY4IDE5Ny42OSA5LjU5MDAxIDE5Ny42OSA5Ljk1MDAxQzE5Ny42OSAxMC4yOTY3IDE5Ny42NjMgMTAuNzQzMyAxOTcuNjEgMTEuMjlDMTk3LjU1NiAxMS44MzY3IDE5Ny40MjMgMTIuNDMgMTk3LjIxIDEzLjA3QzE5Ny4wMSAxMy43MSAxOTYuNzQzIDE0LjAzIDE5Ni40MSAxNC4wM0MxOTYuMjc2IDE0LjAzIDE5NS44NTYgMTMuOTMgMTk1LjE1IDEzLjczQzE5NC40NDMgMTMuNTMgMTkzLjg1NiAxMy40MyAxOTMuMzkgMTMuNDNDMTkyLjkzNiAxMy40MyAxOTIuNjUgMTMuNDk2NyAxOTIuNTMgMTMuNjNDMTkyLjQyMyAxMy43NjMzIDE5Mi4zNyAxMy45NSAxOTIuMzcgMTQuMTlaTTYwLjgyIDQzLjM3QzYwLjI4NjcgNDMuNDkgNTkuNzQgNDMuNTcgNTkuMTggNDMuNjFDNTguNjMzMyA0My42NjMzIDU4LjA5MzMgNDMuNjkgNTcuNTYgNDMuNjlDNTcuMDQgNDMuNjkgNTYuNjMzMyA0My42NzY3IDU2LjM0IDQzLjY1QzU2LjA2IDQzLjYyMzMgNTUuNjg2NyA0My41NTY3IDU1LjIyIDQzLjQ1QzU0Ljc1MzMgNDMuMzQzMyA1NC4zMjY3IDQzLjE5NjcgNTMuOTQgNDMuMDFDNTMuNTUzMyA0Mi44MjMzIDUzLjE0IDQyLjU1IDUyLjcgNDIuMTlDNTIuMjczMyA0MS44MyA1MS45MTMzIDQxLjQwMzMgNTEuNjIgNDAuOTFDNTAuOTQgMzkuNzYzMyA1MC42IDM4LjI4MzMgNTAuNiAzNi40N0M1MC42IDM1LjI1NjcgNTAuNzg2NyAzNC4xODMzIDUxLjE2IDMzLjI1QzUxLjU0NjcgMzIuMzE2NyA1Mi4wMDY3IDMxLjU5NjcgNTIuNTQgMzEuMDlDNTMuMDg2NyAzMC41ODMzIDUzLjcwNjcgMzAuMTc2NyA1NC40IDI5Ljg3QzU1LjUyIDI5LjM2MzMgNTYuNjQ2NyAyOS4xMSA1Ny43OCAyOS4xMUM1OS40MDY3IDI5LjExIDYwLjU3MzMgMjkuMjQzMyA2MS4yOCAyOS41MUM2MS42IDI5LjYzIDYxLjg4NjcgMjkuODE2NyA2Mi4xNCAzMC4wN0M2Mi4zOTMzIDMwLjMyMzMgNjIuNTIgMzAuNjkgNjIuNTIgMzEuMTdDNjIuNTIgMzEuNjUgNjIuNCAzMi4yNTY3IDYyLjE2IDMyLjk5QzYxLjkzMzMgMzMuNzIzMyA2MS42IDM0LjA5IDYxLjE2IDM0LjA5QzYxLjAyNjcgMzQuMDkgNjAuNTMzMyAzMy45ODMzIDU5LjY4IDMzLjc3QzU4LjgyNjcgMzMuNTU2NyA1OC4yNDY3IDMzLjQ1IDU3Ljk0IDMzLjQ1QzU3LjQ3MzMgMzMuNDUgNTcuMDczMyAzMy43MSA1Ni43NCAzNC4yM0M1Ni40MiAzNC43NSA1Ni4yNiAzNS40OSA1Ni4yNiAzNi40NUM1Ni4yNiAzNy40MSA1Ni40IDM4LjE1NjcgNTYuNjggMzguNjlDNTYuOTczMyAzOS4yMjMzIDU3LjM1MzMgMzkuNDkgNTcuODIgMzkuNDlDNTguMTUzMyAzOS40OSA1OC43NTMzIDM5LjM1NjcgNTkuNjIgMzkuMDlDNjAuNSAzOC44MSA2MS4wMTMzIDM4LjY3IDYxLjE2IDM4LjY3QzYxLjU3MzMgMzguNjcgNjEuODkzMyAzOS4wNSA2Mi4xMiAzOS44MUM2Mi4zNiA0MC41NyA2Mi40OCA0MS4xODMzIDYyLjQ4IDQxLjY1QzYyLjQ4IDQyLjExNjcgNjIuMzMzMyA0Mi40OSA2Mi4wNCA0Mi43N0M2MS43NiA0My4wMzY3IDYxLjM1MzMgNDMuMjM2NyA2MC44MiA0My4zN1pNNjkuMjI1IDM3LjE5VjQzLjAzQzY5LjIyNSA0My4xNzY3IDY4Ljg0NSA0My4yOTY3IDY4LjA4NSA0My4zOUM2Ny4zMzgzIDQzLjQ3IDY2LjU1ODMgNDMuNTEgNjUuNzQ1IDQzLjUxQzY0Ljk0NSA0My41MSA2NC40MjUgNDMuNDc2NyA2NC4xODUgNDMuNDFDNjMuOTQ1IDQzLjMzIDYzLjgyNSA0My4yMDMzIDYzLjgyNSA0My4wM1YzMy4xN0M2My44MjUgMzIuOTE2NyA2NC4xOTE3IDMyLjY0MzMgNjQuOTI1IDMyLjM1QzY1LjY3MTcgMzIuMDU2NyA2Ni40NzgzIDMxLjkxIDY3LjM0NSAzMS45MUM2OC4yMjUgMzEuOTEgNjguNzE4MyAzMi4xNSA2OC44MjUgMzIuNjNMNjkuMDI1IDMzLjU1SDY5LjE2NUM2OS4zNTE3IDMzLjA0MzMgNjkuNzk4MyAzMi42MTY3IDcwLjUwNSAzMi4yN0M3MS4yMTE3IDMxLjkxIDcxLjkxODMgMzEuNzMgNzIuNjI1IDMxLjczQzczLjMzMTcgMzEuNzMgNzMuODI1IDMxLjg0MzMgNzQuMTA1IDMyLjA3Qzc0LjM5ODMgMzIuMjk2NyA3NC41NDUgMzIuNTkgNzQuNTQ1IDMyLjk1Qzc0LjU0NSAzMy4yOTY3IDc0LjUxODMgMzMuNzQzMyA3NC40NjUgMzQuMjlDNzQuNDExNyAzNC44MzY3IDc0LjI3ODMgMzUuNDMgNzQuMDY1IDM2LjA3QzczLjg2NSAzNi43MSA3My41OTgzIDM3LjAzIDczLjI2NSAzNy4wM0M3My4xMzE3IDM3LjAzIDcyLjcxMTcgMzYuOTMgNzIuMDA1IDM2LjczQzcxLjI5ODMgMzYuNTMgNzAuNzExNyAzNi40MyA3MC4yNDUgMzYuNDNDNjkuNzkxNyAzNi40MyA2OS41MDUgMzYuNDk2NyA2OS4zODUgMzYuNjNDNjkuMjc4MyAzNi43NjMzIDY5LjIyNSAzNi45NSA2OS4yMjUgMzcuMTlaTTgwLjgwMzggMzguOTlDODAuODAzOCAzOS44NTY3IDgxLjIxNzEgNDAuMjkgODIuMDQzOCA0MC4yOUM4Mi41MjM4IDQwLjI5IDgzLjE1MDQgNDAuMTMgODMuOTIzOCAzOS44MUM4NC42OTcxIDM5LjQ3NjcgODUuMTAzOCAzOS4zMSA4NS4xNDM4IDM5LjMxQzg1LjM5NzEgMzkuMzEgODUuNzMwNCAzOS42OSA4Ni4xNDM3IDQwLjQ1Qzg2LjU1NzEgNDEuMjEgODYuNzYzOCA0MS43NyA4Ni43NjM4IDQyLjEzQzg2Ljc2MzggNDIuNjUgODYuMjMwNCA0My4wNDMzIDg1LjE2MzggNDMuMzFDODQuMDk3MSA0My41NzY3IDgzLjA1MDQgNDMuNzEgODIuMDIzOCA0My43MUM4MS4wMTA0IDQzLjcxIDgwLjE1NzEgNDMuNjMgNzkuNDYzOCA0My40N0M3OC43ODM4IDQzLjMxIDc4LjIyMzggNDMuMTEgNzcuNzgzNyA0Mi44N0M3Ny4zNTcxIDQyLjYxNjcgNzYuOTc3MSA0Mi4zMSA3Ni42NDM4IDQxLjk1Qzc2LjMyMzggNDEuNTkgNzYuMDgzOCA0MS4yNSA3NS45MjM4IDQwLjkzQzc1Ljc2MzggNDAuNTk2NyA3NS42MzcxIDQwLjIzIDc1LjU0MzggMzkuODNDNzUuNDEwNCAzOS4yNDMzIDc1LjM0MzggMzguNjM2NyA3NS4zNDM4IDM4LjAxQzc1LjM0MzggMzUuNTgzMyA3NS45NzcxIDMzLjkxIDc3LjI0MzggMzIuOTlDNzcuODcwNCAzMi41MjMzIDc4LjU3MDQgMzIuMTk2NyA3OS4zNDM4IDMyLjAxQzgwLjExNzEgMzEuODIzMyA4MS4wMzA0IDMxLjczIDgyLjA4MzggMzEuNzNDODUuNDU3MSAzMS43MyA4Ny4xNDM4IDMyLjkwMzMgODcuMTQzOCAzNS4yNUM4Ny4xNDM4IDM3Ljc0MzMgODUuMjUwNCAzOC45OSA4MS40NjM4IDM4Ljk5SDgwLjgwMzhaTTgwLjc2MzggMzYuMDdWMzcuMzlDODEuMTUwNCAzNy4zOSA4MS40NjM4IDM3LjIzNjcgODEuNzAzOCAzNi45M0M4MS45NTcxIDM2LjYyMzMgODIuMDgzOCAzNi4yNSA4Mi4wODM4IDM1LjgxQzgyLjA4MzggMzUuMDEgODEuODc3MSAzNC42MSA4MS40NjM4IDM0LjYxQzgwLjk5NzEgMzQuNjEgODAuNzYzOCAzNS4wOTY3IDgwLjc2MzggMzYuMDdaTTkyLjEzNjcgNDMuNjlDOTAuOTIzNCA0My42OSA4OS45NzAxIDQzLjQwMzMgODkuMjc2NyA0Mi44M0M4OC45OTY3IDQyLjU5IDg4Ljc1MDEgNDIuMjM2NyA4OC41MzY3IDQxLjc3Qzg4LjMzNjcgNDEuMzAzMyA4OC4yMzY3IDQwLjc1NjcgODguMjM2NyA0MC4xM0M4OC4yMzY3IDM5LjUwMzMgODguMzgzNCAzOC45NTY3IDg4LjY3NjcgMzguNDlDODguOTgzNCAzOC4wMjMzIDg5LjM1MDEgMzcuNjYzMyA4OS43NzY3IDM3LjQxQzkwLjIwMzQgMzcuMTU2NyA5MC43MDM0IDM2Ljk1IDkxLjI3NjcgMzYuNzlDOTIuMTQzNCAzNi41NjMzIDkzLjA5NjcgMzYuNDUgOTQuMTM2NyAzNi40NUg5NC43OTY3Qzk0Ljc5NjcgMzUuOTAzMyA5NC42MTAxIDM1LjUxNjcgOTQuMjM2NyAzNS4yOUM5NC4wNzY3IDM1LjE5NjcgOTMuODMwMSAzNS4xNSA5My40OTY3IDM1LjE1QzkzLjE3NjcgMzUuMTUgOTIuNzgzNCAzNS4yMzY3IDkyLjMxNjcgMzUuNDFDOTEuODYzNCAzNS41ODMzIDkxLjQ4MzQgMzUuNzYzMyA5MS4xNzY3IDM1Ljk1QzkwLjg3MDEgMzYuMTIzMyA5MC42NjM0IDM2LjIxIDkwLjU1NjcgMzYuMjFDOTAuMzE2NyAzNi4yMSA4OS45OTAxIDM1Ljg5NjcgODkuNTc2NyAzNS4yN0M4OS4xNjM0IDM0LjYzIDg4Ljk1NjcgMzQuMDUgODguOTU2NyAzMy41M0M4OC45NTY3IDMzLjM1NjcgODkuMjAzNCAzMy4xMyA4OS42OTY3IDMyLjg1QzkwLjE5MDEgMzIuNTcgOTAuODgzNCAzMi4zMTY3IDkxLjc3NjcgMzIuMDlDOTIuNjgzNCAzMS44NSA5My41NjM0IDMxLjczIDk0LjQxNjcgMzEuNzNDOTUuMjcwMSAzMS43MyA5Ni4wMDM0IDMxLjgwMzMgOTYuNjE2NyAzMS45NUM5Ny4yNDM0IDMyLjA4MzMgOTcuNzUwMSAzMi4yNSA5OC4xMzY3IDMyLjQ1Qzk4LjUzNjcgMzIuNjUgOTguODcwMSAzMi45MTY3IDk5LjEzNjcgMzMuMjVDOTkuNDE2NyAzMy41ODMzIDk5LjYyMzQgMzMuODgzMyA5OS43NTY3IDM0LjE1Qzk5LjkwMzQgMzQuNDE2NyAxMDAuMDEgMzQuNzYzMyAxMDAuMDc3IDM1LjE5QzEwMC4xNyAzNS42ODMzIDEwMC4yMTcgMzYuMjkgMTAwLjIxNyAzNy4wMVY0My4wM0MxMDAuMjE3IDQzLjE3NjcgOTkuODU2NyA0My4yOTY3IDk5LjEzNjcgNDMuMzlDOTguNDMwMSA0My40NyA5Ny43MjM0IDQzLjUxIDk3LjAxNjcgNDMuNTFDOTYuMzIzNCA0My41MSA5NS44NzAxIDQzLjQ5IDk1LjY1NjcgNDMuNDVDOTUuNDU2NyA0My40MSA5NS4zMzY3IDQzLjM2MzMgOTUuMjk2NyA0My4zMUM5NS4yNTY3IDQzLjI1NjcgOTUuMjIzNCA0My4xNjMzIDk1LjE5NjcgNDMuMDNMOTUuMDM2NyA0MS44OUg5NC44NzY3Qzk0LjU0MzQgNDMuMDkgOTMuNjMwMSA0My42OSA5Mi4xMzY3IDQzLjY5Wk05NC44MTY3IDQwLjM3VjM4LjAzQzk0LjQ3MDEgMzguMDMgOTQuMTkwMSAzOC4xNzY3IDkzLjk3NjcgMzguNDdDOTMuNzYzNCAzOC43NjMzIDkzLjY1NjcgMzkuMDk2NyA5My42NTY3IDM5LjQ3QzkzLjY1NjcgNDAuMzUgOTMuODU2NyA0MC43OSA5NC4yNTY3IDQwLjc5Qzk0LjQzMDEgNDAuNzkgOTQuNTYzNCA0MC43NSA5NC42NTY3IDQwLjY3Qzk0Ljc2MzQgNDAuNTc2NyA5NC44MTY3IDQwLjQ3NjcgOTQuODE2NyA0MC4zN1pNMTA5LjQ3OCA0My4zM0MxMDkuMjM4IDQzLjU1NjcgMTA4LjY5MSA0My42NyAxMDcuODM4IDQzLjY3QzEwNi45ODUgNDMuNjcgMTA2LjI3OCA0My42MTY3IDEwNS43MTggNDMuNTFDMTA1LjE1OCA0My4zOSAxMDQuNjI1IDQzLjE2MzMgMTA0LjExOCA0Mi44M0MxMDMuMTQ1IDQyLjE3NjcgMTAyLjY1OCA0MC44MTY3IDEwMi42NTggMzguNzVWMzUuNjNIMTAxLjY1OEMxMDEuNTExIDM1LjYzIDEwMS4zODUgMzUuNDc2NyAxMDEuMjc4IDM1LjE3QzEwMS4xNzEgMzQuODYzMyAxMDEuMTE4IDM0LjQ0MzMgMTAxLjExOCAzMy45MUMxMDEuMTE4IDMzLjM3NjcgMTAxLjE5OCAzMi45MSAxMDEuMzU4IDMyLjUxQzEwMS41MzEgMzIuMDk2NyAxMDEuNzUxIDMxLjg5IDEwMi4wMTggMzEuODlIMTAyLjY1OFYyOS40N0MxMDIuNjU4IDI5LjA1NjcgMTAzLjA1OCAyOC43MjMzIDEwMy44NTggMjguNDdDMTA0LjY3MSAyOC4yMTY3IDEwNS40NjUgMjguMDkgMTA2LjIzOCAyOC4wOUMxMDcuNDUxIDI4LjA5IDEwOC4wNTggMjguMzkgMTA4LjA1OCAyOC45OVYzMS44OUgxMDkuNTM4QzEwOS44ODUgMzEuODkgMTEwLjA1OCAzMi4zOSAxMTAuMDU4IDMzLjM5QzExMC4wNTggMzQuMDQzMyAxMDkuOTc4IDM0LjU4MzMgMTA5LjgxOCAzNS4wMUMxMDkuNjcxIDM1LjQyMzMgMTA5LjQ3OCAzNS42MyAxMDkuMjM4IDM1LjYzSDEwOC4wNThWMzkuMjlDMTA4LjA1OCAzOS42NSAxMDguMjExIDM5LjkxIDEwOC41MTggNDAuMDdDMTA4LjgyNSA0MC4yMTY3IDEwOS4wOTEgNDAuMjkgMTA5LjMxOCA0MC4yOUMxMDkuNTU4IDQwLjI5IDEwOS43MDUgNDAuNDAzMyAxMDkuNzU4IDQwLjYzQzEwOS44MTEgNDAuODU2NyAxMDkuODM4IDQxLjE5NjcgMTA5LjgzOCA0MS42NUMxMDkuODM4IDQyLjU0MzMgMTA5LjcxOCA0My4xMDMzIDEwOS40NzggNDMuMzNaTTExNy40MjYgNDMuNjlDMTE2LjQyNiA0My42OSAxMTUuNTY2IDQzLjYwMzMgMTE0Ljg0NiA0My40M0MxMTQuMTI2IDQzLjI1NjcgMTEzLjQ3MyA0Mi45NSAxMTIuODg2IDQyLjUxQzExMS42NzMgNDEuNjMgMTExLjA2NiAzOS45OSAxMTEuMDY2IDM3LjU5QzExMS4wNjYgMzUuNDU2NyAxMTEuNjg2IDMzLjkzIDExMi45MjYgMzMuMDFDMTE0LjA4NiAzMi4xNTY3IDExNS41ODYgMzEuNzMgMTE3LjQyNiAzMS43M0MxMTguMjEzIDMxLjczIDExOC44ODYgMzEuNzcgMTE5LjQ0NiAzMS44NUMxMjAuMDA2IDMxLjkxNjcgMTIwLjU3MyAzMi4wNyAxMjEuMTQ2IDMyLjMxQzEyMS43MzMgMzIuNTUgMTIyLjIgMzIuODc2NyAxMjIuNTQ2IDMzLjI5QzEyMi45MDYgMzMuNzAzMyAxMjMuMiAzNC4yNzY3IDEyMy40MjYgMzUuMDFDMTIzLjY1MyAzNS43MyAxMjMuNzY2IDM2LjU5IDEyMy43NjYgMzcuNTlDMTIzLjc2NiAzOS42MTY3IDEyMy4xOTMgNDEuMTQzMyAxMjIuMDQ2IDQyLjE3QzEyMC45IDQzLjE4MzMgMTE5LjM2IDQzLjY5IDExNy40MjYgNDMuNjlaTTExNi43MjYgMzkuNzlDMTE2LjgyIDQwLjI3IDExNi45MTMgNDAuNTU2NyAxMTcuMDA2IDQwLjY1QzExNy4xMTMgNDAuNzQzMyAxMTcuMjQ2IDQwLjc5IDExNy40MDYgNDAuNzlDMTE3LjU4IDQwLjc5IDExNy43MTMgNDAuNzQzMyAxMTcuODA2IDQwLjY1QzExNy45MTMgNDAuNTU2NyAxMTguMDA2IDQwLjI3IDExOC4wODYgMzkuNzlDMTE4LjE4IDM5LjMxIDExOC4yMjYgMzguNzEgMTE4LjIyNiAzNy45OUMxMTguMjI2IDM3LjI1NjcgMTE4LjIwNiAzNi42OTY3IDExOC4xNjYgMzYuMzFDMTE4LjE0IDM1LjkxIDExOC4xIDM1LjYwMzMgMTE4LjA0NiAzNS4zOUMxMTguMDA2IDM1LjE3NjcgMTE3Ljk0NiAzNS4wMSAxMTcuODY2IDM0Ljg5QzExNy43NDYgMzQuNzE2NyAxMTcuNiAzNC42MyAxMTcuNDI2IDM0LjYzQzExNy4yNjYgMzQuNjMgMTE3LjEzMyAzNC42ODMzIDExNy4wMjYgMzQuNzlDMTE2LjkyIDM0Ljg4MzMgMTE2LjgyIDM1LjE3NjcgMTE2LjcyNiAzNS42N0MxMTYuNjMzIDM2LjE1IDExNi41ODYgMzYuODM2NyAxMTYuNTg2IDM3LjczQzExNi41ODYgMzguNjIzMyAxMTYuNjMzIDM5LjMxIDExNi43MjYgMzkuNzlaTTEzMC4zNTggMzcuMTlWNDMuMDNDMTMwLjM1OCA0My4xNzY3IDEyOS45NzggNDMuMjk2NyAxMjkuMjE4IDQzLjM5QzEyOC40NzEgNDMuNDcgMTI3LjY5MSA0My41MSAxMjYuODc4IDQzLjUxQzEyNi4wNzggNDMuNTEgMTI1LjU1OCA0My40NzY3IDEyNS4zMTggNDMuNDFDMTI1LjA3OCA0My4zMyAxMjQuOTU4IDQzLjIwMzMgMTI0Ljk1OCA0My4wM1YzMy4xN0MxMjQuOTU4IDMyLjkxNjcgMTI1LjMyNCAzMi42NDMzIDEyNi4wNTggMzIuMzVDMTI2LjgwNCAzMi4wNTY3IDEyNy42MTEgMzEuOTEgMTI4LjQ3OCAzMS45MUMxMjkuMzU4IDMxLjkxIDEyOS44NTEgMzIuMTUgMTI5Ljk1OCAzMi42M0wxMzAuMTU4IDMzLjU1SDEzMC4yOThDMTMwLjQ4NCAzMy4wNDMzIDEzMC45MzEgMzIuNjE2NyAxMzEuNjM4IDMyLjI3QzEzMi4zNDQgMzEuOTEgMTMzLjA1MSAzMS43MyAxMzMuNzU4IDMxLjczQzEzNC40NjQgMzEuNzMgMTM0Ljk1OCAzMS44NDMzIDEzNS4yMzggMzIuMDdDMTM1LjUzMSAzMi4yOTY3IDEzNS42NzggMzIuNTkgMTM1LjY3OCAzMi45NUMxMzUuNjc4IDMzLjI5NjcgMTM1LjY1MSAzMy43NDMzIDEzNS41OTggMzQuMjlDMTM1LjU0NCAzNC44MzY3IDEzNS40MTEgMzUuNDMgMTM1LjE5OCAzNi4wN0MxMzQuOTk4IDM2LjcxIDEzNC43MzEgMzcuMDMgMTM0LjM5OCAzNy4wM0MxMzQuMjY0IDM3LjAzIDEzMy44NDQgMzYuOTMgMTMzLjEzOCAzNi43M0MxMzIuNDMxIDM2LjUzIDEzMS44NDQgMzYuNDMgMTMxLjM3OCAzNi40M0MxMzAuOTI0IDM2LjQzIDEzMC42MzggMzYuNDk2NyAxMzAuNTE4IDM2LjYzQzEzMC40MTEgMzYuNzYzMyAxMzAuMzU4IDM2Ljk1IDEzMC4zNTggMzcuMTlaIiBmaWxsPSIjRkYzMjMyIi8+CjxwYXRoIGQ9Ik0zOC4zMTI4IDU0LjM2MDVWNTEuODYyM0gyOC40NDE3VjU1LjM4NTRIMzcuMzY4TDI4LjQ0MzMgNjUuMDY0NEgyOC40NDE3VjY1LjA2NjFMMjguNDQwMSA2NS4wNjc3TDI4LjQ0MTcgNjUuMDY5M1Y2Ny40MzYySDMwLjcyODVMMzMuMDMxMyA2NC45Mzc5VjY3LjQzNjJINDIuOTAyNVY2My45MTNIMzMuOTc3OEw0Mi45MDI1IDU0LjIzMjRWNTEuODYyM0w0MC42MTQgNTEuODY1NUwzOC4zMTI4IDU0LjM2MDVaIiBmaWxsPSIjRkYzMjMyIi8+CjxwYXRoIGQ9Ik00Ny4yMjk0IDU5LjY3MDlDNDcuMjI5NCA1Ny4xMTM0IDQ5LjMwOTYgNTUuMDMzMSA1MS44NjcxIDU1LjAzMzFDNTIuNzY3MSA1NS4wMzMxIDUzLjYwNzggNTUuMjkxIDU0LjMxODggNTUuNzM2Mkw1Ni43NDAyIDUzLjEyOTFDNTUuMzc5IDUyLjExMjEgNTMuNjkyNyA1MS41MSA1MS44NjcxIDUxLjUxQzQ3LjM2NzEgNTEuNTEgNDMuNzA2MiA1NS4xNzA5IDQzLjcwNjIgNTkuNjcwOUM0My43MDYyIDYxLjcxMTEgNDQuNDU4OSA2My41Nzk5IDQ1LjcwNDggNjUuMDEzMkw0OC4xMjYyIDYyLjQwNjFDNDcuNTYyNSA2MS42MzkgNDcuMjI5NCA2MC42OTI2IDQ3LjIyOTQgNTkuNjcwOVoiIGZpbGw9IiNGRjMyMzIiLz4KPHBhdGggZD0iTTU1LjYwOTcgNTYuOTMzOUM1Ni4xNzE4IDU3LjcwMjYgNTYuNTA0OSA1OC42NDkgNTYuNTA0OSA1OS42NzA3QzU2LjUwNDkgNjIuMjI2NiA1NC40MjQ3IDY0LjMwNjkgNTEuODY3MiA2NC4zMDY5QzUwLjk2NzIgNjQuMzA2OSA1MC4xMjgxIDY0LjA0OSA0OS40MTcgNjMuNjAzOEw0Ni45OTQxIDY2LjIxMjZDNDguMzU1MyA2Ny4yMjc5IDUwLjA0MTYgNjcuODMgNTEuODY3MiA2Ny44M0M1Ni4zNjcyIDY3LjgzIDYwLjAyOCA2NC4xNjkxIDYwLjAyOCA1OS42NzA3QzYwLjAyOCA1Ny42Mjg5IDU5LjI3NTQgNTUuNzYwMSA1OC4wMjk1IDU0LjMyNjhMNTUuNjA5NyA1Ni45MzM5WiIgZmlsbD0iI0ZGMzIzMiIvPgo8cGF0aCBkPSJNNzUuNjE0NSA1NC4zMjY4TDczLjE5NDcgNTYuOTMzOUM3My43NTY4IDU3LjcwMjYgNzQuMDg5OSA1OC42NDkgNzQuMDg5OSA1OS42NzA3Qzc0LjA4OTkgNjIuMjI2NiA3Mi4wMDk3IDY0LjMwNjkgNjkuNDUyMiA2NC4zMDY5QzY4LjU1MjIgNjQuMzA2OSA2Ny43MTMxIDY0LjA0OSA2Ny4wMDIgNjMuNjAzOEw2NC41NzkxIDY2LjIxMjZDNjUuOTQwMyA2Ny4yMjc5IDY3LjYyNjYgNjcuODMgNjkuNDUyMiA2Ny44M0M3My45NTIyIDY3LjgzIDc3LjYxMyA2NC4xNjkxIDc3LjYxMyA1OS42NzA3Qzc3LjYxMyA1Ny42Mjg5IDc2Ljg2MDQgNTUuNzYwMSA3NS42MTQ1IDU0LjMyNjhaIiBmaWxsPSIjRkYzMjMyIi8+CjxwYXRoIGQ9Ik02NC44MTQ1IDU5LjY3MDlDNjQuODE0NSA1Ny4xMTM0IDY2Ljg5NDcgNTUuMDMzMSA2OS40NTIyIDU1LjAzMzFDNzAuMzUyMiA1NS4wMzMxIDcxLjE5MyA1NS4yOTEgNzEuOTA0IDU1LjczNjJMNzQuMzI1MyA1My4xMjkxQzcyLjk2NDEgNTIuMTEyMSA3MS4yNzc4IDUxLjUxIDY5LjQ1MjIgNTEuNTFDNjQuOTUyMiA1MS41MSA2MS4yOTE0IDU1LjE3MDkgNjEuMjkxNCA1OS42NzA5QzYxLjI5MTQgNjEuNzExMSA2Mi4wNDQgNjMuNTc5OSA2My4yOSA2NS4wMTMyTDY1LjcxMTMgNjIuNDA2MUM2NS4xNDc2IDYxLjYzOSA2NC44MTQ1IDYwLjY5MjYgNjQuODE0NSA1OS42NzA5WiIgZmlsbD0iI0ZGMzIzMiIvPgo8cGF0aCBkPSJNNy4xMDE2IDY3LjQ2NzZDNi42NTI4IDY3LjM1MzQgNi40Mjg0IDY3LjE4MiA2LjQyODQgNjYuOTUzNVY1OS4xOTM0QzYuNDI4NCA1OS4wMTM5IDYuNjY5MTIgNTguODM4NCA3LjE1MDU2IDU4LjY2NzFDNy42MzIgNTguNDk1NyA4LjEzNzkyIDU4LjQxIDguNjY4MzIgNTguNDFDOS4zODY0IDU4LjQxIDkuNzQ1NDQgNTguNTk3NyA5Ljc0NTQ0IDU4Ljk3MzFWNjAuMzU2Mkw5LjYxMDggNjEuMjAwN0g5LjcwODcyQzkuNzU3NjggNjEuMTI3MyA5Ljg0NzQ0IDYxLjAzNzUgOS45NzggNjAuOTMxNUMxMC4xMTY3IDYwLjgyNTQgMTAuMjU5NSA2MC43MzU2IDEwLjQwNjQgNjAuNjYyMkMxMC43NjU0IDYwLjQ3NDUgMTEuMTYxMiA2MC4zODA3IDExLjU5MzcgNjAuMzgwN0MxMi4wMjYyIDYwLjM4MDcgMTIuMzY0OCA2MC40Mzc4IDEyLjYwOTYgNjAuNTUyQzEyLjg2MjYgNjAuNjU4MSAxMy4wNjI1IDYwLjgwMDkgMTMuMjA5NCA2MC45ODA0QzEzLjM2NDQgNjEuMTUxOCAxMy40ODY4IDYxLjM3MjEgMTMuNTc2NiA2MS42NDE0QzEzLjczMTYgNjIuMTA2NSAxMy44MDkxIDYyLjY4NTkgMTMuODA5MSA2My4zNzk1QzEzLjgwOTEgNjQuNTMgMTMuNjc4NiA2NS40MTEzIDEzLjQxNzQgNjYuMDIzM0MxMy4xNTYzIDY2LjYzNTMgMTIuNzMyIDY3LjA2NzggMTIuMTQ0NSA2Ny4zMjA3QzExLjU1NyA2Ny41NzM3IDEwLjcyODcgNjcuNzAwMiA5LjY1OTc2IDY3LjcwMDJDOC41OTA4IDY3LjcwMDIgNy43MzgwOCA2Ny42MjI3IDcuMTAxNiA2Ny40Njc2Wk05LjczMzIgNjUuOTAwOUgxMC4xMTI2QzEwLjM3MzggNjUuOTAwOSAxMC41MDQzIDY1LjI3NjcgMTAuNTA0MyA2NC4wMjgyQzEwLjUwNDMgNjIuNzcxNSAxMC4zNjk3IDYyLjE0MzIgMTAuMTAwNCA2Mi4xNDMySDkuNzMzMlY2NS45MDA5Wk0xOC43MjkyIDY2Ljc5NDRWNjYuMDcyM0gxOC42MzEzQzE4LjU5MDUgNjYuMTEzMSAxOC41MjkzIDY2LjE2NjEgMTguNDQ3NyA2Ni4yMzE0QzE4LjM2NjEgNjYuMjk2NyAxOC4xNzQzIDY2LjM4MjMgMTcuODcyNCA2Ni40ODg0QzE3LjU3MDUgNjYuNTk0NSAxNy4yMzE5IDY2LjY0NzUgMTYuODU2NSA2Ni42NDc1QzE2LjQ4OTMgNjYuNjQ3NSAxNi4xNjI5IDY2LjU5MDQgMTUuODc3MyA2Ni40NzYyQzE1LjU5OTkgNjYuMzUzOCAxNS4zNzk1IDY2LjE5NDcgMTUuMjE2MyA2NS45OTg4QzE1LjA1MzEgNjUuNzk0OCAxNC45MjY3IDY1LjUyNTUgMTQuODM2OSA2NS4xOTFDMTQuNjgxOSA2NC42NjA2IDE0LjYwNDMgNjMuOTA5OSAxNC42MDQzIDYyLjkzODhWNjEuMjQ5N0MxNC42MDQzIDYxLjA3ODMgMTQuODQ1MSA2MC45MTExIDE1LjMyNjUgNjAuNzQ3OUMxNS44MDc5IDYwLjU3NjUgMTYuMzEzOSA2MC40OTA4IDE2Ljg0NDMgNjAuNDkwOEMxNy41NTQyIDYwLjQ5MDggMTcuOTA5MSA2MC42NzQ0IDE3LjkwOTEgNjEuMDQxNlY2Mi41ODM5QzE3LjkwOTEgNjQuMjE1OSAxOC4wMzk3IDY1LjAzMTkgMTguMzAwOCA2NS4wMzE5QzE4LjQ1NTkgNjUuMDMxOSAxOC41MzM0IDY0LjkyMTcgMTguNTMzNCA2NC43MDE0VjYxLjI0OTdDMTguNTMzNCA2MS4wNzgzIDE4Ljc5MDQgNjAuOTExMSAxOS4zMDQ1IDYwLjc0NzlDMTkuODE4NiA2MC41NzY1IDIwLjM2OTQgNjAuNDkwOCAyMC45NTY5IDYwLjQ5MDhDMjEuNTQ0NCA2MC40OTA4IDIxLjgzODIgNjAuNjQ5OSAyMS44MzgyIDYwLjk2ODJWNjYuNzU3N0MyMS44MzgyIDY4LjU3NzQgMjAuNjA2IDY5LjQ4NzIgMTguMTQxNyA2OS40ODcyQzE2Ljg0NDMgNjkuNDg3MiAxNS45NjMgNjkuMzYwNyAxNS40OTc5IDY5LjEwNzhDMTUuMjkzOSA2OC45OTM1IDE1LjE5MTkgNjguODc1MiAxNS4xOTE5IDY4Ljc1MjhDMTUuMTkxOSA2OC41NTcgMTUuMjczNSA2OC4yMjY1IDE1LjQzNjcgNjcuNzYxNEMxNS41OTk5IDY3LjMwNDQgMTUuNzUwOCA2Ny4wNzU5IDE1Ljg4OTUgNjcuMDc1OUMxNS45MjIyIDY3LjA3NTkgMTYuMDM2NCA2Ny4xMDA0IDE2LjIzMjMgNjcuMTQ5NEMxNi44MzYxIDY3LjMxMjYgMTcuMzM3OSA2Ny4zOTQyIDE3LjczNzggNjcuMzk0MkMxOC4xNDU4IDY3LjM5NDIgMTguNDExIDY3LjM0OTMgMTguNTMzNCA2Ny4yNTk1QzE4LjY2MzkgNjcuMTY5OCAxOC43MjkyIDY3LjAxNDcgMTguNzI5MiA2Ni43OTQ0WiIgZmlsbD0iI0ZGMzIzMiIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTI5LjUyNDcgNDIuOTZMMjkuOTc4IDM1LjAzODlMMzcuMDAwMyAzOC43MzE3TDM0LjYyMzQgNDMuMjUxOEwyOS41MjQ3IDQyLjk2Wk0xMS41NjQ0IDE2LjMwMDNDOC41MTM4OCAxOC4xMjc0IDguMDQ2IDIzLjA1NiAxMC4wNjMyIDI2LjU0OTlDMTQuNDUxNCAzNC4xNTA1IDI5Ljk3OCAzNS4wMzg5IDI5Ljk3OCAzNS4wMzg5QzI5LjUyNDcgNDIuOTYgMjkuNTIyOSA0Mi45NTk5IDI5LjUyMDkgNDIuOTU5OEwyOS41MTY3IDQyLjk1OTZMMjkuNTA3MiA0Mi45NTlMMjkuNDgzOSA0Mi45NTc2TDI5LjQyMDEgNDIuOTUzNkMyOS4zNzAxIDQyLjk1MDQgMjkuMzA1MSA0Mi45NDYgMjkuMjI2MSA0Mi45NDAyQzI5LjA2OCA0Mi45Mjg3IDI4Ljg1MzIgNDIuOTExNyAyOC41ODgyIDQyLjg4NzhDMjguMDU5MyA0Mi44NCAyNy4zMjUyIDQyLjc2MzkgMjYuNDQwNyA0Mi42NDY2QzI0LjY4ODQgNDIuNDE0MyAyMi4yNjQ0IDQyLjAxIDE5LjYzNjcgNDEuMzE0OEMxNy4wNDMgNDAuNjI4NSAxNC4wMTM3IDM5LjU5NzQgMTEuMTcxNCAzOC4wMTc1QzguMzY1NDIgMzYuNDU3OCA1LjI1NjY5IDM0LjA5MjkgMy4xOTIwOSAzMC41MTY5QzEuMjc3NDcgMjcuMjAwNyAwLjU3MDI2MiAyMy4zMDQgMS4wNTU3NCAxOS43MDAyQzEuNTM2NDUgMTYuMTMxNyAzLjM4MjggMTEuODYxOCA3LjY2MzA4IDkuMzkwNTlDOS43NjcxNiA4LjE3NTggMTEuOTgyNSA3LjYwNTk2IDE0LjA4MzkgNy40Nzk0QzE1LjIzMTUgNS43MzcxNSAxNi44MTg5IDQuMTA0NDUgMTguOTIzMyAyLjg4OTVDMjMuMjUyMSAwLjM5MDI5IDI3LjkwODIgMC45OTYzOTcgMzEuMTk0MSAyLjM1ODI3QzM0LjUyMyAzLjczNzkyIDM3LjU0OTIgNi4yODAxMSAzOS40NTQ3IDkuNTgwNjVDNDMuNDU4OCAxNi41MTYgNDEuOTI1MSAyNC43MjI4IDQwLjYzMTMgMjkuMzc1QzM5LjkwMDkgMzIuMDAxMyAzOS4wMTMyIDM0LjI5MjQgMzguMzE3MiAzNS45MTU4QzM3Ljk2NTggMzYuNzM1MyAzNy42NTQ3IDM3LjQwNDUgMzcuNDIzNyAzNy44ODM5QzM3LjMwNzkgMzguMTI0IDM3LjIxMTYgMzguMzE3OCAzNy4xMzk2IDM4LjQ2MDVDMzcuMTAzNSAzOC41MzE4IDM3LjA3MzUgMzguNTkwNSAzNy4wNTAxIDM4LjYzNTlMMzcuMDIwMSAzOC42OTM5TDM3LjAwODkgMzguNzE1NEwzNy4wMDQzIDM4LjcyNDJMMzcuMDAyMiAzOC43MjgxQzM3LjAwMTIgMzguNzI5OSAzNy4wMDAzIDM4LjczMTcgMjkuOTc4IDM1LjAzODlDMjkuOTc4IDM1LjAzODkgMzcuMTM0NCAyMS40Mjk4IDMyLjU4MzYgMTMuNTQ3N0MzMC42MTAxIDEwLjEyOTQgMjYuMDc5OCA4LjAwMjc1IDIyLjk3MjIgOS43MTQ0M0MyMi45NDQ4IDkuNzI5NTEgMjIuOTE3NSA5Ljc0NDkgMjIuODkwMyA5Ljc2MDU5QzE5Ljc4MDkgMTEuNTU1OCAxOC44NDQ5IDE1Ljc1NTggMTkuOTA4NyAxNy41OTg1QzE4LjgwNDIgMTUuNjg1NCAxNC43Mzk1IDE0LjQ2NjUgMTEuNjMwMSAxNi4yNjE3QzExLjYwODEgMTYuMjc0NCAxMS41ODYxIDE2LjI4NzMgMTEuNTY0NCAxNi4zMDAzWiIgZmlsbD0iI0ZGMzIzMiIvPgo8L3N2Zz4K"/></a>
        </div>
        <div id="auth">
          <a class="hide" id="sign-in" href="https://zoo.dev/signin?callbackUrl=https%3A%2F%2Fcookie-cutter.zoo.dev">
            Sign in
            <div id="uwu">

              <img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNjkiIGhlaWdodD0iNjkiIHZpZXdCb3g9IjAgMCA2OSA2OSIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHBhdGggZD0iTTExLjY2NCA0NC4yMTZDOS44NzIgNDQuMjE2IDguNjE2IDQzLjc1MiA3Ljg5NiA0Mi44MjRDNy4xOTIgNDEuODk2IDYuODQgNDAuMjggNi44NCAzNy45NzZWMzEuNDQ4QzYuODQgMzEuMTI4IDcuMzEyIDMwLjgyNCA4LjI1NiAzMC41MzZDOS4yIDMwLjIzMiAxMC4xOTIgMzAuMDggMTEuMjMyIDMwLjA4QzEyLjYyNCAzMC4wOCAxMy4zMiAzMC40NCAxMy4zMiAzMS4xNlYzNy4yNTZDMTMuMzIgMzguNDcyIDEzLjM2OCAzOS4zNiAxMy40NjQgMzkuOTJDMTMuNTYgNDAuNDY0IDEzLjggNDAuNzM2IDE0LjE4NCA0MC43MzZDMTQuNjk2IDQwLjczNiAxNC45NTIgNDAuNTIgMTQuOTUyIDQwLjA4OFYzMS40NDhDMTQuOTUyIDMxLjExMiAxNS40NDggMzAuOCAxNi40NCAzMC41MTJDMTcuNDMyIDMwLjIyNCAxOC41MTIgMzAuMDggMTkuNjggMzAuMDhDMjAuODQ4IDMwLjA4IDIxLjQzMiAzMC4zOTIgMjEuNDMyIDMxLjAxNlY0My4zNzZDMjEuNDMyIDQzLjYgMjAuOTI4IDQzLjc2IDE5LjkyIDQzLjg1NkMxOC45MTIgNDMuOTUyIDE3LjkyIDQ0IDE2Ljk0NCA0NEMxNS45NjggNDQgMTUuNDcyIDQzLjg3MiAxNS40NTYgNDMuNjE2TDE1LjIxNiA0Mi4wNTZIMTUuMDI0QzE0Ljg4IDQyLjYzMiAxNC41OTIgNDMuMTA0IDE0LjE2IDQzLjQ3MkMxMy45MzYgNDMuNjY0IDEzLjYgNDMuODQgMTMuMTUyIDQ0QzEyLjcyIDQ0LjE0NCAxMi4yMjQgNDQuMjE2IDExLjY2NCA0NC4yMTZaTTQxLjMyMTYgNDMuNDI0QzQxLjExMzYgNDMuODA4IDQwLjAyNTYgNDQgMzguMDU3NiA0NEMzNi4xMDU2IDQ0IDM1LjA4OTYgNDMuODA4IDM1LjAwOTYgNDMuNDI0TDM0LjE5MzYgMzkuMDU2SDMzLjg1NzZMMzMuMDg5NiA0My40MjRDMzMuMDQxNiA0My44MDggMzEuNjQxNiA0NCAyOC44ODk2IDQ0QzI4LjEyMTYgNDQgMjcuNjA5NiA0My45NiAyNy4zNTM2IDQzLjg4QzI3LjExMzYgNDMuNzg0IDI2Ljk0NTYgNDMuNjMyIDI2Ljg0OTYgNDMuNDI0QzIzLjg3MzYgMzYuMTEyIDIyLjM4NTYgMzIuMjY0IDIyLjM4NTYgMzEuODhDMjIuMzg1NiAzMS40OTYgMjIuOTYxNiAzMS4xMDQgMjQuMTEzNiAzMC43MDRDMjUuMjgxNiAzMC4yODggMjYuNDAxNiAzMC4wOCAyNy40NzM2IDMwLjA4QzI4Ljg0OTYgMzAuMDggMjkuNTYxNiAzMC40NDggMjkuNjA5NiAzMS4xODRMMzAuNDI1NiAzNy43NkgzMC43MTM2TDMxLjAwMTYgMzIuNDU2QzMxLjAxNzYgMzIuMDU2IDMxLjQyNTYgMzEuNzA0IDMyLjIyNTYgMzEuNEMzMy4wMjU2IDMxLjA5NiAzMy44MzM2IDMwLjk0NCAzNC42NDk2IDMwLjk0NEMzNS40NjU2IDMwLjk0NCAzNi4wNzM2IDMxLjA0OCAzNi40NzM2IDMxLjI1NkMzNi44ODk2IDMxLjQ0OCAzNy4xMDU2IDMxLjY4OCAzNy4xMjE2IDMxLjk3NkwzNy4zODU2IDM3Ljc2SDM3LjY0OTZMMzguNDQxNiAzMS41OTJDMzguNDg5NiAzMS4yMDggMzkuMDI1NiAzMC44NjQgNDAuMDQ5NiAzMC41NkM0MS4wODk2IDMwLjI0IDQyLjAwMTYgMzAuMDggNDIuNzg1NiAzMC4wOEM0My41Njk2IDMwLjA4IDQ0LjE4NTYgMzAuMTkyIDQ0LjYzMzYgMzAuNDE2QzQ1LjM2OTYgMzAuNzY4IDQ1LjczNzYgMzEuMTg0IDQ1LjczNzYgMzEuNjY0QzQ1LjczNzYgMzEuNzEyIDQ1LjAwOTYgMzMuNjY0IDQzLjU1MzYgMzcuNTJDNDIuMTEzNiA0MS4zNzYgNDEuMzY5NiA0My4zNDQgNDEuMzIxNiA0My40MjRaTTUxLjUzMTIgNDQuMjE2QzQ5LjczOTIgNDQuMjE2IDQ4LjQ4MzIgNDMuNzUyIDQ3Ljc2MzIgNDIuODI0QzQ3LjA1OTIgNDEuODk2IDQ2LjcwNzIgNDAuMjggNDYuNzA3MiAzNy45NzZWMzEuNDQ4QzQ2LjcwNzIgMzEuMTI4IDQ3LjE3OTIgMzAuODI0IDQ4LjEyMzIgMzAuNTM2QzQ5LjA2NzIgMzAuMjMyIDUwLjA1OTIgMzAuMDggNTEuMDk5MiAzMC4wOEM1Mi40OTEyIDMwLjA4IDUzLjE4NzIgMzAuNDQgNTMuMTg3MiAzMS4xNlYzNy4yNTZDNTMuMTg3MiAzOC40NzIgNTMuMjM1MiAzOS4zNiA1My4zMzEyIDM5LjkyQzUzLjQyNzIgNDAuNDY0IDUzLjY2NzIgNDAuNzM2IDU0LjA1MTIgNDAuNzM2QzU0LjU2MzIgNDAuNzM2IDU0LjgxOTIgNDAuNTIgNTQuODE5MiA0MC4wODhWMzEuNDQ4QzU0LjgxOTIgMzEuMTEyIDU1LjMxNTIgMzAuOCA1Ni4zMDcyIDMwLjUxMkM1Ny4yOTkyIDMwLjIyNCA1OC4zNzkyIDMwLjA4IDU5LjU0NzIgMzAuMDhDNjAuNzE1MiAzMC4wOCA2MS4yOTkyIDMwLjM5MiA2MS4yOTkyIDMxLjAxNlY0My4zNzZDNjEuMjk5MiA0My42IDYwLjc5NTIgNDMuNzYgNTkuNzg3MiA0My44NTZDNTguNzc5MiA0My45NTIgNTcuNzg3MiA0NCA1Ni44MTEyIDQ0QzU1LjgzNTIgNDQgNTUuMzM5MiA0My44NzIgNTUuMzIzMiA0My42MTZMNTUuMDgzMiA0Mi4wNTZINTQuODkxMkM1NC43NDcyIDQyLjYzMiA1NC40NTkyIDQzLjEwNCA1NC4wMjcyIDQzLjQ3MkM1My44MDMyIDQzLjY2NCA1My40NjcyIDQzLjg0IDUzLjAxOTIgNDRDNTIuNTg3MiA0NC4xNDQgNTIuMDkxMiA0NC4yMTYgNTEuNTMxMiA0NC4yMTZaIiBmaWxsPSIjRkYzMjMyIi8+Cjwvc3ZnPgo="/>
            </div>
          </a>
          <details id="account">
            <summary>
              <img id="avatar" referrerpolicy="no-referrer" src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNjkiIGhlaWdodD0iNjkiIHZpZXdCb3g9IjAgMCA2OSA2OSIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHBhdGggZD0iTTExLjY2NCA0NC4yMTZDOS44NzIgNDQuMjE2IDguNjE2IDQzLjc1MiA3Ljg5NiA0Mi44MjRDNy4xOTIgNDEuODk2IDYuODQgNDAuMjggNi44NCAzNy45NzZWMzEuNDQ4QzYuODQgMzEuMTI4IDcuMzEyIDMwLjgyNCA4LjI1NiAzMC41MzZDOS4yIDMwLjIzMiAxMC4xOTIgMzAuMDggMTEuMjMyIDMwLjA4QzEyLjYyNCAzMC4wOCAxMy4zMiAzMC40NCAxMy4zMiAzMS4xNlYzNy4yNTZDMTMuMzIgMzguNDcyIDEzLjM2OCAzOS4zNiAxMy40NjQgMzkuOTJDMTMuNTYgNDAuNDY0IDEzLjggNDAuNzM2IDE0LjE4NCA0MC43MzZDMTQuNjk2IDQwLjczNiAxNC45NTIgNDAuNTIgMTQuOTUyIDQwLjA4OFYzMS40NDhDMTQuOTUyIDMxLjExMiAxNS40NDggMzAuOCAxNi40NCAzMC41MTJDMTcuNDMyIDMwLjIyNCAxOC41MTIgMzAuMDggMTkuNjggMzAuMDhDMjAuODQ4IDMwLjA4IDIxLjQzMiAzMC4zOTIgMjEuNDMyIDMxLjAxNlY0My4zNzZDMjEuNDMyIDQzLjYgMjAuOTI4IDQzLjc2IDE5LjkyIDQzLjg1NkMxOC45MTIgNDMuOTUyIDE3LjkyIDQ0IDE2Ljk0NCA0NEMxNS45NjggNDQgMTUuNDcyIDQzLjg3MiAxNS40NTYgNDMuNjE2TDE1LjIxNiA0Mi4wNTZIMTUuMDI0QzE0Ljg4IDQyLjYzMiAxNC41OTIgNDMuMTA0IDE0LjE2IDQzLjQ3MkMxMy45MzYgNDMuNjY0IDEzLjYgNDMuODQgMTMuMTUyIDQ0QzEyLjcyIDQ0LjE0NCAxMi4yMjQgNDQuMjE2IDExLjY2NCA0NC4yMTZaTTQxLjMyMTYgNDMuNDI0QzQxLjExMzYgNDMuODA4IDQwLjAyNTYgNDQgMzguMDU3NiA0NEMzNi4xMDU2IDQ0IDM1LjA4OTYgNDMuODA4IDM1LjAwOTYgNDMuNDI0TDM0LjE5MzYgMzkuMDU2SDMzLjg1NzZMMzMuMDg5NiA0My40MjRDMzMuMDQxNiA0My44MDggMzEuNjQxNiA0NCAyOC44ODk2IDQ0QzI4LjEyMTYgNDQgMjcuNjA5NiA0My45NiAyNy4zNTM2IDQzLjg4QzI3LjExMzYgNDMuNzg0IDI2Ljk0NTYgNDMuNjMyIDI2Ljg0OTYgNDMuNDI0QzIzLjg3MzYgMzYuMTEyIDIyLjM4NTYgMzIuMjY0IDIyLjM4NTYgMzEuODhDMjIuMzg1NiAzMS40OTYgMjIuOTYxNiAzMS4xMDQgMjQuMTEzNiAzMC43MDRDMjUuMjgxNiAzMC4yODggMjYuNDAxNiAzMC4wOCAyNy40NzM2IDMwLjA4QzI4Ljg0OTYgMzAuMDggMjkuNTYxNiAzMC40NDggMjkuNjA5NiAzMS4xODRMMzAuNDI1NiAzNy43NkgzMC43MTM2TDMxLjAwMTYgMzIuNDU2QzMxLjAxNzYgMzIuMDU2IDMxLjQyNTYgMzEuNzA0IDMyLjIyNTYgMzEuNEMzMy4wMjU2IDMxLjA5NiAzMy44MzM2IDMwLjk0NCAzNC42NDk2IDMwLjk0NEMzNS40NjU2IDMwLjk0NCAzNi4wNzM2IDMxLjA0OCAzNi40NzM2IDMxLjI1NkMzNi44ODk2IDMxLjQ0OCAzNy4xMDU2IDMxLjY4OCAzNy4xMjE2IDMxLjk3NkwzNy4zODU2IDM3Ljc2SDM3LjY0OTZMMzguNDQxNiAzMS41OTJDMzguNDg5NiAzMS4yMDggMzkuMDI1NiAzMC44NjQgNDAuMDQ5NiAzMC41NkM0MS4wODk2IDMwLjI0IDQyLjAwMTYgMzAuMDggNDIuNzg1NiAzMC4wOEM0My41Njk2IDMwLjA4IDQ0LjE4NTYgMzAuMTkyIDQ0LjYzMzYgMzAuNDE2QzQ1LjM2OTYgMzAuNzY4IDQ1LjczNzYgMzEuMTg0IDQ1LjczNzYgMzEuNjY0QzQ1LjczNzYgMzEuNzEyIDQ1LjAwOTYgMzMuNjY0IDQzLjU1MzYgMzcuNTJDNDIuMTEzNiA0MS4zNzYgNDEuMzY5NiA0My4zNDQgNDEuMzIxNiA0My40MjRaTTUxLjUzMTIgNDQuMjE2QzQ5LjczOTIgNDQuMjE2IDQ4LjQ4MzIgNDMuNzUyIDQ3Ljc2MzIgNDIuODI0QzQ3LjA1OTIgNDEuODk2IDQ2LjcwNzIgNDAuMjggNDYuNzA3MiAzNy45NzZWMzEuNDQ4QzQ2LjcwNzIgMzEuMTI4IDQ3LjE3OTIgMzAuODI0IDQ4LjEyMzIgMzAuNTM2QzQ5LjA2NzIgMzAuMjMyIDUwLjA1OTIgMzAuMDggNTEuMDk5MiAzMC4wOEM1Mi40OTEyIDMwLjA4IDUzLjE4NzIgMzAuNDQgNTMuMTg3MiAzMS4xNlYzNy4yNTZDNTMuMTg3MiAzOC40NzIgNTMuMjM1MiAzOS4zNiA1My4zMzEyIDM5LjkyQzUzLjQyNzIgNDAuNDY0IDUzLjY2NzIgNDAuNzM2IDU0LjA1MTIgNDAuNzM2QzU0LjU2MzIgNDAuNzM2IDU0LjgxOTIgNDAuNTIgNTQuODE5MiA0MC4wODhWMzEuNDQ4QzU0LjgxOTIgMzEuMTEyIDU1LjMxNTIgMzAuOCA1Ni4zMDcyIDMwLjUxMkM1Ny4yOTkyIDMwLjIyNCA1OC4zNzkyIDMwLjA4IDU5LjU0NzIgMzAuMDhDNjAuNzE1MiAzMC4wOCA2MS4yOTkyIDMwLjM5MiA2MS4yOTkyIDMxLjAxNlY0My4zNzZDNjEuMjk5MiA0My42IDYwLjc5NTIgNDMuNzYgNTkuNzg3MiA0My44NTZDNTguNzc5MiA0My45NTIgNTcuNzg3MiA0NCA1Ni44MTEyIDQ0QzU1LjgzNTIgNDQgNTUuMzM5MiA0My44NzIgNTUuMzIzMiA0My42MTZMNTUuMDgzMiA0Mi4wNTZINTQuODkxMkM1NC43NDcyIDQyLjYzMiA1NC40NTkyIDQzLjEwNCA1NC4wMjcyIDQzLjQ3MkM1My44MDMyIDQzLjY2NCA1My40NjcyIDQzLjg0IDUzLjAxOTIgNDRDNTIuNTg3MiA0NC4xNDQgNTIuMDkxMiA0NC4yMTYgNTEuNTMxMiA0NC4yMTZaIiBmaWxsPSIjRkYzMjMyIi8+Cjwvc3ZnPgo="/>
            </summary>
            <div id="account-menu">
              <div id="user-info">
                <p id="user-name">User Name</p>
                <p id="user-email">user.email@example.com</p>
              </div>
              <button id="sign-out">
                Sign out
              </button>
          </details>
        </div>
      </header>
      <section id="configuration">
        <p>
          You can use <a href="https://www.figma.com/file/jqTEa6dFfiWMor3tGwxmwX/KittyCAD-Cookie-Cutter-Creator?type=design&node-id=0%3A1&mode=design&t=kgJTe5t8u1StFdzc-1" target="_blank" rel="noreferrer noopener">Figma template</a> to start with some example paths, or download these <a download="cookie-cutter-outline.svg" href="/samples/outline.svg">outline</a> and <a download="cookie-cutter-stamp.svg" href="/samples/stamp.svg">stamp</a> examples directly.
        </p>
        <div id="upload-fields">
          <label for="file-outline" class="svg-file-uploader">
            <div>Upload an SVG of your cookie outline</div>
            <div id="outline">
              <img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTczIiBoZWlnaHQ9IjE3NCIgdmlld0JveD0iMCAwIDE3MyAxNzQiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+CjxwYXRoIGZpbGwtcnVsZT0iZXZlbm9kZCIgY2xpcC1ydWxlPSJldmVub2RkIiBkPSJNNzUuMDc4MiAxNjUuNDU2TDg2LjA1MTMgMTQ4LjczNUw5Ni43MjcyIDE2NS42NDdMODUuODQxMSAxNzIuNTE5TDc1LjA3ODIgMTY1LjQ1NlpNNzIuNDU2NyAyNi41NzM2QzY3LjA2NDEgMjIuOTM3NSA2MC40MzgyIDIwLjUgNTMuMjc1NyAyMC41QzM1LjE3NDIgMjAuNSAyMC41IDQwLjk4NDggMjAuNSA2MS40Njk2QzIwLjUgMTA1LjcxNyA4Ni4wNTEzIDE0OC43MzUgODYuMDUxMyAxNDguNzM1Qzc1LjA3ODIgMTY1LjQ1NiA3NS4wNzQxIDE2NS40NTMgNzUuMDY5NyAxNjUuNDVMNzUuMDU5NyAxNjUuNDQ0TDc1LjAzNTIgMTY1LjQyN0w3NC45NjgzIDE2NS4zODNDNzQuOTE1NyAxNjUuMzQ4IDc0Ljg0NzQgMTY1LjMwMyA3NC43NjM4IDE2NS4yNDdDNzQuNTk2NyAxNjUuMTM2IDc0LjM2ODQgMTY0Ljk4MyA3NC4wODMxIDE2NC43ODlDNzMuNTEyNiAxNjQuNDAyIDcyLjcxMjggMTYzLjg1MiA3MS43MTY0IDE2My4xNUM2OS43MjU4IDE2MS43NDggNjYuOTM4OCAxNTkuNzMgNjMuNjE5NSAxNTcuMTc4QzU3LjAxNDEgMTUyLjEgNDguMTM0OSAxNDQuNzgyIDM5LjE3NzkgMTM1Ljg4MUMzMC4yODM2IDEyNy4wNDIgMjAuODczMSAxMTYuMjExIDEzLjU4NjkgMTA0LjA1MkM2LjM1NDMzIDkxLjk4MjcgMC41IDc3LjQwOTMgMC41IDYxLjQ2OTZDMC41IDQ2LjY5NTcgNS43MDE3NiAzMi4xNzY0IDE0LjI2OTQgMjEuMDgwMUMyMi43ODIxIDEwLjA1NSAzNi4yOTE1IDAuNSA1My4yNzU3IDAuNUM2Ni4xNzc0IDAuNSA3Ny41MzQ0IDUuMjkwMTkgODYuMTM4NSAxMS43Nzc1Qzk0LjY1MzcgNS4zNTQ3OSAxMDUuOTMyIDAuNSAxMTguODI3IDAuNUMxMzUuOTUyIDAuNSAxNDkuNDUgMTAuMzAzNSAxNTcuODcyIDIxLjI4NDZDMTY2LjM2NiAzMi4zNTg2IDE3MS42MDMgNDYuODQzOCAxNzEuNjAzIDYxLjQ2OTZDMTcxLjYwMyA5My4xMjc5IDE0OS43MTcgMTIwLjAxOSAxMzIuODM1IDEzNi41ODVDMTIzLjgzMyAxNDUuNDE4IDExNC45MTEgMTUyLjYwMyAxMDguMjcyIDE1Ny41NjhDMTA0LjkzNiAxNjAuMDY0IDEwMi4xMzMgMTYyLjAzIDEwMC4xMjggMTYzLjM5NkM5OS4xMjQ4IDE2NC4wOCA5OC4zMTgyIDE2NC42MTUgOTcuNzQxMSAxNjQuOTkzQzk3LjQ1MjUgMTY1LjE4MSA5Ny4yMjEgMTY1LjMzMSA5Ny4wNTA3IDE2NS40NDFDOTcuMDA4OCAxNjUuNDY4IDk2Ljk3MDYgMTY1LjQ5MiA5Ni45MzYyIDE2NS41MTRDOTYuOTAwNiAxNjUuNTM3IDk2Ljg2OTEgMTY1LjU1NyA5Ni44NDE2IDE2NS41NzRMOTYuNzcyNCAxNjUuNjE4TDk2Ljc0NjcgMTY1LjYzNUw5Ni43MzYyIDE2NS42NDFDOTYuNzMxNiAxNjUuNjQ0IDk2LjcyNzIgMTY1LjY0NyA4Ni4wNTEzIDE0OC43MzVDODYuMDUxMyAxNDguNzM1IDE1MS42MDMgMTA3LjM1NSAxNTEuNjAzIDYxLjQ2OTZDMTUxLjYwMyA0MS4zOTQ1IDEzNi45MjggMjAuNSAxMTguODI3IDIwLjVDMTExLjcyMSAyMC41IDEwNS4xNDQgMjIuOTYyIDk5Ljc3NSAyNi42MDE5QzkxLjQ2NjIgMzIuMjM0OSA4Ni4wNTEzIDQwLjY4ODkgODYuMDUxMyA0Ny4yMDUxQzg2LjA1MTMgNDAuNDc1MSA4MC42OTI0IDMyLjEyNjYgNzIuNDU2NyAyNi41NzM2WiIgZmlsbD0iI0ZGMzIzMiIvPgo8cGF0aCBkPSJNNzguMzM5MSA3My42MTc0SDcwLjUxMDlWNTYuMzQzOUg3OC45MDE2QzgxLjAxODcgNTYuMzc1MiA4Mi41MTg3IDU2Ljk4ODUgODMuNDAxNiA1OC4xODM4QzgzLjkzMjggNTguOTE4MiA4NC4xOTg0IDU5Ljc5NzEgODQuMTk4NCA2MC44MjA1Qzg0LjE5ODQgNjEuODc1MiA4My45MzI4IDYyLjcyMjggODMuNDAxNiA2My4zNjM1QzgzLjEwNDcgNjMuNzIyOCA4Mi42NjcyIDY0LjA1MSA4Mi4wODkxIDY0LjM0NzhDODIuOTcxOSA2NC42NjgyIDgzLjYzNTkgNjUuMTc2IDg0LjA4MTIgNjUuODcxM0M4NC41MzQ0IDY2LjU2NjYgODQuNzYwOSA2Ny40MTAzIDg0Ljc2MDkgNjguNDAyNUM4NC43NjA5IDY5LjQyNiA4NC41MDMxIDcwLjM0MzkgODMuOTg3NSA3MS4xNTY0QzgzLjY1OTQgNzEuNjk1NSA4My4yNDkyIDcyLjE0ODYgODIuNzU3IDcyLjUxNThDODIuMjAyMyA3Mi45Mzc3IDgxLjU0NjEgNzMuMjI2NyA4MC43ODgzIDczLjM4M0M4MC4wMzgzIDczLjUzOTIgNzkuMjIxOSA3My42MTc0IDc4LjMzOTEgNzMuNjE3NFpNNzguMjU3IDY2LjAxMTlINzMuOTU2MlY3MC42MTc0SDc4LjE5ODRDNzguOTU2MiA3MC42MTc0IDc5LjU0NjEgNzAuNTE1OCA3OS45NjggNzAuMzEyN0M4MC43MzM2IDY5LjkzNzcgODEuMTE2NCA2OS4yMTg5IDgxLjExNjQgNjguMTU2NEM4MS4xMTY0IDY3LjI1OCA4MC43NDUzIDY2LjY0MDggODAuMDAzMSA2Ni4zMDQ5Qzc5LjU4OTEgNjYuMTE3NCA3OS4wMDcgNjYuMDE5NyA3OC4yNTcgNjYuMDExOVpNODAuMDUgNjIuNzE4OUM4MC41MTg3IDYyLjQzNzcgODAuNzUzMSA2MS45MzM4IDgwLjc1MzEgNjEuMjA3MkM4MC43NTMxIDYwLjQwMjUgODAuNDQwNiA1OS44NzEzIDc5LjgxNTYgNTkuNjEzNUM3OS4yNzY2IDU5LjQzMzggNzguNTg5MSA1OS4zNDM5IDc3Ljc1MzEgNTkuMzQzOUg3My45NTYyVjYzLjE1MjVINzguMTk4NEM3OC45NTYyIDYzLjE1MjUgNzkuNTczNCA2My4wMDggODAuMDUgNjIuNzE4OVpNMTAyLjIyIDY2LjA3MDVIOTMuODI4OVY3MC41MTE5SDEwMy4zOTFWNzMuNjE3NEg5MC4zMDE2VjU2LjM0MzlIMTAyLjk3VjU5LjQwMjVIOTMuODI4OVY2My4wNzA1SDEwMi4yMlY2Ni4wNzA1Wk01OC4wMjExIDEwNy42MTdINTQuNjU3OFY5MC4zNDM5SDU5LjkwNzhMNjMuMDQ4NCAxMDMuOTI2TDY2LjE2NTYgOTAuMzQzOUg3MS4zNTdWMTA3LjYxN0g2Ny45OTM3Vjk1LjkzMzhDNjcuOTkzNyA5NS41OTc4IDY3Ljk5NzcgOTUuMTI5MSA2OC4wMDU1IDk0LjUyNzVDNjguMDEzMyA5My45MTgyIDY4LjAxNzIgOTMuNDQ5NCA2OC4wMTcyIDkzLjEyMTNMNjQuNzQ3NyAxMDcuNjE3SDYxLjI0MzdMNTcuOTk3NyA5My4xMjEzQzU3Ljk5NzcgOTMuNDQ5NCA1OC4wMDE2IDkzLjkxODIgNTguMDA5NCA5NC41Mjc1QzU4LjAxNzIgOTUuMTI5MSA1OC4wMjExIDk1LjU5NzggNTguMDIxMSA5NS45MzM4VjEwNy42MTdaTTc2LjgyNzMgOTAuMzQzOUg4MC40MTMzVjEwNy42MTdINzYuODI3M1Y5MC4zNDM5Wk0xMDAuMTU3IDEwNy42MTdIOTYuNTQ3Nkw4OS40OTMgOTUuMzQ3OFYxMDcuNjE3SDg2LjEyOTdWOTAuMzQzOUg4OS45MTQ4TDk2Ljc5MzcgMTAyLjQwM1Y5MC4zNDM5SDEwMC4xNTdWMTA3LjYxN1pNMTE3Ljk1NSAxMDAuMDdIMTA5LjU2NVYxMDQuNTEySDExOS4xMjdWMTA3LjYxN0gxMDYuMDM3VjkwLjM0MzlIMTE4LjcwNVY5My40MDI1SDEwOS41NjVWOTcuMDcwNUgxMTcuOTU1VjEwMC4wN1oiIGZpbGw9IiNGRkM1QzUiLz4KPC9zdmc+Cg=="/>
            </div>
          </label>
          <input id="file-outline" type="file"/>
          <label for="file-stamp" class="svg-file-uploader">
            <div>and an SVG of your cookie stamp</div>
            <div id="stamp">
              <img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTczIiBoZWlnaHQ9IjE3NCIgdmlld0JveD0iMCAwIDE3MyAxNzQiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+CjxwYXRoIGZpbGwtcnVsZT0iZXZlbm9kZCIgY2xpcC1ydWxlPSJldmVub2RkIiBkPSJNNzUuMDc4MiAxNjUuNDU2TDg2LjA1MTMgMTQ4LjczNUw5Ni43MjcyIDE2NS42NDdMODUuODQxMSAxNzIuNTE5TDc1LjA3ODIgMTY1LjQ1NlpNNzIuNDU2NyAyNi41NzM2QzY3LjA2NDEgMjIuOTM3NSA2MC40MzgyIDIwLjUgNTMuMjc1NyAyMC41QzM1LjE3NDIgMjAuNSAyMC41IDQwLjk4NDggMjAuNSA2MS40Njk2QzIwLjUgMTA1LjcxNyA4Ni4wNTEzIDE0OC43MzUgODYuMDUxMyAxNDguNzM1Qzc1LjA3ODIgMTY1LjQ1NiA3NS4wNzQxIDE2NS40NTMgNzUuMDY5NyAxNjUuNDVMNzUuMDU5NyAxNjUuNDQ0TDc1LjAzNTIgMTY1LjQyN0w3NC45NjgzIDE2NS4zODNDNzQuOTE1NyAxNjUuMzQ4IDc0Ljg0NzQgMTY1LjMwMyA3NC43NjM4IDE2NS4yNDdDNzQuNTk2NyAxNjUuMTM2IDc0LjM2ODQgMTY0Ljk4MyA3NC4wODMxIDE2NC43ODlDNzMuNTEyNiAxNjQuNDAyIDcyLjcxMjggMTYzLjg1MiA3MS43MTY0IDE2My4xNUM2OS43MjU4IDE2MS43NDggNjYuOTM4OCAxNTkuNzMgNjMuNjE5NSAxNTcuMTc4QzU3LjAxNDEgMTUyLjEgNDguMTM0OSAxNDQuNzgyIDM5LjE3NzkgMTM1Ljg4MUMzMC4yODM2IDEyNy4wNDIgMjAuODczMSAxMTYuMjExIDEzLjU4NjkgMTA0LjA1MkM2LjM1NDMzIDkxLjk4MjcgMC41IDc3LjQwOTMgMC41IDYxLjQ2OTZDMC41IDQ2LjY5NTcgNS43MDE3NiAzMi4xNzY0IDE0LjI2OTQgMjEuMDgwMUMyMi43ODIxIDEwLjA1NSAzNi4yOTE1IDAuNSA1My4yNzU3IDAuNUM2Ni4xNzc0IDAuNSA3Ny41MzQ0IDUuMjkwMTkgODYuMTM4NSAxMS43Nzc1Qzk0LjY1MzcgNS4zNTQ3OSAxMDUuOTMyIDAuNSAxMTguODI3IDAuNUMxMzUuOTUyIDAuNSAxNDkuNDUgMTAuMzAzNSAxNTcuODcyIDIxLjI4NDZDMTY2LjM2NiAzMi4zNTg2IDE3MS42MDMgNDYuODQzOCAxNzEuNjAzIDYxLjQ2OTZDMTcxLjYwMyA5My4xMjc5IDE0OS43MTcgMTIwLjAxOSAxMzIuODM1IDEzNi41ODVDMTIzLjgzMyAxNDUuNDE4IDExNC45MTEgMTUyLjYwMyAxMDguMjcyIDE1Ny41NjhDMTA0LjkzNiAxNjAuMDY0IDEwMi4xMzMgMTYyLjAzIDEwMC4xMjggMTYzLjM5NkM5OS4xMjQ4IDE2NC4wOCA5OC4zMTgyIDE2NC42MTUgOTcuNzQxMSAxNjQuOTkzQzk3LjQ1MjUgMTY1LjE4MSA5Ny4yMjEgMTY1LjMzMSA5Ny4wNTA3IDE2NS40NDFDOTcuMDA4OCAxNjUuNDY4IDk2Ljk3MDYgMTY1LjQ5MiA5Ni45MzYyIDE2NS41MTRDOTYuOTAwNiAxNjUuNTM3IDk2Ljg2OTEgMTY1LjU1NyA5Ni44NDE2IDE2NS41NzRMOTYuNzcyNCAxNjUuNjE4TDk2Ljc0NjcgMTY1LjYzNUw5Ni43MzYyIDE2NS42NDFDOTYuNzMxNiAxNjUuNjQ0IDk2LjcyNzIgMTY1LjY0NyA4Ni4wNTEzIDE0OC43MzVDODYuMDUxMyAxNDguNzM1IDE1MS42MDMgMTA3LjM1NSAxNTEuNjAzIDYxLjQ2OTZDMTUxLjYwMyA0MS4zOTQ1IDEzNi45MjggMjAuNSAxMTguODI3IDIwLjVDMTExLjcyMSAyMC41IDEwNS4xNDQgMjIuOTYyIDk5Ljc3NSAyNi42MDE5QzkxLjQ2NjIgMzIuMjM0OSA4Ni4wNTEzIDQwLjY4ODkgODYuMDUxMyA0Ny4yMDUxQzg2LjA1MTMgNDAuNDc1MSA4MC42OTI0IDMyLjEyNjYgNzIuNDU2NyAyNi41NzM2WiIgZmlsbD0iI0ZGQzVDNSIvPgo8cGF0aCBkPSJNNzguMzM5MSA3My42MTc0SDcwLjUxMDlWNTYuMzQzOUg3OC45MDE2QzgxLjAxODcgNTYuMzc1MiA4Mi41MTg3IDU2Ljk4ODUgODMuNDAxNiA1OC4xODM4QzgzLjkzMjggNTguOTE4MiA4NC4xOTg0IDU5Ljc5NzEgODQuMTk4NCA2MC44MjA1Qzg0LjE5ODQgNjEuODc1MiA4My45MzI4IDYyLjcyMjggODMuNDAxNiA2My4zNjM1QzgzLjEwNDcgNjMuNzIyOCA4Mi42NjcyIDY0LjA1MSA4Mi4wODkxIDY0LjM0NzhDODIuOTcxOSA2NC42NjgyIDgzLjYzNTkgNjUuMTc2IDg0LjA4MTIgNjUuODcxM0M4NC41MzQ0IDY2LjU2NjYgODQuNzYwOSA2Ny40MTAzIDg0Ljc2MDkgNjguNDAyNUM4NC43NjA5IDY5LjQyNiA4NC41MDMxIDcwLjM0MzkgODMuOTg3NSA3MS4xNTY0QzgzLjY1OTQgNzEuNjk1NSA4My4yNDkyIDcyLjE0ODYgODIuNzU3IDcyLjUxNThDODIuMjAyMyA3Mi45Mzc3IDgxLjU0NjEgNzMuMjI2NyA4MC43ODgzIDczLjM4M0M4MC4wMzgzIDczLjUzOTIgNzkuMjIxOSA3My42MTc0IDc4LjMzOTEgNzMuNjE3NFpNNzguMjU3IDY2LjAxMTlINzMuOTU2MlY3MC42MTc0SDc4LjE5ODRDNzguOTU2MiA3MC42MTc0IDc5LjU0NjEgNzAuNTE1OCA3OS45NjggNzAuMzEyN0M4MC43MzM2IDY5LjkzNzcgODEuMTE2NCA2OS4yMTg5IDgxLjExNjQgNjguMTU2NEM4MS4xMTY0IDY3LjI1OCA4MC43NDUzIDY2LjY0MDggODAuMDAzMSA2Ni4zMDQ5Qzc5LjU4OTEgNjYuMTE3NCA3OS4wMDcgNjYuMDE5NyA3OC4yNTcgNjYuMDExOVpNODAuMDUgNjIuNzE4OUM4MC41MTg3IDYyLjQzNzcgODAuNzUzMSA2MS45MzM4IDgwLjc1MzEgNjEuMjA3MkM4MC43NTMxIDYwLjQwMjUgODAuNDQwNiA1OS44NzEzIDc5LjgxNTYgNTkuNjEzNUM3OS4yNzY2IDU5LjQzMzggNzguNTg5MSA1OS4zNDM5IDc3Ljc1MzEgNTkuMzQzOUg3My45NTYyVjYzLjE1MjVINzguMTk4NEM3OC45NTYyIDYzLjE1MjUgNzkuNTczNCA2My4wMDggODAuMDUgNjIuNzE4OVpNMTAyLjIyIDY2LjA3MDVIOTMuODI4OVY3MC41MTE5SDEwMy4zOTFWNzMuNjE3NEg5MC4zMDE2VjU2LjM0MzlIMTAyLjk3VjU5LjQwMjVIOTMuODI4OVY2My4wNzA1SDEwMi4yMlY2Ni4wNzA1Wk01OC4wMjExIDEwNy42MTdINTQuNjU3OFY5MC4zNDM5SDU5LjkwNzhMNjMuMDQ4NCAxMDMuOTI2TDY2LjE2NTYgOTAuMzQzOUg3MS4zNTdWMTA3LjYxN0g2Ny45OTM4Vjk1LjkzMzhDNjcuOTkzOCA5NS41OTc4IDY3Ljk5NzcgOTUuMTI5MSA2OC4wMDU1IDk0LjUyNzVDNjguMDEzMyA5My45MTgyIDY4LjAxNzIgOTMuNDQ5NCA2OC4wMTcyIDkzLjEyMTNMNjQuNzQ3NyAxMDcuNjE3SDYxLjI0MzhMNTcuOTk3NyA5My4xMjEzQzU3Ljk5NzcgOTMuNDQ5NCA1OC4wMDE2IDkzLjkxODIgNTguMDA5NCA5NC41Mjc1QzU4LjAxNzIgOTUuMTI5MSA1OC4wMjExIDk1LjU5NzggNTguMDIxMSA5NS45MzM4VjEwNy42MTdaTTc2LjgyNzMgOTAuMzQzOUg4MC40MTMzVjEwNy42MTdINzYuODI3M1Y5MC4zNDM5Wk0xMDAuMTU3IDEwNy42MTdIOTYuNTQ3N0w4OS40OTMgOTUuMzQ3OFYxMDcuNjE3SDg2LjEyOTdWOTAuMzQzOUg4OS45MTQ4TDk2Ljc5MzggMTAyLjQwM1Y5MC4zNDM5SDEwMC4xNTdWMTA3LjYxN1pNMTE3Ljk1NSAxMDAuMDdIMTA5LjU2NVYxMDQuNTEySDExOS4xMjdWMTA3LjYxN0gxMDYuMDM4VjkwLjM0MzlIMTE4LjcwNVY5My40MDI1SDEwOS41NjVWOTcuMDcwNUgxMTcuOTU1VjEwMC4wN1oiIGZpbGw9IiNGRjMyMzIiLz4KPC9zdmc+Cg=="/>
            </div>
          </label>
          <input id="file-stamp" type="file"/>
          <div id="go">
            <button disabled id="generate-cookie-cutter">Generate my cookie cutter plz</button>
          </div>
        </div>
      </section>
      <section id="generation" class="hide">
        <div id="viewer">
          <video id="stream" src=""/>
        </div>
        <div style="display: flex; flex-direction: column; gap: 10px;">
          <div id="gimmie">
            <button id="download" class="center">
              <div class="center">
                <img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNDQiIGhlaWdodD0iNDQiIHZpZXdCb3g9IjAgMCA0NCA0NCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHBhdGggZmlsbC1ydWxlPSJldmVub2RkIiBjbGlwLXJ1bGU9ImV2ZW5vZGQiIGQ9Ik0yMS41MjU1IDM5LjY0NTZMMjAuMDA3MSAzOC4xMjcyTDEyLjQ5MSAzMC42MTExTDE1LjUyNzkgMjcuNTc0MUwxOS4zNzgxIDMxLjQyNDNWNi41NDQ0M0gyMy42NzNWMzEuNDI0M0wyNy41MjMxIDI3LjU3NDFMMzAuNTYwMSAzMC42MTExTDIzLjA0NCAzOC4xMjcyTDIxLjUyNTUgMzkuNjQ1NloiIGZpbGw9IiNGRkZDRkMiLz4KPC9zdmc+Cg=="/>
                <span>Gimme the file</span>
              </div>
            </button>
          </div>
          <div id="again">
            <button id="try-again" class="secondary center">
              <div class="center">
                <img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNDMiIGhlaWdodD0iNDMiIHZpZXdCb3g9IjAgMCA0MyA0MyIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHBhdGggZmlsbC1ydWxlPSJldmVub2RkIiBjbGlwLXJ1bGU9ImV2ZW5vZGQiIGQ9Ik0yLjk1NjUzIDIxLjUyNTVMNC40NzUgMjAuMDA3TDExLjk5MTEgMTIuNDkxTDE1LjAyOCAxNS41Mjc5TDExLjE3NzkgMTkuMzc4MUwzNi4wNTc3IDE5LjM3ODFMMzYuMDU3NyAyMy42NzI5TDExLjE3NzkgMjMuNjcyOUwxNS4wMjggMjcuNTIzMUwxMS45OTExIDMwLjU2TDQuNDc1IDIzLjA0NEwyLjk1NjUzIDIxLjUyNTVaIiBmaWxsPSIjRkYzMjMyIi8+Cjwvc3ZnPgo="/>
                <span>Try again</span>
              </div>
            </button>
          </div>
        </div>
      </section>
      <footer>
        <p>
          This <a href="https://github.com/kittycad/cookie-cutter/" target="_blank" rel="noopener noreferrer">open-source app</a> was built in a few days by <a href="https://github.com/lf94" target="_blank" rel="noopener noreferrer">Lee</a> & <a href="https://github.com/franknoirot" target="_blank" rel="noopener noreferrer">Frank</a> thanks to the <a href="https://zoo.dev/design-api">KittyCAD Design API</a>.
        </p>
        <p>
          Learn how to build something at <a href="https://zoo.dev">zoo.dev</a>
        </p>
      </footer>
    </div>

    <script>
    let ws, pc, dc;
    let mediaStream;
    let isGenerating = false;
    let svgs = {};
    const TOKEN_COOKIE_NAME = '__Secure-next-auth.session-token'
    const ZOO_USER_KEY = 'ZOO_USER'
    const DOMAIN = window.location.origin.includes('localhost') ? '.dev.zoo.dev' : '.zoo.dev'

    const signInDiv = document.getElementById("sign-in");
    const accountDiv = document.getElementById("account");
    const avatarImg = document.getElementById("avatar");
    const usernamePara = document.getElementById("user-name");
    const emailPara = document.getElementById("user-email");
    const signOutBtn = document.getElementById("sign-out");
    const generateBtn = document.getElementById("generate-cookie-cutter");
    const downloadBtn = document.getElementById("download");
    const tryAgainBtn = document.getElementById("try-again");
    const fileOutline = document.getElementById("file-outline");
    const fileStamp = document.getElementById("file-stamp");
    const streamEl = document.getElementById("stream");
    const configurationSection = document.getElementById("configuration")
    const generationSection = document.getElementById("generation")

    const signIn = (user) => {
      signInDiv.classList.add("hide");
      accountDiv.classList.remove("hide");
      document.body.classList.add("signed-in");
      
      if (user.image) {
        avatarImg.src = user.image;
      }
      usernamePara.textContent = user.first_name ? (user.first_name + " " + user.last_name) : user.name;
      emailPara.textContent = user.email;
    };

    const signOut = async () => {
      await fetch(`https://api${DOMAIN}/logout`, {
        method: 'POST',
        credentials: 'include',
      })
    }

    const signOutUI = () => {
      signInDiv.classList.remove("hide");
      accountDiv.classList.add("hide");
      document.body.classList.remove("signed-in");
      localStorage.removeItem(ZOO_USER_KEY)
    };

    window.addEventListener("load", async () => {
      const userInLocalStorage = localStorage.getItem(ZOO_USER_KEY)
      if (userInLocalStorage) {
        signIn(JSON.parse(userInLocalStorage))
        return
      }

      const user = await fetch(`https://api${DOMAIN}/user`, {
        credentials: 'include',
      }).then(res => res.json())

      if (user && !user.error_code) {
        localStorage.setItem(ZOO_USER_KEY, JSON.stringify(user))
        signIn(user)
      } else {
        signOutUI()
      }
    });

    signOutBtn.addEventListener("click", async () => {
      await signOut()
      signOutUI()
      window.location.reload()
    });

    const fileUploadHandler = (elId) => (event) => {
      const file = event.target.files[0];
      const reader = new FileReader();

      reader.onload = (event) => {
        const fileContents = event.target.result;
        svgs[elId] = fileContents;
        document.getElementById(elId).innerHTML = fileContents;

        if (Object.keys(svgs).length == 2) {
          // Unlock the generate button.
          generateBtn.disabled = undefined;
        }
      };
      reader.readAsText(file);
    };

    fileOutline.addEventListener("change", fileUploadHandler("outline"));
    fileStamp.addEventListener("change", fileUploadHandler("stamp"));

    configurationSection.addEventListener("animationend", (event) => {
      if (event.animationName === "fade-out") {
        configurationSection.classList.add("hide");
        generationSection.classList.remove("hide");
        generationSection.classList.add("fade-in");
      }
    });
    generationSection.addEventListener("animationend", (event) => {
      if (event.animationName === "fade-out") {
        generationSection.classList.add("hide");
        configurationSection.classList.remove("hide");
        configurationSection.classList.add("fade-in");
      }
    });

    let isMouseActive = false;
    const pointerEventToKCCameraDrag = {
      pointerdown: "camera_drag_start",
      pointermove: "camera_drag_move",
      pointerup: "camera_drag_end",
    };

    let sequence = 0;
    const pointerHandler = (eventName) => (event) => {

      if (!dc) return;

      if (eventName === "pointermove" && isMouseActive === false) return;
      if (eventName === "pointerdown") {
        isMouseActive = true;
        streamPlayback(true);
      }
      if (eventName === "pointerup") {
        isMouseActive = false;
        streamPlayback(false);
      }

      if (eventName === "pointermove") {
        sequence += 1;
        const message = {
          type: "modeling_cmd_req",
          cmd_id: uuidV4(),
          cmd: {
            type: pointerEventToKCCameraDrag[eventName],
            interaction: "rotate",
            sequence,
            window: { x: Math.max(0, event.offsetX), y: Math.max(0, event.offsetY) },
          },
        };
        dc.send(JSON.stringify(message));
      } else {
        const message = {
          type: "modeling_cmd_req",
          cmd_id: uuidV4(),
          cmd: {
            type: pointerEventToKCCameraDrag[eventName],
            interaction: "rotate",
            window: { x: Math.max(0, event.offsetX), y: Math.max(0, event.offsetY) },
          },
        };
        ws.send(JSON.stringify(message));
      }
    };

    streamEl.addEventListener("pointermove", pointerHandler("pointermove"), { passive: false });
    streamEl.addEventListener("pointerdown", pointerHandler("pointerdown"), { passive: false });
    streamEl.addEventListener("pointerup", pointerHandler("pointerup"), { passive: false });

    const streamPlayback = (isPlaying) => {
      // Because iPhones ruin the UX, disable this.
      if (!isPlaying) return;

      if (!isPlaying) {
        streamEl.pause();
        mediaStream.getTracks().forEach(track => {
          track.enabled = false;
        });
      } else {
        mediaStream.getTracks().forEach(track => {
          track.enabled = true;
        });
        streamEl.play();
      }
    }

    generateBtn.addEventListener("click", () => {
      isGenerating = true;
      generateBtn.disabled = "disabled";
      fileOutline.disabled = "disabled";
      fileStamp.disabled = "disabled";
      configurationSection.classList.add("fade-out");
      generateCookieCutter();
    });

    downloadBtn.addEventListener("click", () => {
      window["export"]({
        entity_ids: [],
        source_unit: "mm",
        format: {
          type: "stl",
          coords: {
            forward: {
              axis: 'y',
              direction: 'negative',
            },
            up: {
              axis: 'z',
              direction: 'positive',
            },
          },
          units: "mm",
          storage: "ascii",
          selection: { type: "default_scene" },
          presentation: "pretty",
        }
      });
    });

    tryAgainBtn.addEventListener("click", () => {
      window.location.href = "/";
    });

    const generateCookieCutter = () => {
      const svgTextOutline = svgs["outline"];
      const svgTextStamp = svgs["stamp"];

      KittyCADClient(localStorage.getItem("token"), () => {
        console.log("Generating cookie cutter...");

        const parser = new DOMParser();
        const svgOutline = parser.parseFromString(svgTextOutline, "text/xml").children[0];
        const svgStamp = parser.parseFromString(svgTextStamp, "text/xml").children[0];

        default_camera_zoom({ magnitude: -25 });
        default_camera_look_at({
          center: { x: 0, y: 0, z: 0 },
          up: { x: 0, y: 0, z: 1 },
          vantage: { x: 0, y: -100, z: 75 },
        });

        // These MUST be called inside here. The svg2kc makes API calls that
        // rely on the KittyCAD client being initialized.

        // This first call only draws the 1st path encountered, which
        // will act as our base.
        const baseId = svg2KCApiCalls(svgOutline, { firstOnly: true });

        // Hold off creating the outline and stamp until we find the top face
        const shapes = (topFace) => {
          // The rest are drawn on top of this.
          svg2KCApiCalls(svgOutline, { topFace, extrudeHeight: 7 });
          svg2KCApiCalls(svgStamp, { topFace, extrudeHeight: 4 });

          // Stop the stream, save on bandwidth
          setTimeout(() => {
            streamPlayback(false);
          }, 5000);
        };

        let found = false;

        entity_get_all_child_uuids({ entity_id: baseId }, (data) => {
          edit_mode_enter({ target: baseId });

          for (let entity_id of data.resp.data.modeling_response.data.entity_ids) {
            if (found) break;
            get_entity_type({ entity_id }, (data) => {
              if (data.resp.data.modeling_response.data.entity_type === "edge") {
                solid3d_get_extrusion_face_info({ edge_id: entity_id, object_id: baseId }, (data) => {
                  for (let face of data.resp.data.modeling_response.data.faces) {
                    if (found) break;
                    if (face.cap === "top") {
                      found = true;
                      shapes(face.face_id);
                    }
                  }
                });
              }
            });
          }
        });

      });
    };


                         /////////////||\\\\\\\\\\\\\\
                        //    KITTYCAD CLIENT CODE   \\
                       ///////////////||\\\\\\\\\\\\\\\\
                       //                             \\
                       //    |\      _,,,---,,_       \\
                       //    /,`.-'`'    -.  ;-;;,_   \\
                       //   |,4-  ) )-,_..;\ (  `'-'  \\
                       //  '---''(_/--'  `-'\_)       \\ Art by Felix Lee
                       ///////////////||\\\\\\\\\\\\\\\\

    let cmds = {};
    let cbs = {};

    // Add more as needed or as they become available
    const commands = [ "make_axes_gizmo", "make_plane", "sketch_mode_enable",
    "start_path", "move_path_pen", "extend_path", "close_path", "sketch_mode_disable",
    "extrude", "export", "modeling_cmd_req", "reconfigure_stream",
    "import_files", "default_camera_zoom", "object_bring_to_front",
    "default_camera_focus_on", "default_camera_zoom", "solid2d_add_hole",
    "default_camera_enable_sketch_mode", "default_camera_disable_sketch_mode",
    "default_camera_look_at", "entity_get_all_child_uuids",
    "solid3d_get_extrusion_face_info", "edit_mode_enter", "edit_mode_exit",
    "get_entity_type", "enable_sketch_mode"];

    // Create the functions for ease of use
    for (const command of commands) {
      cmds[command] = (args, cb) => {
        const payload = {
          cmd: {
            type: command,
            ...args
          },
          cmd_id: uuidV4(),
          type: "modeling_cmd_req"
        };

        // Call this callback when the server responds with the same cmd_id
        if (cb) cbs[payload.cmd_id] = cb;

        ws.send(JSON.stringify(payload));
        return payload.cmd_id;
      };
    };

    // Let's make all the command functions part of the global namespace.
    // Allows for doing this like start_path(), extend_path(), etc.
    Object.assign(window, cmds);

    const KittyCADClient = (sessionKey, fnCmds) => {
      const queue = [];
      const modeling_cmd_batch_req = (args) => {
        let requests = [];
        let a;
        while ((a = queue.shift()) != "batch_end") {
          requests.push(a);
        }
        const payload = {
          requests,
          type: "modeling_cmd_batch_req"
        };
        return queue.push(payload);
      }

      const te = new TextEncoder();

      const send = (payload) => {
        let data;

        // Decode both to be re-encoded shortly.
        if (payload instanceof ArrayBuffer) {
          payload = JSON.parse(td.decode(payload));
        }

        if (typeof payload === "string") {
          payload = JSON.parse(payload);
        }

        data = JSON.stringify(payload);

        if (payload.cmd && payload.cmd.type == "import_files") {
          payload.cmd.files.forEach((f) => {
            // Yep, .data.data was a pain to learn.
            // Caused by serializing from Buffer to JSON and back.
            f.data = Buffer.from(f.data.data);
          });
          data = BSON.serialize(payload);
        }

        ws.send(data);
      };

      const close = () => {
        dc.close();
        pc.close();
        ws.close();
      };

      let handlers = {};
      handlers["ice_server_info"] = (args) => {
        const ice_servers = args.ice_servers;

        pc = new RTCPeerConnection()

        pc.addEventListener("icecandidate", (event) => {
          if (!event.candidate) return;
          send({
            type: "trickle_ice",
            candidate: event.candidate.toJSON()
          });
        });

        pc.addEventListener("connectionstatechange", (event) => {
          if (event.target?.connectionState !== "connected") return;
          streamEl.srcObject = mediaStream;
          streamEl.play();
        });

        pc.addEventListener("track", (event) => {
          mediaStream = event.streams[0];
        });

        pc.setConfiguration({
          iceServers: ice_servers,
          iceTransportPolicy: 'relay',
        });

        // If you don't do this, your offer may not include what
        // it needs to establish it ;) (it'll fail)
        pc.createDataChannel("unreliable_modeling_cmds");

        pc.addEventListener("datachannel", (event) => {
          dc = event.channel;

          dc.addEventListener("open", () => {
            console.log("unreliable_modeling_cmds open");

            if (fnCmds) {
              fnCmds();
              ignition();
            }
          });
        });

        pc.addTransceiver('video', {
          direction: 'recvonly',
        })

        pc.createOffer().then((offer) => {
          return pc.setLocalDescription(offer).then(() => {
            send({
              type: 'sdp_offer',
              offer,
            })
          });
        });

      };
      handlers["trickle_ice"] = (args) => {
        const candidate = args.candidate;
        pc.addIceCandidate(candidate);
      };
      handlers["sdp_answer"] = (args) => {
        const answer = args.answer
        pc.setRemoteDescription(answer);
      };
      handlers["modeling"] = (args) => {
        if (queue.length == 0) return;

        // Continue to fire off commands in the queue.
        let cmd = queue.shift();

        // Unload the batch into the queue as a single command.
        if (cmd == "batch_start") {
          modeling_cmd_batch_req();
          cmd = queue.shift();
        }

        console.log(cmd);
        send(cmd);
      };

      const generateAndDownload = (data) => {
        const blob = new Blob([data], { type: 'model/stl' });
        const link = document.createElement('a');
        link.href = URL.createObjectURL(blob);
        link.download = 'cookie-cutter.stl';
        link.click();
      }

      handlers["export"] = (args) => {
        const file = args.files[0];
        generateAndDownload(file.contents.buffer);
        //fs.writeFileSync(file.name, file.contents.read(0, file.contents.length));
      };

      const url = `wss://api${DOMAIN}/ws/modeling/commands?video_res_width=348&video_res_height=272`;
      ws = new WebSocket(url, []);
      ws.binaryType = "arraybuffer";

      ws.addEventListener("error", (e) => console.log("error", e));
      ws.addEventListener("upgrade", (e) => console.log("upgrade"));
      ws.addEventListener("open", () => {
        // Used for development / testing other session keys
        if (sessionKey) {
          send({ headers: { Authorization: `Bearer ${sessionKey}` } })
        }
      });
      ws.addEventListener("close", (e) => console.log("close", e));

      const td = new TextDecoder();
      const noop = () => {};

      ws.addEventListener("message", (event) => {
        const chunk = event.data;
        let obj;
        if (chunk instanceof ArrayBuffer) {
          // console.log("ArrayBuffer");
          obj = BSON.deserialize(chunk);
        } else {
          obj = JSON.parse(chunk);
        }

        if (obj.success) {
          (handlers[obj.resp.type] || console.log)(obj.resp.data);

          // Run any callbacks associated with this request_id (cmd_id)
          (cbs[obj.request_id] || noop)(obj);
        } else {
          console.log(obj);
          // Reignite the queue command launcher on any failures.
          ignition();
        }
      });

      setInterval(() => { console.log("ping"); send({ type: "ping" }); }, 10000);
      ws.addEventListener("pong", () => console.log("pong"));

      // Kick off the requests.
      const ignition = () => {
        if (queue.length == 0) return;
        const cmd = queue.shift();
        //console.log(cmd);
        send(cmd);
      };
    };

     //               SVG2KCAPI
     //                 _
     //                \`*-.
     //                 )  _`-.
     //                .  : `. .
     //                : _   '  \
     //                ; *` _.   `*-._
     //                `-.-'          `-.
     //                  ;       `       `.
     //                  :.       .        \
     //                  . \  .   :   .-'   .
     //                  '  `+.;  ;  '      :
     //                  :  '  |    ;       ;-.
     //                  ; '   : :`-:     _.`* ;
     //         [bug] .*' /  .*' ; .*`- +'  `*'
     //               `*-*   `*-*  `*-*'       

    Array.prototype.chunks = function(chunkSize) {
      const a = [];

      for (let i = 0; i < this.length; i += chunkSize) {
          const chunk = this.slice(i, i + chunkSize);
          a.push(chunk);
      }

      return a;
    };

    class Position {
      x = 0;
      y = 0;
    }

    class Circle {
      position = new Position();
      radius = 0;
    }

    class Ellipse {
      position = new Position();
      radius_x = 0;
      radius_y = 0;
    }

    const Command = {
      NotSet: "NotSet",
      MoveAbsolute: "MoveAbsolute",
      MoveRelative: "MoveRelative",
      LineAbsolute: "LineAbsolute",
      LineRelative: "LineRelative",
      HorizontalLineAbsolute: "HorizontalLineAbsolute",
      HorizontalLineRelative: "HorizontalLineRelative",
      VerticalLineAbsolute: "VerticalLineAbsolute",
      VerticalLineRelative: "VerticalLineRelative",
      QuadraticBezierAbsolute: "QuadraticBezierAbsolute",
      QuadraticBezierRelative: "QuadraticBezierRelative",
      QuadraticBezierSmoothAbsolute: "QuadraticBezierSmoothAbsolute",
      QuadraticBezierSmoothRelative: "QuadraticBezierSmoothRelative",
      CubicBezierAbsolute: "CubicBezierAbsolute",
      CubicBezierRelative: "CubicBezierRelative",
      CubicBezierSmoothAbsolute: "CubicBezierSmoothAbsolute",
      CubicBezierSmoothRelative: "CubicBezierSmoothRelative",
      EllipticalArcAbsolute: "EllipticalArcAbsolute",
      EllipticalArcRelative: "EllipticalArcRelative",
      StopAbsolute: "StopAbsolute",
      StopRelative: "StopRelative",
    }

    class PathState {
      command = Command.NotSet;
      values = [];
      value_buffer = "";

      // Handles the case of whitespace preceding a command, because detecting a new
      // command will also cause the value to be pushed to the values stack.
      is_value_already_pushed = false;

      // See the terminology at https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/d#moveto_path_commands
      current_point = new Position();

      constructor(pathId, offsetCoords) {
        this.pathId = pathId;
        this.offsetCoords = offsetCoords ?? { x: 0, y: 0 };
      }

      push_value() {
        // Don't push anything if there is nothing buffered.
        if (this.value_buffer.length == 0) {
          return;
        }

        let value = parseFloat(this.value_buffer);
        this.values.push(value);
        this.value_buffer = "";
      }

      push_command(command) {
        if (this.value_buffer != "") {
          this.push_value();
          this.is_value_already_pushed = true;
        }

        this.handle_command();

        let current_point = this.current_point;
        this.values = [];
        this.value_buffer = "";
        this.is_value_already_pushed = false;
        this.command = command;
        this.current_point = current_point;
      }

      handle_command() {
        // Do things based on the command
        // console.log(this)
        switch (this.command) {
          case Command.NotSet: { break; /* Do nothing when the command is not set. */ }
          case Command.MoveAbsolute: {
            for (let args of this.values.chunks(2)) {
              this.current_point.x = args[0];
              this.current_point.y = args[1];

              move_path_pen({
                path: this.pathId,
                to:  {
                  x: this.current_point.x + this.offsetCoords.x,
                  y: -this.current_point.y + this.offsetCoords.y,
                  z: 0,
                }
              });
            }
            break;
          }
          case Command.MoveRelative: {
            for (let args of this.values.chunks(2)) {
              this.current_point.x += args[0];
              this.current_point.y += args[1];
              
              move_path_pen({
                path: this.pathId,
                to: {
                  x: this.current_point.x + this.offsetCoords.x,
                  y: -this.current_point.y + this.offsetCoords.y,
                  z: 0,
                }
              });
            }
            break;
          }
          case Command.LineAbsolute: {
            for (let args of this.values.chunks(2)) {
              this.current_point.x = args[0];
              this.current_point.y = args[1];
              
              extend_path({
                path: this.pathId,
                segment:  {
                  type: "line",
                  end: {
                    x: this.current_point.x + this.offsetCoords.x,
                    y: -this.current_point.y + this.offsetCoords.y,
                    z: 0,
                  },
                  relative: false
                }
              });
            }
            break;
          }
          case Command.LineRelative: {
            for (let args of this.values.chunks(2)) {
              this.current_point.x += args[0];
              this.current_point.y += args[1];
              
              extend_path({
                path: this.pathId,
                segment: {
                  type: "line",
                  end: {
                    x: this.current_point.x + this.offsetCoords.x,
                    y: -this.current_point.y + this.offsetCoords.y,
                    z: 0,
                  },
                  relative: false
                }
              });
            }
            break;
          }
          case Command.HorizontalLineAbsolute: {
            for (let args of this.values.chunks(2)) {
              this.current_point.x = args[0];
             
              extend_path({
                path: this.pathId,
                segment: {
                  type: "line",
                  end: {
                    x: this.current_point.x + this.offsetCoords.x,
                    y: -this.current_point.y + this.offsetCoords.y,
                    z: 0,
                  },
                  relative: false
                }
              });
            }
            break;
          }
          case Command.HorizontalLineRelative: {
            for (let args of this.values.chunks(2)) {
              this.current_point.x += args[0];
              
              extend_path({
                path: this.pathId,
                segment:  {
                  type: "line",
                  end: {
                    x: this.current_point.x + this.offsetCoords.x,
                    y: -this.current_point.y + this.offsetCoords.y,
                    z: 0,
                  },
                  relative: false
                }
              });
            }
            break;
          }
          case Command.VerticalLineAbsolute: {
            for (let args of this.values.chunks(2)) {
              this.current_point.y = args[0];
              
              extend_path({
                path: this.pathId,
                segment: {
                  type: "line",
                  end: {
                    x: this.current_point.x + this.offsetCoords.x,
                    y: -this.current_point.y + this.offsetCoords.y,
                    z: 0,
                  },
                  relative: false
                }
              });
            }
            break;
          }
          case Command.VerticalLineRelative: {
            for (let args of this.values.chunks(2)) {
              this.current_point.y += args[0];
              
              extend_path({
                path: this.pathId,
                segment: {
                  type: "line",
                  end: {
                    x: this.current_point.x + this.offsetCoords.x,
                    y: -this.current_point.y + this.offsetCoords.y,
                    z: 0,
                  },
                  relative: false
                }
              });
            }
            break;
          }
          case Command.QuadraticBezierAbsolute: {
            for (let args of this.values.chunks(4)) {
              extend_path({
                path: this.pathId,
                segment: {
                  type: "bezier",
                  control1: {
                    x: args[0] + this.offsetCoords.x,
                    y: -args[1] + this.offsetCoords.y,
                    z: 0,
                  },
                  control2: {
                    x: args[0] + this.offsetCoords.x,
                    y: -args[1] + this.offsetCoords.y,
                    z: 0,
                  },
                  end: {
                    x: args[2] + this.offsetCoords.x,
                    y: -args[3] + this.offsetCoords.y,
                    z: 0,
                  },
                  relative: false
                }
              });

              this.current_point.x = args[2];
              this.current_point.y = args[3];
            }
            break;
          }
          case Command.QuadraticBezierRelative: {
            for (let args of this.values.chunks(4)) {
              if (args.length != 4) {
                // Should never happen but does because of how other software exports SVGs.
                break;
              }
              
              extend_path({
                path: this.pathId,
                segment: {
                  type: "bezier",
                  control1: {
                    x: this.current_point.x + args[0] + this.offsetCoords.x,
                    y: -(this.current_point.y + args[1]) + this.offsetCoords.y,
                    z: 0,
                  },
                  control2: {
                    x: this.current_point.x + args[0] + this.offsetCoords.x,
                    y: -(this.current_point.y + args[1]) + this.offsetCoords.y,
                    z: 0,
                  },
                  end: {
                    x: this.current_point.x + args[2] + this.offsetCoords.x,
                    y: -(this.current_point.y + args[3]) + this.offsetCoords.y,
                    z: 0,
                  },
                  relative: false
                }
              });

              this.current_point.x += args[2];
              this.current_point.y += args[3];
            }
            break;
          }
          case Command.QuadraticBezierSmoothAbsolute: { break; }
          case Command.QuadraticBezierSmoothRelative: { break; }
          case Command.CubicBezierAbsolute: {
            for (let args of this.values.chunks(6)) {
              extend_path({
                path: this.pathId,
                segment: {
                  type: "bezier",
                  control1: {
                    x: args[0] + this.offsetCoords.x,
                    y: -args[1] + this.offsetCoords.y,
                    z: 0,
                  },
                  control2: {
                    x: args[2] + this.offsetCoords.x,
                    y: -args[3] + this.offsetCoords.y,
                    z: 0,
                  },
                  end: {
                    x: args[4] + this.offsetCoords.x,
                    y: -args[5] + this.offsetCoords.y,
                    z: 0,
                  },
                  relative: false
                }
              });

              this.current_point.x = args[4];
              this.current_point.y = args[5];
            }
            break;
          }
          case Command.CubicBezierRelative: {
            for (let args of this.values.chunks(6)) {
              if (args.length != 6) {
                // Should never happen but does because of how other software exports SVGs.
                break;
              }
              
              extend_path({
                path: this.pathId,
                  segment: {
                  type: "bezier",
                  control1: {
                    x: this.current_point.x + args[0] + this.offsetCoords.x,
                    y: -(this.current_point.y + args[1]) + this.offsetCoords.y,
                    z: 0,
                  },
                  control2: {
                    x: this.current_point.x + args[2] + this.offsetCoords.x,
                    y: -(this.current_point.y + args[3]) + this.offsetCoords.y,
                    z: 0,
                  },
                  end: {
                    x: this.current_point.x + args[4] + this.offsetCoords.x,
                    y: -(this.current_point.y + args[5]) + this.offsetCoords.y,
                    z: 0,
                  },
                  relative: false
                }
              });

              this.current_point.x += args[4];
              this.current_point.y += args[5];
            }
            break;
          }
          case Command.CubicBezierSmoothAbsolute: { break; }
          case Command.CubicBezierSmoothRelative: { break; }
          case Command.EllipticalArcAbsolute: { break; }
          case Command.EllipticalArcRelative: { break; }
          case Command.StopAbsolute: {
            break;
          }
          case Command.StopRelative: {
            break;
          }
        }
      }
    }

    const svg2KCApiCalls = (svg, opts) => {
      let cutPathIds = [];
      let basePathId;
      let additionalPathIds = [];
      let translate = { x: 0, y: 0, };

      let escape = false;

      const startPathAndTrackSomeThings = (e, translate, opts) => {
        if (opts.topFace) enable_sketch_mode({ entity_id: opts.topFace, ortho: false, animated: true, adjust_camera: true });

        const pathId = start_path();

        const fillValue = e.style.fill || e.attributes.fill?.value;

        if (basePathId === undefined) {
          basePathId = pathId;
        } else if (fillValue === "none" || !fillValue) {
          additionalPathIds.push(pathId);
        } else if (fillValue !== "none") {
          cutPathIds.push(pathId);
        }

        // Used to center the object when being created
        const offsetCoords = {
          x: (parseFloat(svg.width.baseVal.valueInSpecifiedUnits) / -2) + translate.x,
          y: (parseFloat(svg.height.baseVal.valueInSpecifiedUnits) / 2) - translate.y,
        };

        return [pathId, offsetCoords];
      };

      const closePathAndCleanUp = (pathId, opts) => {
        close_path({ path_id: pathId });
        if (opts.topFace) sketch_mode_disable();
      };

      const traverse = (root) => {
        for (let e of root.children) {
          switch (e.tagName) {
            case "g": {
              if (e.transform.baseVal.length === 0) break;

              translate = {
                x: translate.x + e.transform.baseVal[0].matrix.e,
                y: translate.y + e.transform.baseVal[0].matrix.f,
              };
              break;
            }
            case "path": {
              for (let attr of e.attributes) {
                switch (attr.name) {
                  case "d": {
                    const [pathId, offsetCoords] = startPathAndTrackSomeThings(e, translate, opts);

                    let state = new PathState(pathId, offsetCoords);

                    // To handle the initial Command.NotSet, which has no values.
                    state.is_value_already_pushed = true;
                    
                    for (let char of attr.value.split("")) {
                      switch (char) {
                        case 'M': state.push_command(Command.MoveAbsolute); break;
                        case 'm': state.push_command(Command.MoveRelative); break;
                        case 'L': state.push_command(Command.LineAbsolute); break;
                        case 'l': state.push_command(Command.LineRelative); break;
                        case 'H': state.push_command(Command.HorizontalLineAbsolute); break;
                        case 'h': state.push_command(Command.HorizontalLineRelative); break;
                        case 'V': state.push_command(Command.VerticalLineAbsolute); break;
                        case 'v': state.push_command(Command.VerticalLineRelative); break;
                        case 'C': state.push_command(Command.CubicBezierAbsolute); break;
                        case 'c': state.push_command(Command.CubicBezierRelative); break;
                        case 'S': state.push_command(Command.CubicBezierSmoothAbsolute); break;
                        case 's': state.push_command(Command.CubicBezierSmoothRelative); break;
                        case 'Q': state.push_command(Command.QuadraticBezierAbsolute); break;
                        case 'q': state.push_command(Command.QuadraticBezierRelative); break;
                        case 'T': state.push_command(Command.QuadraticBezierSmoothAbsolute); break;
                        case 't': state.push_command(Command.QuadraticBezierSmoothRelative); break;
                        case 'A': state.push_command(Command.EllipticalArcAbsolute); break;
                        case 'a': state.push_command(Command.EllipticalArcRelative); break;
                        case 'Z': state.push_command(Command.StopAbsolute); break;
                        case 'z': state.push_command(Command.StopRelative); break;
                        case ',': {
                          state.push_value();
                          break;
                        }
                        case '-': {
                          state.push_value();
                          state.value_buffer += char;
                          break;
                        }
                        case ' ': {
                          state.push_value();
                          state.is_value_already_pushed = true;
                          break;
                        }

                        // Yep, thanks JS, for no multi-case on one line.
                        case '0': case '1': case '2': case '3': case '4': case '5': case '6': case '7': case '8': case '9':
                        case '.': {
                          state.value_buffer += char;
                          break;
                        }
                      }

                      switch (state.command) {
                        case Command.StopAbsolute:
                        case Command.StopRelative: {
                          state.push_value();
                          state.handle_command();
                          break;
                        }
                      }
                    } // for

                    // It's possible we stopped without processing the last command
                    // because some programs generate without Z or z command.
                    // We know this if there is still data in the value buffer.
                    // Pushing a fake Z or z command will resolve the issue.
                    if (state.value_buffer.length > 0) {
                      state.push_value();
                      state.push_command(Command.StopAbsolute);
                    }

                    closePathAndCleanUp(pathId, opts);

                    if (opts.firstOnly) escape = true;
                    break;
                  }
                }

                if (escape) break;
              }
            }
          }

          if (escape) break;

          traverse(e);
        }
      };

      // It is 1:24am and I am getting my second wind
      traverse(svg);

      cutPathIds.forEach((pathId) => solid2d_add_hole({ hole_id: pathId, object_id: basePathId }));
      extrude({ target: basePathId, distance: opts.firstOnly ? 2 : opts.extrudeHeight, cap: true })
      additionalPathIds.forEach((pathId) => extrude({ target: pathId, distance: opts.extrudeHeight, cap: true }));

      return basePathId;
    }
    </script>
    <script defer data-domain="cookie-cutter.zoo.dev" src="https://plausible.corp.zoo.dev/js/script.js"></script>
  </body>
</html>
